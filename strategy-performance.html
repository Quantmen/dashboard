<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Strategy Performance</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        html, body { width: 100%; height: 100%; overflow: hidden; }
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            background: #f8fafc;
            color: #1e293b;
        }
        .main-content {
            overflow-y: auto;
            overflow-x: hidden;
            padding: 16px 32px 32px 32px;
            background: #f8fafc;
            height: 100vh;
            width: 100%;
        }
        .page-header { margin-bottom: 16px; }
        .page-title { font-size: 20px; font-weight: 700; color: #111827; margin-bottom: 4px; letter-spacing: -0.5px; }
        .page-subtitle { font-size: 12px; color: #6b7280; font-weight: 400; }
        .controls-section {
            display: flex;
            gap: 12px;
            margin-bottom: 20px;
            flex-wrap: wrap;
            align-items: center;
        }
        .control-group { display: flex; align-items: center; gap: 8px; }
        .control-label { font-size: 12px; color: #374151; font-weight: 600; }
        .strategy-filter-container { position: relative; }
        .strategy-filter-button {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 7px 12px;
            border: 1px solid #d1d5db;
            border-radius: 8px;
            font-size: 12px;
            font-weight: 500;
            background: white;
            color: #374151;
            cursor: pointer;
            transition: all 0.15s ease;
        }
        .strategy-filter-button:hover { border-color: #9ca3af; background: #f9fafb; }
        .strategy-filter-dropdown {
            position: absolute;
            top: 100%;
            left: 0;
            margin-top: 6px;
            background: white;
            border: 1px solid #d1d5db;
            border-radius: 10px;
            box-shadow: 0 10px 15px rgba(0,0,0,0.1), 0 4px 6px rgba(0,0,0,0.05);
            min-width: 280px;
            max-height: 400px;
            overflow-y: auto;
            z-index: 1000;
            display: none;
        }
        .strategy-filter-dropdown.active { display: block; }
        .strategy-filter-header {
            padding: 12px 14px;
            border-bottom: 1px solid #e2e8f0;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        .strategy-filter-title { font-size: 13px; font-weight: 600; color: #1e293b; }
        .strategy-filter-actions { display: flex; gap: 8px; }
        .filter-action-btn {
            font-size: 11px;
            color: #1e40af;
            cursor: pointer;
            padding: 4px 8px;
            border-radius: 4px;
            transition: background 0.2s ease;
        }
        .filter-action-btn:hover { background: #eff6ff; }
        .filter-action-btn[style*="color: #dc2626"]:hover { background: #fee2e2; }
        .strategy-filter-list { padding: 8px 0; }
        .strategy-filter-item {
            display: flex;
            align-items: center;
            padding: 8px 14px;
            cursor: pointer;
            transition: background 0.2s ease;
        }
        .strategy-filter-item:hover { background: #f8fafc; }
        .strategy-filter-checkbox { margin-right: 10px; width: 16px; height: 16px; cursor: pointer; }
        .strategy-filter-label { font-size: 13px; color: #475569; cursor: pointer; user-select: none; }
        .filter-badge {
            display: inline-block;
            background: #1e40af;
            color: white;
            font-size: 9px;
            padding: 2px 5px;
            border-radius: 10px;
            margin-left: 6px;
            font-weight: 600;
        }
        select, button {
            padding: 7px 12px;
            border: 1px solid #d1d5db;
            border-radius: 8px;
            font-size: 12px;
            font-weight: 500;
            background: white;
            color: #374151;
            cursor: pointer;
            transition: all 0.15s ease;
            font-family: inherit;
        }
        select:hover, button:hover { border-color: #9ca3af; background: #f9fafb; }
        select:focus, button:focus {
            outline: none;
            border-color: #3b82f6;
            box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.1);
        }
        button.primary { background: #3b82f6; color: white; border-color: #3b82f6; }
        button.primary:hover { background: #2563eb; border-color: #2563eb; }
        .table-container {
            background: white;
            border-radius: 12px;
            box-shadow: 0 1px 3px rgba(0,0,0,0.08), 0 1px 2px rgba(0,0,0,0.06);
            border: 1px solid #e5e7eb;
            overflow: visible;
        }
        .table-wrapper { overflow-x: auto; overflow-y: visible; background: white; border-radius: 0; }
        .performance-table {
            width: 100%;
            border-collapse: separate;
            border-spacing: 0;
            font-size: 13px;
            min-width: 800px;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Segoe UI Web (West European)', 'Segoe UI', -apple-system, BlinkMacSystemFont, Roboto, 'Helvetica Neue', sans-serif;
        }
        .performance-table thead { position: sticky; top: 0; z-index: 10; background: white; }
        .performance-table thead tr { height: 0; border-spacing: 0; border-collapse: collapse; }
        .performance-table thead tr.header-row-1, .performance-table thead tr.header-row-2 { height: auto; }
        .performance-table thead tr.header-row-1 th {
            padding: 12px 8px 6px 8px;
            position: sticky;
            top: 0;
            background: #f3f4f6;
            z-index: 10;
            font-size: 11px;
            text-align: center;
            font-weight: 700;
            color: #1f2937;
            border-bottom: 1px solid #d1d5db;
            border-right: 1px solid #e5e7eb;
            white-space: nowrap;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            line-height: 1.2;
            vertical-align: middle;
            height: 32px;
        }
        .performance-table thead tr.header-row-1 th[rowspan="2"] {
            border-bottom: 2px solid #d1d5db;
            text-align: center;
            background: #f3f4f6;
            padding: 12px 8px;
            height: auto;
            vertical-align: middle;
        }
        .performance-table thead tr.header-row-2 th {
            padding: 6px 8px 12px 8px;
            font-size: 10px;
            position: sticky;
            top: 32px;
            background: #f3f4f6;
            z-index: 10;
            font-weight: 600;
            color: #6b7280;
            text-align: center;
            border-bottom: 2px solid #d1d5db;
            border-right: 1px solid #e5e7eb;
            white-space: nowrap;
            text-transform: uppercase;
            line-height: 1.2;
            vertical-align: middle;
            height: 32px;
        }
        .performance-table thead tr.header-row-1 th:first-child {
            position: sticky;
            left: 0;
            z-index: 11;
            background: #f9fafb;
            min-width: 100px;
            max-width: 100px;
            border-right: 2px solid #cbd5e1;
            padding: 12px 8px;
            vertical-align: middle;
        }
        .performance-table th {
            background: #f3f4f6;
            padding: 12px 8px;
            text-align: center;
            font-weight: 700;
            color: #6b7280;
            border-bottom: 2px solid #d1d5db;
            border-right: 1px solid #e5e7eb;
            white-space: nowrap;
            text-transform: uppercase;
            font-size: 11px;
            letter-spacing: 0.5px;
            min-width: 75px;
            max-width: 90px;
            vertical-align: middle;
        }
        .performance-table th.strategy-group-end { border-right: 1px solid #cbd5e1; }
        .performance-table td.strategy-group-end { border-right: 1px solid #cbd5e1; }
        .performance-table th.apro-boundary { border-right: 1px solid #cbd5e1 !important; }
        .performance-table td.apro-boundary { border-right: 1px solid #cbd5e1 !important; }
        .performance-table th.broker-boundary { border-right: 1px solid #cbd5e1 !important; }
        .performance-table td.broker-boundary { border-right: 1px solid #cbd5e1 !important; }
        .performance-table th.strategy-bg-0, .performance-table td.strategy-bg-0 { background: #f8fcf9; }
        .performance-table th.strategy-bg-1, .performance-table td.strategy-bg-1 { background: #f8fcf9; }
        .performance-table th.strategy-bg-2, .performance-table td.strategy-bg-2 { background: #f8fcf9; }
        .performance-table th.strategy-bg-3, .performance-table td.strategy-bg-3 { background: #fefafd; }
        .performance-table th.strategy-bg-4, .performance-table td.strategy-bg-4 { background: #fffaf5; }
        .performance-table td.lot-col.strategy-bg-0,
        .performance-table td.lot-col.strategy-bg-1,
        .performance-table td.lot-col.strategy-bg-2,
        .performance-table td.lot-col.strategy-bg-3,
        .performance-table td.lot-col.strategy-bg-4 {
            width: 65px;
            min-width: 65px;
            max-width: 65px;
            background: #eff8fe !important;
        }
        .performance-table tr:hover td.strategy-bg-0,
        .performance-table tr:hover td.strategy-bg-1,
        .performance-table tr:hover td.strategy-bg-2,
        .performance-table tr:hover td.strategy-bg-3,
        .performance-table tr:hover td.strategy-bg-4 { background: #fafbfc; }
        .performance-table tr:hover td.lot-col.strategy-bg-0,
        .performance-table tr:hover td.lot-col.strategy-bg-1,
        .performance-table tr:hover td.lot-col.strategy-bg-2,
        .performance-table tr:hover td.lot-col.strategy-bg-3,
        .performance-table tr:hover td.lot-col.strategy-bg-4 {
            background: #fafbfc;
            width: 65px;
            min-width: 65px;
            max-width: 65px;
        }
        .performance-table tr:hover td.apro-pnl-col {
            background: #fafbfc;
            width: 85px;
            min-width: 75px;
            max-width: 90px;
        }
        .performance-table tr:hover td.apro-pnl-col.strategy-bg-0,
        .performance-table tr:hover td.apro-pnl-col.strategy-bg-1,
        .performance-table tr:hover td.apro-pnl-col.strategy-bg-2,
        .performance-table tr:hover td.apro-pnl-col.strategy-bg-3,
        .performance-table tr:hover td.apro-pnl-col.strategy-bg-4 {
            background: #fafbfc;
            width: 85px;
            min-width: 75px;
            max-width: 90px;
        }
        .performance-table th:first-child {
            position: sticky;
            left: 0;
            z-index: 11;
            background: #f8fafc;
            min-width: 110px;
            max-width: 110px;
            border-right: 2px solid #cbd5e1;
            vertical-align: middle;
        }
        .performance-table th.number-col { text-align: center; max-width: 80px; }
        .performance-table th.apro-pnl-col, .performance-table td.apro-pnl-col {
            min-width: 75px;
            max-width: 90px;
            width: 85px;
        }
        .performance-table td.apro-pnl-col.strategy-bg-0 { background: #f8fcf9; width: 85px; min-width: 75px; max-width: 90px; }
        .performance-table td.apro-pnl-col.strategy-bg-1 { background: #f8fcf9; width: 85px; min-width: 75px; max-width: 90px; }
        .performance-table td.apro-pnl-col.strategy-bg-2 { background: #f8fcf9; width: 85px; min-width: 75px; max-width: 90px; }
        .performance-table td.apro-pnl-col.strategy-bg-3 { background: #f8fcf9; width: 85px; min-width: 75px; max-width: 90px; }
        .performance-table td.apro-pnl-col.strategy-bg-4 { background: #f8fcf9; width: 85px; min-width: 75px; max-width: 90px; }
        
        /* Section-based color overrides */
        .performance-table td.dpnl-section { background: #fefafd !important; }
        .performance-table td.pnl-section { background: #fffaf5 !important; }
        
        .performance-table td {
            padding: 11px 8px;
            border-bottom: 1px solid #f3f4f6;
            border-right: 1px solid #f3f4f6;
            color: #374151;
            text-align: right;
            white-space: nowrap;
            min-width: 75px;
            max-width: 90px;
            overflow: hidden;
            text-overflow: ellipsis;
            font-size: 13px;
            font-weight: 400;
        }
        .performance-table td.lot-col { min-width: 65px; max-width: 65px; width: 65px; }
        .performance-table th.lot-col { min-width: 65px; max-width: 65px; width: 65px; }
        .performance-table td:first-child {
            position: sticky;
            left: 0;
            background: white;
            font-weight: 500;
            z-index: 9;
            border-right: 2px solid #cbd5e1;
            min-width: 100px;
            max-width: 100px;
            padding: 11px 8px;
            text-align: left;
            color: #111827;
        }
        .performance-table td.number-col {
            text-align: right;
            font-weight: 400;
            font-size: 13px;
            min-width: 75px;
            max-width: 90px;
            padding: 11px 8px;
            font-variant-numeric: tabular-nums;
        }
        .performance-table th.number-col { text-align: center; max-width: 90px; }
        .performance-table td.number-col.total-net-col {
            min-width: 80px;
            max-width: none;
            font-weight: 600;
            background: #fefce8 !important;
        }
        .performance-table tbody tr.month-row td.number-col.total-net-col { background: #fef9c3 !important; }
        .performance-table tbody tr.total-row td.number-col.total-net-col { background: #fef9c3 !important; }
        .performance-table th.total-net-col { min-width: 80px; max-width: none; }
        .performance-table th.total-col-border,
        .performance-table td.total-col-border {
            border-right: 1px solid #cbd5e1 !important;
        }
        .performance-table td.number-col.net-pnl-percent-col {
            min-width: 60px;
            max-width: 60px;
            font-weight: 550;
            background: #fefce8 !important;
            font-size: 13px;
        }
        .performance-table tbody tr.month-row td.number-col.net-pnl-percent-col { background: #fef9c3 !important; }
        .performance-table tbody tr.total-row td.number-col.net-pnl-percent-col { background: #fef9c3 !important; }
        .performance-table th.net-pnl-percent-col { min-width: 60px; max-width: 60px; }
        .performance-table td.number-col.drawdown-col {
            min-width: 90px;
            max-width: none;
            background: #fef3f2 !important;
        }
        .performance-table tbody tr.month-row td.number-col.drawdown-col { background: #fee2e2 !important; }
        .performance-table tbody tr.total-row td.number-col.drawdown-col { background: #fee2e2 !important; }
        .performance-table th.drawdown-col { min-width: 90px; max-width: none; }
        .performance-table td.number-col.expenses-col {
            font-weight: 600;
            background: #fef2f2;
            border-left: 1px solid #cbd5e1;
        }
        .performance-table tbody tr.month-row td.number-col.expenses-col { background: #fef2f2 !important; }
        .performance-table tbody tr.total-row td.number-col.expenses-col { background: #fef2f2 !important; }
        .performance-table th.expenses-col { min-width: 80px; max-width: none; }
        .performance-table td.positive { color: #059669; }
        .performance-table td.negative { color: #b96060; }
        .performance-table tr:hover { background: #fafbfc; }
        .performance-table tr:hover td:first-child { background: #fafbfc; min-width: 100px; max-width: 100px; border-right: 2px solid #cbd5e1; }
        .performance-table tbody tr.total-row {
            background: #f9fafb;
            font-weight: 700;
            border-top: 2px solid #d1d5db;
        }
        .performance-table tbody tr.total-row:hover { background: #f3f4f6; }
        .performance-table tbody tr.total-row td {
            border-top: 2px solid #d1d5db;
            padding: 14px 8px;
            font-weight: 600;
            font-size: 13px;
        }
        .performance-table tbody tr.total-row td:first-child { background: #f9fafb; min-width: 100px; max-width: 100px; border-right: 2px solid #cbd5e1; }
        .performance-table tbody tr.total-row:hover td:first-child { background: #f3f4f6; min-width: 100px; max-width: 100px; border-right: 2px solid #cbd5e1; }
        .performance-table tbody tr.total-row:hover td.strategy-bg-0 { background: #ecf7f1; }
        .performance-table tbody tr.total-row:hover td.strategy-bg-1 { background: #ecf7f1; }
        .performance-table tbody tr.total-row:hover td.strategy-bg-2 { background: #ecf7f1; }
        .performance-table tbody tr.total-row:hover td.strategy-bg-3 { background: #fef0f6; }
        .performance-table tbody tr.total-row:hover td.strategy-bg-4 { background: #fff1e1; }
        .performance-table tbody tr.total-row:hover td.lot-col { width: 65px; min-width: 65px; max-width: 65px; background: #dff0fc !important; }
        .performance-table tbody tr.total-row:hover td.dpnl-section { background: #fef0f6 !important; }
        .performance-table tbody tr.total-row:hover td.pnl-section { background: #fff1e1 !important; }
        .performance-table tbody tr.total-row:hover td.apro-pnl-col { width: 85px; min-width: 75px; max-width: 90px; }
        .performance-table tbody tr.total-row:hover td.apro-pnl-col.strategy-bg-0 { background: #ecf7f1; }
        .performance-table tbody tr.total-row:hover td.apro-pnl-col.strategy-bg-1 { background: #ecf7f1; }
        .performance-table tbody tr.total-row:hover td.apro-pnl-col.strategy-bg-2 { background: #ecf7f1; }
        .performance-table tbody tr.total-row:hover td.apro-pnl-col.strategy-bg-3 { background: #ecf7f1; }
        .performance-table tbody tr.total-row:hover td.apro-pnl-col.strategy-bg-4 { background: #ecf7f1; }
        .performance-table tbody tr.total-row td.apro-pnl-col { width: 85px; min-width: 75px; max-width: 90px; }
        .performance-table tbody tr.month-row {
            background: #f9fafb;
            font-weight: 600 !important;
            cursor: pointer;
            user-select: none;
            border-left: 3px solid transparent;
            transition: all 0.15s ease;
        }
        .performance-table tbody tr.month-row:hover { background: #f3f4f6; border-left-color: #3b82f6; }
        .performance-table tbody tr.month-row td {
            font-weight: 600 !important;
            font-size: 12px !important;
        }
        .performance-table tbody tr.month-row td:first-child {
            background: #f9fafb;
            color: #111827;
            min-width: 100px;
            max-width: 100px;
            font-weight: 600 !important;
            font-size: 12px !important;
            border-right: 2px solid #cbd5e1;
        }
        .performance-table tbody tr.month-row:hover td:first-child { background: #f3f4f6; min-width: 100px; max-width: 100px; border-right: 2px solid #cbd5e1; }
        .performance-table tbody tr.month-row:hover td.strategy-bg-0 { background: #e3f3ea; }
        .performance-table tbody tr.month-row:hover td.strategy-bg-1 { background: #e3f3ea; }
        .performance-table tbody tr.month-row:hover td.strategy-bg-2 { background: #e3f3ea; }
        .performance-table tbody tr.month-row:hover td.strategy-bg-3 { background: #fde9f3; }
        .performance-table tbody tr.month-row:hover td.strategy-bg-4 { background: #ffecd6; }
        .performance-table tbody tr.month-row:hover td.lot-col { width: 65px; min-width: 65px; max-width: 65px; background: #d5ebfa !important; }
        .performance-table tbody tr.month-row:hover td.dpnl-section { background: #fde9f3 !important; }
        .performance-table tbody tr.month-row:hover td.pnl-section { background: #ffecd6 !important; }
        .performance-table tbody tr.month-row:hover td.apro-pnl-col { width: 85px; min-width: 75px; max-width: 90px; }
        .performance-table tbody tr.month-row:hover td.apro-pnl-col.strategy-bg-0 { background: #e3f3ea; }
        .performance-table tbody tr.month-row:hover td.apro-pnl-col.strategy-bg-1 { background: #e3f3ea; }
        .performance-table tbody tr.month-row:hover td.apro-pnl-col.strategy-bg-2 { background: #e3f3ea; }
        .performance-table tbody tr.month-row:hover td.apro-pnl-col.strategy-bg-3 { background: #e3f3ea; }
        .performance-table tbody tr.month-row:hover td.apro-pnl-col.strategy-bg-4 { background: #e3f3ea; }
        .performance-table tbody tr.month-row td.strategy-bg-0 { background: #f0f9f3; }
        .performance-table tbody tr.month-row td.strategy-bg-1 { background: #f0f9f3; }
        .performance-table tbody tr.month-row td.strategy-bg-2 { background: #f0f9f3; }
        .performance-table tbody tr.month-row td.strategy-bg-3 { background: #fef2f8; }
        .performance-table tbody tr.month-row td.strategy-bg-4 { background: #fff3e8; }
        .performance-table tbody tr.month-row td.lot-col { background: #e8f4fc !important; }
        .performance-table tbody tr.month-row td.dpnl-section { background: #fef2f8 !important; }
        .performance-table tbody tr.month-row td.pnl-section { background: #fff3e8 !important; }
        .performance-table tbody tr.month-row td.apro-pnl-col.strategy-bg-0 { background: #f0f9f3; width: 85px; min-width: 75px; max-width: 90px; }
        .performance-table tbody tr.month-row td.apro-pnl-col.strategy-bg-1 { background: #f0f9f3; width: 85px; min-width: 75px; max-width: 90px; }
        .performance-table tbody tr.month-row td.apro-pnl-col.strategy-bg-2 { background: #f0f9f3; width: 85px; min-width: 75px; max-width: 90px; }
        .performance-table tbody tr.month-row td.apro-pnl-col.strategy-bg-3 { background: #f0f9f3; width: 85px; min-width: 75px; max-width: 90px; }
        .performance-table tbody tr.month-row td.apro-pnl-col.strategy-bg-4 { background: #f0f9f3; width: 85px; min-width: 75px; max-width: 90px; }
        .performance-table tbody tr.day-row { display: none; }
        .performance-table tbody tr.day-row.expanded { display: table-row; }
        .performance-table tbody tr.day-row td { padding: 7px 8px; font-size: 12px; }
        .performance-table tbody tr.day-row td:first-child {
            padding-left: 40px;
            padding-top: 7px;
            padding-bottom: 7px;
            font-weight: 500;
            color: #6b7280;
            min-width: 100px;
            max-width: 100px;
            font-size: 12px;
            border-right: 2px solid #cbd5e1;
        }
        .performance-table tbody tr.day-row td.apro-pnl-col { width: 85px; min-width: 75px; max-width: 90px; }
        .expand-icon {
            display: inline-block;
            width: 18px;
            height: 18px;
            margin-right: 10px;
            text-align: center;
            font-weight: 600;
            color: #6b7280;
            transition: transform 0.2s ease;
            font-size: 12px;
            line-height: 18px;
        }
        .expand-icon.expanded { transform: rotate(90deg); }
        .no-data { text-align: center; color: #cbd5e1; padding: 40px; font-size: 14px; }
        .summary-cards {
            display: flex;
            gap: 12px;
            margin-bottom: 16px;
            flex-wrap: nowrap;
            overflow-x: auto;
            align-items: stretch;
        }
        .summary-card {
            background: white;
            border-radius: 8px;
            padding: 10px 12px;
            box-shadow: 0 1px 3px rgba(0,0,0,0.08), 0 1px 2px rgba(0,0,0,0.06);
            border: 1px solid #e5e7eb;
            flex: 1 1 0;
            min-width: 140px;
        }
        .summary-card-title {
            font-size: 10px;
            color: #6b7280;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            margin-bottom: 5px;
            font-weight: 700;
        }
        .summary-card-value {
            font-size: 18px;
            font-weight: 700;
            line-height: 1.2;
            font-variant-numeric: tabular-nums;
        }
        .summary-card-value.positive { color: #059669; }
        .summary-card-value.negative { color: #b96060; }
        .summary-card.net-profit-box {
            background: #f0fdf4;
        }
        .summary-card.total-expense-box {
            background: #fdf2f8;
        }
        .summary-card.running-margin-box {
            background: #fffbeb;
        }
        
        /* Tablet Layout - Dynamic columns based on card count */
        @media screen and (min-width: 769px) and (max-width: 1024px) {
            /* Default: 4 columns (changed to fix 4-box layout) */
            .summary-cards {
                display: grid;
                grid-template-columns: repeat(4, 1fr);
                gap: 12px;
                flex-wrap: wrap;
                overflow-x: visible;
            }
            
            /* 3 columns when 5+ boxes */
            .summary-cards.grid-3-cols {
                grid-template-columns: repeat(3, 1fr);
            }
            
            .summary-card {
                min-width: auto;
                flex: none;
            }
        }
        
        /* Comprehensive Mobile Responsive Styles */
        @media screen and (max-width: 768px) {
            .main-content {
                padding: 12px 16px 24px 16px;
            }
            
            .page-title {
                font-size: 18px;
            }
            
            .page-subtitle {
                font-size: 11px;
            }
            
            .controls-section {
                display: flex;
                flex-wrap: wrap;
                gap: 10px;
                margin-bottom: 16px;
            }
            
            /* Row 1: Month filter + Hide Strategy button */
            .controls-section .control-group:first-child {
                flex: 1 1 48%;
                display: flex;
                flex-direction: row;
                align-items: center;
                gap: 6px;
            }
            
            .controls-section .control-group:first-child select {
                flex: 1;
            }
            
            .controls-section .strategy-filter-container {
                flex: 1 1 48%;
            }
            
            /* Row 2: Checkboxes in same row */
            .controls-section .control-group:has(input[type="checkbox"]) {
                flex: 0 1 auto;
                display: flex;
                flex-direction: row;
                align-items: center;
                gap: 4px;
                white-space: nowrap;
            }
            
            .controls-section .control-group:has(input[type="checkbox"]) label {
                font-size: 11px;
                white-space: nowrap;
            }
            
            /* Row 3: Buttons in same row */
            .controls-section button {
                flex: 1 1 auto;
                min-width: 0;
            }
            
            .control-label {
                font-size: 11px;
                white-space: nowrap;
            }
            
            select, button, .strategy-filter-button {
                padding: 10px 12px;
                font-size: 12px;
            }
            
            .strategy-filter-button {
                width: 100%;
            }
            
            .strategy-filter-dropdown {
                left: 0;
                right: 0;
                min-width: auto;
                width: calc(100vw - 32px);
                max-height: 60vh;
            }
            
            .summary-cards {
                display: grid;
                grid-template-columns: repeat(2, 1fr);
                gap: 10px;
                flex-wrap: wrap;
                overflow-x: visible;
            }
            
            .summary-card {
                min-width: auto;
                flex: none;
            }
            
            .summary-card {
                padding: 14px 16px;
            }
            
            .summary-card-title {
                font-size: 11px;
            }
            
            .summary-card-value {
                font-size: 20px;
            }
            
            .summary-card-subtitle {
                font-size: 11px;
            }
            
            .table-container {
                margin: 0 -16px;
                border-radius: 0;
                border-left: none;
                border-right: none;
            }
            
            .table-wrapper {
                overflow-x: auto;
                -webkit-overflow-scrolling: touch;
            }
            
            .performance-table {
                font-size: 11px;
            }
            
            .performance-table thead tr.header-row-1 th {
                font-size: 9px;
                padding: 10px 6px 5px 6px;
            }
            
            .performance-table thead tr.header-row-2 th {
                font-size: 9px;
                padding: 8px 6px;
            }
            
            .performance-table tbody td {
                padding: 10px 6px;
                font-size: 11px;
            }
            
            .performance-table tbody tr.month-row td,
            .performance-table tbody tr.total-row td {
                font-size: 11px !important;
            }
            
            .performance-table tbody tr.day-row td {
                font-size: 10px;
                padding: 6px 4px;
            }
            
            .performance-table tbody tr.day-row td:first-child {
                padding-left: 30px;
                font-size: 10px;
            }
            
            .expand-icon {
                width: 16px;
                height: 16px;
            }
        }
        
        @media screen and (max-width: 480px) {
            .main-content {
                padding: 10px 12px 20px 12px;
            }
            
            .page-title {
                font-size: 16px;
            }
            
            .page-subtitle {
                font-size: 10px;
            }
            
            .controls-section {
                gap: 8px;
                margin-bottom: 14px;
            }
            
            .controls-section .control-group:has(input[type="checkbox"]) label {
                font-size: 10px;
            }
            
            .control-label {
                font-size: 10px;
            }
            
            select, button, .strategy-filter-button {
                padding: 9px 10px;
                font-size: 11px;
            }
            
            .summary-card {
                padding: 12px 14px;
                min-width: auto;
            }
            
            .summary-cards {
                gap: 8px;
                display: grid;
                grid-template-columns: repeat(2, 1fr);
            }
            
            .summary-card-title {
                font-size: 10px;
            }
            
            .summary-card-value {
                font-size: 18px;
            }
            
            .summary-card-subtitle {
                font-size: 10px;
            }
            
            .table-container {
                margin: 0 -12px;
            }
            
            .performance-table {
                font-size: 10px;
            }
            
            .performance-table thead tr.header-row-1 th,
            .performance-table thead tr.header-row-2 th {
                font-size: 8px;
                padding: 8px 4px;
            }
            
            .performance-table tbody td {
                padding: 8px 4px;
                font-size: 10px;
            }
            
            .performance-table tbody tr.month-row td,
            .performance-table tbody tr.total-row td {
                font-size: 10px !important;
            }
            
            .performance-table tbody tr.day-row td {
                font-size: 9px;
                padding: 5px 3px;
            }
            
            .performance-table tbody tr.day-row td:first-child {
                padding-left: 25px;
                font-size: 9px;
            }
            
            .strategy-filter-dropdown {
                width: calc(100vw - 24px);
                max-height: 50vh;
            }
            
            .expand-icon {
                width: 14px;
                height: 14px;
            }
            
            .filter-badge {
                font-size: 8px;
                padding: 1px 4px;
            }
        }
        
        @media screen and (max-width: 360px) {
            .main-content {
                padding: 8px 10px 16px 10px;
            }
            
            .page-title {
                font-size: 15px;
            }
            
            .controls-section {
                gap: 6px;
            }
            
            .controls-section .control-group:has(input[type="checkbox"]) label {
                font-size: 9px;
            }
            
            .control-label {
                font-size: 9px;
            }
            
            select, button, .strategy-filter-button {
                padding: 8px 8px;
                font-size: 10px;
            }
            
            .summary-cards {
                gap: 6px;
                display: grid;
                grid-template-columns: repeat(2, 1fr);
            }
            
            .summary-card {
                padding: 10px 12px;
                min-width: auto;
            }
            
            .summary-card-title {
                font-size: 9px;
            }
            
            .summary-card-value {
                font-size: 15px;
            }
            
            .summary-card-subtitle {
                font-size: 9px;
            }
            
            .performance-table {
                font-size: 9px;
            }
            
            .performance-table thead tr.header-row-1 th,
            .performance-table thead tr.header-row-2 th {
                font-size: 7px;
                padding: 6px 3px;
            }
            
            .performance-table tbody td {
                padding: 6px 3px;
                font-size: 9px;
            }
            
            .performance-table tbody tr.month-row td,
            .performance-table tbody tr.total-row td {
                font-size: 9px !important;
            }
            
            .performance-table tbody tr.day-row td {
                font-size: 8px;
            }
        }
    </style>
</head>
<body>
    <div class="main-content">
        <div class="page-header">
            <h1 class="page-title">Strategy Performance</h1>
            <p class="page-subtitle">Detailed profit and loss analysis by strategy and time period</p>
        </div>

        <div class="summary-cards" id="summaryCards">
            <div class="summary-card">
                <div class="summary-card-title">Starting Capital</div>
                <div class="summary-card-value" id="startingCapital">₹0</div>
            </div>
            <div class="summary-card">
                <div class="summary-card-title">Running Profit</div>
                <div class="summary-card-value" id="runningProfit">₹0</div>
            </div>
            <div class="summary-card">
                <div class="summary-card-title">Net Broker Profit</div>
                <div class="summary-card-value" id="netBrProfit">₹0</div>
            </div>
            <div class="summary-card">
                <div class="summary-card-title">Charges</div>
                <div class="summary-card-value negative" id="charges">₹0</div>
            </div>
            <div class="summary-card running-margin-box">
                <div class="summary-card-title">Running Margin</div>
                <div class="summary-card-value" id="runningMargin">-</div>
            </div>
            <div class="summary-card total-expense-box">
                <div class="summary-card-title">Total Expense</div>
                <div class="summary-card-value" id="totalExpense">-</div>
            </div>
            <div class="summary-card net-profit-box">
                <div class="summary-card-title">Total Net Profit</div>
                <div class="summary-card-value" id="netProfit">-</div>
            </div>
        </div>

        <div class="controls-section">
            <div class="control-group">
                <label class="control-label">Month:</label>
                <select id="monthFilter">
                    <option value="all">All Months</option>
                </select>
            </div>
            <div class="strategy-filter-container">
                <button class="strategy-filter-button" onclick="toggleStrategyFilter()">
                    <span>Hide Strategies</span>
                    <span class="filter-badge" id="filterBadge" style="display: none;">0</span>
                    <span>▼</span>
                </button>
                <div class="strategy-filter-dropdown" id="strategyFilterDropdown">
                    <div class="strategy-filter-header">
                        <span class="strategy-filter-title">Select Strategies</span>
                        <div class="strategy-filter-actions">
                            <span class="filter-action-btn" onclick="selectAllStrategies()">All</span>
                            <span class="filter-action-btn" onclick="deselectAllStrategies()">None</span>
                            <span class="filter-action-btn" onclick="clearSavedFilters()" style="color: #dc2626;">Reset</span>
                        </div>
                    </div>
                    <div class="strategy-filter-list" id="strategyFilterList"></div>
                </div>
            </div>
            <div class="control-group">
                <input type="checkbox" id="showFilteredTotals" onchange="toggleTotalsMode()" style="margin-right: 6px; cursor: pointer;">
                <label for="showFilteredTotals" style="cursor: pointer; font-size: 12px; color: #374151; font-weight: 500;">Show Filtered Totals</label>
            </div>
            <div class="control-group">
                <input type="checkbox" id="showTradeCount" onchange="toggleLotTradeMode()" style="margin-right: 6px; cursor: pointer;">
                <label for="showTradeCount" style="cursor: pointer; font-size: 12px; color: #374151; font-weight: 500;">Show Trade Count</label>
            </div>
            <div class="control-group">
                <input type="checkbox" id="showDrawdown" onchange="toggleDrawdownMode()" style="margin-right: 6px; cursor: pointer;">
                <label for="showDrawdown" style="cursor: pointer; font-size: 12px; color: #374151; font-weight: 500;">Show Drawdown</label>
            </div>
            <div class="control-group">
                <input type="checkbox" id="showLot" onchange="toggleLotMode()" style="margin-right: 6px; cursor: pointer;">
                <label for="showLot" style="cursor: pointer; font-size: 12px; color: #374151; font-weight: 500;">Show LOT</label>
            </div>
            <div class="control-group">
                <input type="checkbox" id="showPnlTax" onchange="togglePnlTaxMode()" style="margin-right: 6px; cursor: pointer;">
                <label for="showPnlTax" style="cursor: pointer; font-size: 12px; color: #374151; font-weight: 500;">Show PNL TAX</label>
            </div>
            <button class="primary" onclick="refreshData()">Refresh</button>
            <button onclick="expandAll()">Expand All</button>
            <button onclick="collapseAll()">Collapse All</button>
        </div>

        <div class="table-container">
            <div class="table-wrapper">
                <table class="performance-table" id="performanceTable">
                    <thead id="tableHeaders"></thead>
                    <tbody id="tableBody">
                        <tr>
                            <td colspan="100" class="no-data">Upload Excel file to view performance data</td>
                        </tr>
                    </tbody>
                </table>
            </div>
        </div>
    </div>

    <script>
        const elements = {
            startingCapital: document.getElementById('startingCapital'),
            runningProfit: document.getElementById('runningProfit'),
            netBrProfit: document.getElementById('netBrProfit'),
            charges: document.getElementById('charges'),
            runningMargin: document.getElementById('runningMargin'),
            totalExpense: document.getElementById('totalExpense'),
            netProfit: document.getElementById('netProfit'),
            monthFilter: document.getElementById('monthFilter'),
            strategyFilterDropdown: document.getElementById('strategyFilterDropdown'),
            strategyFilterList: document.getElementById('strategyFilterList'),
            filterBadge: document.getElementById('filterBadge'),
            tableHeaders: document.getElementById('tableHeaders'),
            tableBody: document.getElementById('tableBody')
        };

        let allTrades = [];
        let hiddenStrategies = new Set();
        let allStrategies = [];
        let globalTotalExpenses = 0;
        let globalLastTotalMargin = 0;
        let globalStartingCapital = 0;
        let updateTimeout;
        let showFilteredTotals = false;
        let showTradeCount = false;
        let showDrawdown = false;
        let showLot = false;
        let showPnlTax = false;
        const monthNames = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];

        window.addEventListener('DOMContentLoaded', () => {
            loadSavedFilters();
            initializeHeadersOnly(); // Initialize headers only on page load
            
            elements.monthFilter.addEventListener('change', function() {
                try {
                    localStorage.setItem('selectedMonth', this.value);
                } catch (e) {}
                processAndDisplayData();
            });
            
            document.addEventListener('click', (event) => {
                if (!elements.strategyFilterDropdown.contains(event.target) && 
                    !event.target.closest('.strategy-filter-button')) {
                    elements.strategyFilterDropdown.classList.remove('active');
                }
            });
        });

        window.addEventListener('message', (event) => {
            const { type, data } = event.data;
            if (type === 'TRADES_DATA') {
                allTrades = data;
                processAndDisplayData();
            } else if (type === 'LOAD_SAMPLE_DATA') {
                loadSampleData();
            }
        });

        function loadSavedFilters() {
            try {
                const savedFilters = localStorage.getItem('strategyFilters');
                if (savedFilters) {
                    hiddenStrategies = new Set(JSON.parse(savedFilters));
                }
                const savedTotalsMode = localStorage.getItem('showFilteredTotals');
                if (savedTotalsMode !== null) {
                    showFilteredTotals = savedTotalsMode === 'true';
                    const checkbox = document.getElementById('showFilteredTotals');
                    if (checkbox) checkbox.checked = showFilteredTotals;
                }
                const savedTradeMode = localStorage.getItem('showTradeCount');
                if (savedTradeMode !== null) {
                    showTradeCount = savedTradeMode === 'true';
                    const checkbox = document.getElementById('showTradeCount');
                    if (checkbox) checkbox.checked = showTradeCount;
                }
                const savedDrawdownMode = localStorage.getItem('showDrawdown');
                if (savedDrawdownMode !== null) {
                    showDrawdown = savedDrawdownMode === 'true';
                    const checkbox = document.getElementById('showDrawdown');
                    if (checkbox) checkbox.checked = showDrawdown;
                }
                const savedLotMode = localStorage.getItem('showLot');
                if (savedLotMode !== null) {
                    showLot = savedLotMode === 'true';
                    const checkbox = document.getElementById('showLot');
                    if (checkbox) checkbox.checked = showLot;
                }
                const savedPnlTaxMode = localStorage.getItem('showPnlTax');
                if (savedPnlTaxMode !== null) {
                    showPnlTax = savedPnlTaxMode === 'true';
                    const checkbox = document.getElementById('showPnlTax');
                    if (checkbox) checkbox.checked = showPnlTax;
                }
            } catch (e) {
                hiddenStrategies = new Set();
            }
        }

        function toggleTotalsMode() {
            const checkbox = document.getElementById('showFilteredTotals');
            showFilteredTotals = checkbox.checked;
            try {
                localStorage.setItem('showFilteredTotals', showFilteredTotals);
            } catch (e) {}
            processAndDisplayData();
        }

        function toggleLotTradeMode() {
            const checkbox = document.getElementById('showTradeCount');
            showTradeCount = checkbox.checked;
            
            // Automatically enable LOT column when showing Trade Count
            if (showTradeCount && !showLot) {
                showLot = true;
                const lotCheckbox = document.getElementById('showLot');
                if (lotCheckbox) lotCheckbox.checked = true;
                try {
                    localStorage.setItem('showLot', showLot);
                } catch (e) {}
            }
            
            // Automatically disable LOT column when hiding Trade Count
            if (!showTradeCount && showLot) {
                showLot = false;
                const lotCheckbox = document.getElementById('showLot');
                if (lotCheckbox) lotCheckbox.checked = false;
                try {
                    localStorage.setItem('showLot', showLot);
                } catch (e) {}
            }
            
            try {
                localStorage.setItem('showTradeCount', showTradeCount);
            } catch (e) {}
            processAndDisplayData();
        }

        function toggleDrawdownMode() {
            const checkbox = document.getElementById('showDrawdown');
            showDrawdown = checkbox.checked;
            try {
                localStorage.setItem('showDrawdown', showDrawdown);
            } catch (e) {}
            processAndDisplayData();
        }

        function toggleLotMode() {
            const checkbox = document.getElementById('showLot');
            showLot = checkbox.checked;
            try {
                localStorage.setItem('showLot', showLot);
            } catch (e) {}
            processAndDisplayData();
        }

        function togglePnlTaxMode() {
            const checkbox = document.getElementById('showPnlTax');
            showPnlTax = checkbox.checked;
            try {
                localStorage.setItem('showPnlTax', showPnlTax);
            } catch (e) {}
            processAndDisplayData();
        }

        function saveFilters() {
            try {
                localStorage.setItem('strategyFilters', JSON.stringify(Array.from(hiddenStrategies)));
            } catch (e) {}
        }

        function cleanupSavedFilters() {
            if (hiddenStrategies.size > 0 && allStrategies.length > 0) {
                const validHiddenStrategies = new Set();
                hiddenStrategies.forEach(strategy => {
                    if (allStrategies.includes(strategy)) {
                        validHiddenStrategies.add(strategy);
                    }
                });
                hiddenStrategies = validHiddenStrategies;
                saveFilters();
            }
        }

        function toggleStrategyFilter() {
            elements.strategyFilterDropdown.classList.toggle('active');
        }

        function updateStrategyFilterList() {
            if (allStrategies.length > 0) {
                const validHiddenStrategies = new Set();
                hiddenStrategies.forEach(strategy => {
                    if (allStrategies.includes(strategy)) {
                        validHiddenStrategies.add(strategy);
                    }
                });
                hiddenStrategies = validHiddenStrategies;
            }
            
            const html = allStrategies.map(strategy => {
                const isChecked = !hiddenStrategies.has(strategy);
                const displayName = formatStrategyName(strategy);
                return `<div class="strategy-filter-item" onclick="toggleStrategyRow('${strategy}')">
                    <input type="checkbox" class="strategy-filter-checkbox" id="check_${strategy}" 
                           ${isChecked ? 'checked' : ''}>
                    <label class="strategy-filter-label" for="check_${strategy}">${displayName}</label>
                </div>`;
            }).join('');
            
            elements.strategyFilterList.innerHTML = html;
            updateFilterBadge();
        }

        function toggleStrategyRow(strategyName) {
            const checkbox = document.getElementById(`check_${strategyName}`);
            if (!checkbox) return;
            
            checkbox.checked = !checkbox.checked;
            
            if (checkbox.checked) {
                hiddenStrategies.delete(strategyName);
            } else {
                hiddenStrategies.add(strategyName);
            }
            
            saveFilters();
            updateFilterBadge();
            clearTimeout(updateTimeout);
            updateTimeout = setTimeout(() => processAndDisplayData(), 250);
        }

        function selectAllStrategies() {
            hiddenStrategies.clear();
            saveFilters();
            allStrategies.forEach(strategy => {
                const checkbox = document.getElementById(`check_${strategy}`);
                if (checkbox) checkbox.checked = true;
            });
            updateFilterBadge();
            processAndDisplayData();
        }

        function deselectAllStrategies() {
            allStrategies.forEach(strategy => hiddenStrategies.add(strategy));
            saveFilters();
            allStrategies.forEach(strategy => {
                const checkbox = document.getElementById(`check_${strategy}`);
                if (checkbox) checkbox.checked = false;
            });
            updateFilterBadge();
            processAndDisplayData();
        }

        function clearSavedFilters() {
            try {
                localStorage.removeItem('strategyFilters');
                localStorage.removeItem('selectedMonth');
                localStorage.removeItem('showFilteredTotals');
                localStorage.removeItem('showTradeCount');
                localStorage.removeItem('showDrawdown');
            } catch (e) {}
            hiddenStrategies.clear();
            showFilteredTotals = false;
            showTradeCount = false;
            showDrawdown = false;
            elements.monthFilter.value = 'all';
            const filteredCheckbox = document.getElementById('showFilteredTotals');
            if (filteredCheckbox) filteredCheckbox.checked = false;
            const tradeCheckbox = document.getElementById('showTradeCount');
            if (tradeCheckbox) tradeCheckbox.checked = false;
            const drawdownCheckbox = document.getElementById('showDrawdown');
            if (drawdownCheckbox) drawdownCheckbox.checked = false;
            updateStrategyFilterList();
            processAndDisplayData();
        }

        function updateFilterBadge() {
            const hiddenCount = hiddenStrategies.size;
            if (hiddenCount > 0 && allStrategies.length > 0) {
                elements.filterBadge.textContent = hiddenCount;
                elements.filterBadge.style.display = 'inline-block';
            } else {
                elements.filterBadge.style.display = 'none';
            }
        }

        function formatStrategyName(strategyName) {
            if (!strategyName) return strategyName;
            if (strategyName.startsWith('A.PRO')) return strategyName;
            
            return strategyName.replace(/_/g, ' ').replace(/(\d)(PRO)/g, '$1 $2');
        }

        function formatNumber(num) {
            if (num === 0) return '';
            const formatted = Math.abs(num).toLocaleString('en-IN', { maximumFractionDigits: 0 });
            return num >= 0 ? formatted : `-${formatted}`;
        }

        function initializeHeadersOnly() {
            // Initialize with empty trades
            allTrades = [];
            
            // Define the strategies to display in headers
            const aProStrategies = ['A.PRO 2', 'A.PRO 3'];
            const brokerStrategies = ['B1PRO2', 'B1PRO3', 
                                     'B2PRO2', 'B2PRO3'];
            
            // Combine all strategies
            const strategies = [...aProStrategies, ...brokerStrategies];
            allStrategies = strategies;
            
            // Call renderPivotTable with empty data but with strategies
            renderPivotTable({}, {}, strategies, {}, {}, {}, {}, {}, {}, {}, {});
            
            // Clear the table body to show no data
            elements.tableBody.innerHTML = '<tr><td colspan="100%" class="no-data">No data loaded yet.</td></tr>';
            
            // Update strategy filter list
            updateStrategyFilterList();
        }

        function loadSampleData() {
            allTrades = [];
            const strategies = ['PRO 2', 'PRO 3', 'PRO 4', 'PRO 5', 'PRO 7'];
            const aProStrategies = ['A.PRO 1', 'A.PRO 2', 'A.PRO 3', 'A.PRO 4', 'A.PRO 5', 'A.PRO 7'];
            const brokerCodes = ['B1', 'B2'];
            const months = ['01', '02', '03', '04', '05', '06', '07', '08', '09', '10'];
            let cumPnl = 0;
            
            for (let monthIdx = 0; monthIdx < months.length; monthIdx++) {
                const daysInMonth = 20 + Math.floor(Math.random() * 10);
                
                for (let day = 1; day <= daysInMonth; day++) {
                    const strategy = strategies[Math.floor(Math.random() * strategies.length)];
                    const profit = (Math.random() - 0.45) * 5000;
                    cumPnl += profit;
                    
                    const strategyDetails = {};
                    const pnlStrategies = {};
                    const pnlTaxStrategies = {};
                    const brokerCodesMap = {};
                    
                    aProStrategies.forEach((aProStrat) => {
                        const aProProfit = (Math.random() - 0.5) * 2000;
                        pnlStrategies[aProStrat] = aProProfit;
                        pnlTaxStrategies[aProStrat] = aProProfit;
                        brokerCodesMap[aProStrat] = 'A';
                        strategyDetails[aProStrat] = {
                            lot: aProProfit !== 0 ? 1 : 0,
                            pnl: aProProfit,
                            dpnl: aProProfit,
                            buy: 0, qty: 0, sell: 0, unpnl: 0, margin: 0
                        };
                    });
                    
                    strategies.forEach((strat, idx) => {
                        const brokerCode = idx < 2 ? 'B1' : 'B2';
                        const stratName = `${brokerCode}${strat.replace(' ', '')}`;
                        const isActive = strat === strategy;
                        
                        pnlStrategies[stratName] = isActive ? profit : 0;
                        pnlTaxStrategies[stratName] = isActive ? profit * 0.95 : 0;
                        brokerCodesMap[stratName] = brokerCode;
                        strategyDetails[stratName] = {
                            lot: isActive ? (Math.random() > 0.5 ? 2 : 4) : 0,
                            pnl: isActive ? profit : 0,
                            dpnl: isActive ? profit * 0.95 : 0,
                            buy: 0, qty: 0, sell: 0, unpnl: 0, margin: 0
                        };
                    });
                    
                    allTrades.push({
                        date: `${String(day).padStart(2, '0')}/${months[monthIdx]}/2025`,
                        strategy: strategy,
                        profit: profit,
                        cumPnl: cumPnl,
                        strategyPnls: pnlStrategies,
                        strategyPnlTax: pnlTaxStrategies,
                        strategyDetails: strategyDetails,
                        brokerCodes: brokerCodesMap
                    });
                }
            }
            
            processAndDisplayData();
            window.parent.postMessage({ type: 'TRADES_DATA', data: allTrades }, '*');
        }

        function processAndDisplayData() {
            if (allTrades.length === 0) return;

            let monthFilter = elements.monthFilter.value;
            if (!monthFilter || monthFilter === 'all') {
                try {
                    const savedMonth = localStorage.getItem('selectedMonth');
                    if (savedMonth) monthFilter = savedMonth;
                } catch (e) {}
            }
            
            const filteredTrades = monthFilter && monthFilter !== 'all' 
                ? allTrades.filter(trade => trade.date?.split('/')[1] === monthFilter)
                : allTrades;

            displayPivotData(filteredTrades);
            updateMonthFilter();
            updateSummaryCards(filteredTrades);
            updateStrategyFilterList();
            cleanupSavedFilters();
        }

        function updateMonthFilter() {
            const monthsSet = new Set();
            allTrades.forEach(trade => {
                const parts = trade.date.split('/');
                if (parts.length >= 2) monthsSet.add(parts[1]);
            });

            let savedMonth = null;
            try {
                savedMonth = localStorage.getItem('selectedMonth');
            } catch (e) {}
            
            const currentValue = savedMonth || elements.monthFilter.value;
            elements.monthFilter.innerHTML = '<option value="all">All Months</option>';
            
            Array.from(monthsSet).sort().forEach(month => {
                const option = document.createElement('option');
                option.value = month;
                option.textContent = monthNames[parseInt(month) - 1];
                elements.monthFilter.appendChild(option);
            });

            if (currentValue && (currentValue === 'all' || monthsSet.has(currentValue))) {
                elements.monthFilter.value = currentValue;
            }
        }

        function displayPivotData(trades) {
            const monthlyData = {};
            const dailyData = {};
            const strategies = new Set();
            
            const monthlyTotals = {};
            const dailyTotals = {};
            const monthlyFilteredTotals = {};
            const dailyFilteredTotals = {};
            const cumulativeData = {};
            let runningTotal = 0;
            let peakTotal = 0;

            const sortedTrades = [...trades].sort((a, b) => {
                const dateA = a.date.split('/').reverse().join('');
                const dateB = b.date.split('/').reverse().join('');
                return dateA.localeCompare(dateB);
            });

            sortedTrades.forEach(trade => {
                const dateParts = trade.date.split('/');
                const monthKey = dateParts[1];
                const dateKey = trade.date;
                
                if (!monthlyData[monthKey]) monthlyData[monthKey] = {};
                if (!dailyData[monthKey]) dailyData[monthKey] = {};
                if (!dailyData[monthKey][dateKey]) dailyData[monthKey][dateKey] = {};
                if (!monthlyTotals[monthKey]) monthlyTotals[monthKey] = { total: 0, net: 0, amiPnl: 0, margin: 0, pnlTax: 0 };
                if (!dailyTotals[monthKey]) dailyTotals[monthKey] = {};
                if (!dailyTotals[monthKey][dateKey]) dailyTotals[monthKey][dateKey] = { total: 0, net: 0, amiPnl: 0, margin: 0, pnlTax: 0 };
                if (!monthlyFilteredTotals[monthKey]) monthlyFilteredTotals[monthKey] = { total: 0, net: 0, amiPnl: 0, margin: 0, pnlTax: 0 };
                if (!dailyFilteredTotals[monthKey]) dailyFilteredTotals[monthKey] = {};
                if (!dailyFilteredTotals[monthKey][dateKey]) dailyFilteredTotals[monthKey][dateKey] = { total: 0, net: 0, amiPnl: 0, margin: 0, pnlTax: 0 };

                Object.entries(trade.strategyDetails).forEach(([stratName, details]) => {
                    strategies.add(stratName);
                    
                    if (!monthlyData[monthKey][stratName]) {
                        monthlyData[monthKey][stratName] = { lot: 0, pnl: 0, dpnl: 0, net: 0, tradeCount: 0, lotSum: 0, lotCount: 0 };
                    }
                    if (!dailyData[monthKey][dateKey][stratName]) {
                        dailyData[monthKey][dateKey][stratName] = { lot: 0, pnl: 0, dpnl: 0, net: 0, tradeCount: 0, lotSum: 0, lotCount: 0 };
                    }
                    
                    if (details.lot > 0) {
                        monthlyData[monthKey][stratName].lotSum += details.lot;
                        monthlyData[monthKey][stratName].lotCount += 1;
                        monthlyData[monthKey][stratName].tradeCount += 1;
                    }
                    monthlyData[monthKey][stratName].pnl += details.pnl;
                    monthlyData[monthKey][stratName].dpnl += details.dpnl;
                    monthlyData[monthKey][stratName].net += (trade.strategyPnlTax[stratName] || 0);
                    
                    if (details.lot > 0) {
                        dailyData[monthKey][dateKey][stratName].lotSum += details.lot;
                        dailyData[monthKey][dateKey][stratName].lotCount += 1;
                        dailyData[monthKey][dateKey][stratName].tradeCount += 1;
                    }
                    dailyData[monthKey][dateKey][stratName].pnl += details.pnl;
                    dailyData[monthKey][dateKey][stratName].dpnl += details.dpnl;
                    dailyData[monthKey][dateKey][stratName].net += (trade.strategyPnlTax[stratName] || 0);
                    
                    const isAPro = stratName.startsWith('A.PRO');
                    if (!isAPro) {
                        const netPnl = trade.strategyPnlTax[stratName] || 0;
                        runningTotal += netPnl;
                        if (runningTotal > peakTotal) peakTotal = runningTotal;
                        
                        monthlyTotals[monthKey].total += details.pnl;
                        monthlyTotals[monthKey].net += netPnl;
                        monthlyTotals[monthKey].margin += (trade.strategyMargins?.[stratName] || 0);
                        monthlyTotals[monthKey].pnlTax += netPnl;
                        
                        dailyTotals[monthKey][dateKey].total += details.pnl;
                        dailyTotals[monthKey][dateKey].net += netPnl;
                        dailyTotals[monthKey][dateKey].margin += (trade.strategyMargins?.[stratName] || 0);
                        dailyTotals[monthKey][dateKey].pnlTax += netPnl;
                        
                        if (!hiddenStrategies.has(stratName)) {
                            monthlyFilteredTotals[monthKey].total += details.pnl;
                            monthlyFilteredTotals[monthKey].net += netPnl;
                            monthlyFilteredTotals[monthKey].margin += (trade.strategyMargins?.[stratName] || 0);
                            monthlyFilteredTotals[monthKey].pnlTax += netPnl;
                            
                            dailyFilteredTotals[monthKey][dateKey].total += details.pnl;
                            dailyFilteredTotals[monthKey][dateKey].net += netPnl;
                            dailyFilteredTotals[monthKey][dateKey].margin += (trade.strategyMargins?.[stratName] || 0);
                            dailyFilteredTotals[monthKey][dateKey].pnlTax += netPnl;
                        }
                    }
                    
                    if (!cumulativeData[monthKey]) cumulativeData[monthKey] = {};
                    cumulativeData[monthKey][dateKey] = {
                        cumTotal: runningTotal,
                        peak: peakTotal,
                        drawdown: peakTotal - runningTotal
                    };
                });
            });

            Object.keys(monthlyData).forEach(monthKey => {
                const datesInMonth = Object.keys(dailyData[monthKey] || {}).sort((a, b) => {
                    const dateA = a.split('/').reverse().join('');
                    const dateB = b.split('/').reverse().join('');
                    return dateA.localeCompare(dateB);
                });
                if (datesInMonth.length > 0) {
                    const lastDate = datesInMonth[datesInMonth.length - 1];
                    if (cumulativeData[monthKey] && cumulativeData[monthKey][lastDate]) {
                        monthlyTotals[monthKey].cumTotal = cumulativeData[monthKey][lastDate].cumTotal;
                        monthlyTotals[monthKey].peak = cumulativeData[monthKey][lastDate].peak;
                        monthlyTotals[monthKey].drawdown = cumulativeData[monthKey][lastDate].drawdown;
                        monthlyFilteredTotals[monthKey].cumTotal = cumulativeData[monthKey][lastDate].cumTotal;
                        monthlyFilteredTotals[monthKey].peak = cumulativeData[monthKey][lastDate].peak;
                        monthlyFilteredTotals[monthKey].drawdown = cumulativeData[monthKey][lastDate].drawdown;
                    }
                }
            });

            // Calculate AMI PNL (A.PRO PNL * Broker Lot Size)
            const aproStrategies = Array.from(strategies).filter(s => s.startsWith('A.PRO'));
            
            Object.keys(monthlyTotals).forEach(monthKey => {
                let amiPnlTotal = 0;
                let amiPnlFiltered = 0;
                
                const monthTrades = trades.filter(trade => {
                    const tradeParts = trade.date.split('/');
                    return tradeParts[1] === monthKey;
                });
                
                // Build daily max lots
                const dailyMaxLots = {};
                monthTrades.forEach(trade => {
                    const dateKey = trade.date;
                    if (!dailyMaxLots[dateKey]) {
                        dailyMaxLots[dateKey] = {};
                    }
                    
                    if (trade.strategyDetails) {
                        const allBrokerStrategies = Array.from(strategies).filter(s => !s.startsWith('A.PRO'));
                        allBrokerStrategies.forEach(brokerStrat => {
                            const lotSize = trade.strategyDetails[brokerStrat]?.lot || 0;
                            if (lotSize > 0) {
                                if (!dailyMaxLots[dateKey][brokerStrat] || lotSize > dailyMaxLots[dateKey][brokerStrat]) {
                                    dailyMaxLots[dateKey][brokerStrat] = lotSize;
                                }
                            }
                        });
                    }
                });
                
                // Calculate AMI PNL contribution
                monthTrades.forEach(trade => {
                    if (trade.strategyDetails) {
                        aproStrategies.forEach(aproStrat => {
                            const aproPnl = trade.strategyDetails[aproStrat]?.pnl || 0;
                            
                            if (aproPnl !== 0) {
                                const proMatch = aproStrat.match(/PRO\s*(\d+)/i);
                                if (proMatch) {
                                    const proNum = proMatch[1];
                                    
                                    const allBrokerStrategies = Array.from(strategies).filter(s => !s.startsWith('A.PRO'));
                                    allBrokerStrategies.forEach(brokerStrat => {
                                        const brokerProMatch = brokerStrat.match(/PRO\s*(\d+)/i);
                                        if (brokerProMatch && brokerProMatch[1] === proNum) {
                                            let lotSize = trade.strategyDetails[brokerStrat]?.lot || 0;
                                            
                                            if (lotSize === 0 && dailyMaxLots[trade.date]?.[brokerStrat]) {
                                                lotSize = dailyMaxLots[trade.date][brokerStrat];
                                            }
                                            
                                            const contribution = aproPnl * lotSize;
                                            amiPnlTotal += contribution;
                                            
                                            if (!hiddenStrategies.has(brokerStrat)) {
                                                amiPnlFiltered += contribution;
                                            }
                                        }
                                    });
                                }
                            }
                        });
                    }
                });
                
                monthlyTotals[monthKey].amiPnl = amiPnlTotal;
                monthlyFilteredTotals[monthKey].amiPnl = amiPnlFiltered;
                
                // Also calculate daily AMI PNL
                Object.keys(dailyData[monthKey] || {}).forEach(dateKey => {
                    let dailyAmiPnl = 0;
                    let dailyAmiPnlFiltered = 0;
                    
                    const dayTrades = monthTrades.filter(t => t.date === dateKey);
                    
                    dayTrades.forEach(trade => {
                        if (trade.strategyDetails) {
                            aproStrategies.forEach(aproStrat => {
                                const aproPnl = trade.strategyDetails[aproStrat]?.pnl || 0;
                                
                                if (aproPnl !== 0) {
                                    const proMatch = aproStrat.match(/PRO\s*(\d+)/i);
                                    if (proMatch) {
                                        const proNum = proMatch[1];
                                        
                                        const allBrokerStrategies = Array.from(strategies).filter(s => !s.startsWith('A.PRO'));
                                        allBrokerStrategies.forEach(brokerStrat => {
                                            const brokerProMatch = brokerStrat.match(/PRO\s*(\d+)/i);
                                            if (brokerProMatch && brokerProMatch[1] === proNum) {
                                                let lotSize = trade.strategyDetails[brokerStrat]?.lot || 0;
                                                
                                                if (lotSize === 0 && dailyMaxLots[dateKey]?.[brokerStrat]) {
                                                    lotSize = dailyMaxLots[dateKey][brokerStrat];
                                                }
                                                
                                                const contribution = aproPnl * lotSize;
                                                dailyAmiPnl += contribution;
                                                
                                                if (!hiddenStrategies.has(brokerStrat)) {
                                                    dailyAmiPnlFiltered += contribution;
                                                }
                                            }
                                        });
                                    }
                                }
                            });
                        }
                    });
                    
                    dailyTotals[monthKey][dateKey].amiPnl = dailyAmiPnl;
                    dailyFilteredTotals[monthKey][dateKey].amiPnl = dailyAmiPnlFiltered;
                });
            });

            allStrategies = Array.from(strategies).sort((a, b) => {
                const aIsAPro = a.startsWith('A.PRO');
                const bIsAPro = b.startsWith('A.PRO');
                
                if (aIsAPro && !bIsAPro) return -1;
                if (!aIsAPro && bIsAPro) return 1;
                
                if (aIsAPro && bIsAPro) {
                    const aNum = parseInt(a.match(/\d+/)?.[0] || '0');
                    const bNum = parseInt(b.match(/\d+/)?.[0] || '0');
                    return aNum - bNum;
                }
                
                return a.localeCompare(b);
            });
            
            const visibleStrategies = allStrategies.filter(s => !hiddenStrategies.has(s));
            
            // Calculate Expenses and TOTAL MARGIN using ALL trades (not filtered by month)
            // because we need cumulative calculations across all months
            const sortedAllTrades = [...allTrades].sort((a, b) => {
                const dateA = a.date.split('/').reverse().join('');
                const dateB = b.date.split('/').reverse().join('');
                return dateA.localeCompare(dateB);
            });
            const monthlyExpensesAndMargins = calculateExpensesAndMargins(sortedAllTrades, hiddenStrategies, Array.from(strategies), showFilteredTotals);
            
            // Calculate daily total margins
            const dailyTotalMargins = calculateDailyTotalMargins(sortedAllTrades, Array.from(strategies));
            
            // Calculate daily expenses
            const dailyExpenses = calculateDailyExpenses(sortedAllTrades, Array.from(strategies), dailyTotalMargins);
            
            renderPivotTable(monthlyData, dailyData, visibleStrategies, monthlyTotals, dailyTotals, monthlyFilteredTotals, dailyFilteredTotals, cumulativeData, monthlyExpensesAndMargins, dailyTotalMargins, dailyExpenses);
        }
        
        function calculateExpensesAndMargins(sortedTrades, hiddenStrategies, allStrategiesParam, useFilteredTotals) {
            const result = {};
            let startingCapital = 0;
            let cumulativeNetPnl = 0;
            let cumulativeCharges = 0;
            let previousMonthTotalMargin = 0;
            
            // Group trades by month
            const tradesByMonth = {};
            sortedTrades.forEach(trade => {
                const monthKey = trade.date.split('/')[1];
                if (!tradesByMonth[monthKey]) {
                    tradesByMonth[monthKey] = [];
                }
                tradesByMonth[monthKey].push(trade);
            });
            
            // Use provided strategies
            const allStrategies = allStrategiesParam;
            
            const sortedMonths = Object.keys(tradesByMonth).sort();
            
            sortedMonths.forEach((monthKey, monthIdx) => {
                const monthTrades = tradesByMonth[monthKey];
                
                let monthMargin = 0;
                let filteredMonthMargin = 0;
                let latestDayPnlTax = 0;
                let filteredLatestDayPnlTax = 0;
                
                if (monthTrades.length > 0) {
                    const brokerMarginsByDate = {};
                    const allBrokerStrategies = allStrategies.filter(s => !s.startsWith('A.PRO'));
                    
                    // Collect margins by date and broker
                    monthTrades.forEach(trade => {
                        const tradeDate = trade.date;
                        if (!brokerMarginsByDate[tradeDate]) {
                            brokerMarginsByDate[tradeDate] = {};
                        }
                        
                        if (trade.strategyDetails) {
                            allBrokerStrategies.forEach(brokerStrat => {
                                const margin = trade.strategyDetails[brokerStrat]?.margin || 0;
                                const brokerMatch = brokerStrat.match(/^(B\d+)/);
                                
                                if (brokerMatch) {
                                    const brokerCode = brokerMatch[1];
                                    if (!brokerMarginsByDate[tradeDate][brokerCode]) {
                                        brokerMarginsByDate[tradeDate][brokerCode] = {};
                                    }
                                    // Store MAX margin for each strategy on each date
                                    if (!brokerMarginsByDate[tradeDate][brokerCode][brokerStrat] || margin > brokerMarginsByDate[tradeDate][brokerCode][brokerStrat]) {
                                        brokerMarginsByDate[tradeDate][brokerCode][brokerStrat] = margin;
                                    }
                                }
                            });
                        }
                    });
                    
                    // Get sorted dates (latest first)
                    const sortedDates = Object.keys(brokerMarginsByDate).sort((a, b) => {
                        const dayA = parseInt(a.split('/')[0]);
                        const dayB = parseInt(b.split('/')[0]);
                        return dayB - dayA;
                    });
                    
                    // Get all unique brokers
                    const allBrokersInMonth = new Set();
                    Object.values(brokerMarginsByDate).forEach(dateMargins => {
                        Object.keys(dateMargins).forEach(broker => allBrokersInMonth.add(broker));
                    });
                    
                    // For each broker, find the most recent day with non-zero margin
                    const brokerMaxMargins = {};
                    const filteredBrokerMaxMargins = {};
                    
                    allBrokersInMonth.forEach(brokerCode => {
                        for (let i = 0; i < sortedDates.length; i++) {
                            const checkDate = sortedDates[i];
                            
                            if (brokerMarginsByDate[checkDate] && brokerMarginsByDate[checkDate][brokerCode]) {
                                const strategyMargins = Object.entries(brokerMarginsByDate[checkDate][brokerCode]);
                                const margins = strategyMargins.map(([strat, margin]) => margin);
                                const maxMargin = margins.length > 0 ? Math.max(...margins) : 0;
                                
                                if (maxMargin > 0) {
                                    brokerMaxMargins[brokerCode] = maxMargin;
                                    
                                    // Calculate filtered margin
                                    const filteredMargins = strategyMargins
                                        .filter(([strat, margin]) => !hiddenStrategies.has(strat))
                                        .map(([strat, margin]) => margin);
                                    const maxFilteredMargin = filteredMargins.length > 0 ? Math.max(...filteredMargins) : 0;
                                    if (maxFilteredMargin > 0) {
                                        filteredBrokerMaxMargins[brokerCode] = maxFilteredMargin;
                                    }
                                    break;
                                }
                            }
                        }
                    });
                    
                    monthMargin = Object.values(brokerMaxMargins).reduce((sum, val) => sum + val, 0);
                    filteredMonthMargin = Object.values(filteredBrokerMaxMargins).reduce((sum, val) => sum + val, 0);
                    
                    // PnL Tax calculation with carry-forward logic
                    const brokerPnlTaxByDate = {};
                    monthTrades.forEach(trade => {
                        const tradeDate = trade.date;
                        if (!brokerPnlTaxByDate[tradeDate]) {
                            brokerPnlTaxByDate[tradeDate] = {};
                        }
                        
                        if (trade && trade.strategyPnlTax) {
                            Object.entries(trade.strategyPnlTax).forEach(([stratName, pnlTax]) => {
                                if (!stratName.startsWith('A.PRO')) {
                                    const brokerMatch = stratName.match(/^(B\d+)/);
                                    if (brokerMatch) {
                                        const brokerCode = brokerMatch[1];
                                        if (!brokerPnlTaxByDate[tradeDate][brokerCode]) {
                                            brokerPnlTaxByDate[tradeDate][brokerCode] = {};
                                        }
                                        if (!brokerPnlTaxByDate[tradeDate][brokerCode][stratName]) {
                                            brokerPnlTaxByDate[tradeDate][brokerCode][stratName] = 0;
                                        }
                                        brokerPnlTaxByDate[tradeDate][brokerCode][stratName] += pnlTax;
                                    }
                                }
                            });
                        }
                    });
                    
                    // For each broker, use PnL Tax from the margin date FORWARD to end of month
                    const strategyPnlTaxMap = {};
                    const filteredStrategyPnlTaxMap = {};
                    
                    allBrokersInMonth.forEach(brokerCode => {
                        // Find which date we used for this broker's margin
                        for (let i = 0; i < sortedDates.length; i++) {
                            const checkDate = sortedDates[i];
                            
                            if (brokerMarginsByDate[checkDate] && brokerMarginsByDate[checkDate][brokerCode]) {
                                const strategyMargins = Object.entries(brokerMarginsByDate[checkDate][brokerCode]);
                                const margins = strategyMargins.map(([strat, margin]) => margin);
                                const maxMargin = margins.length > 0 ? Math.max(...margins) : 0;
                                
                                if (maxMargin > 0) {
                                    // Accumulate PnL Tax from this date FORWARD to end of month
                                    for (let j = i; j >= 0; j--) {
                                        const dateToCheck = sortedDates[j];
                                        
                                        if (brokerPnlTaxByDate[dateToCheck] && brokerPnlTaxByDate[dateToCheck][brokerCode]) {
                                            Object.entries(brokerPnlTaxByDate[dateToCheck][brokerCode]).forEach(([stratName, pnlTax]) => {
                                                const isHidden = hiddenStrategies.has(stratName);
                                                
                                                if (!strategyPnlTaxMap[stratName]) {
                                                    strategyPnlTaxMap[stratName] = 0;
                                                }
                                                strategyPnlTaxMap[stratName] += pnlTax;
                                                
                                                if (!isHidden) {
                                                    if (!filteredStrategyPnlTaxMap[stratName]) {
                                                        filteredStrategyPnlTaxMap[stratName] = 0;
                                                    }
                                                    filteredStrategyPnlTaxMap[stratName] += pnlTax;
                                                }
                                            });
                                        }
                                    }
                                    break;
                                }
                            }
                        }
                    });
                    
                    latestDayPnlTax = Object.values(strategyPnlTaxMap).reduce((sum, val) => sum + val, 0);
                    filteredLatestDayPnlTax = Object.values(filteredStrategyPnlTaxMap).reduce((sum, val) => sum + val, 0);
                }
                
                const displayMargin = useFilteredTotals ? filteredMonthMargin : monthMargin;
                const displayLatestDayPnlTax = useFilteredTotals ? filteredLatestDayPnlTax : latestDayPnlTax;
                const totalMargin = displayMargin + displayLatestDayPnlTax;
                
                // Calculate starting capital for first month
                if (monthIdx === 0 && monthTrades.length > 0) {
                    const tradesByDate = {};
                    monthTrades.forEach(trade => {
                        const dateKey = trade.date;
                        if (!tradesByDate[dateKey]) {
                            tradesByDate[dateKey] = [];
                        }
                        tradesByDate[dateKey].push(trade);
                    });
                    
                    const sortedDatesInMonth = Object.keys(tradesByDate).sort((a, b) => {
                        const dayA = parseInt(a.split('/')[0]);
                        const dayB = parseInt(b.split('/')[0]);
                        return dayA - dayB;
                    });
                    
                    if (sortedDatesInMonth.length > 0) {
                        const firstDate = sortedDatesInMonth[0];
                        const firstDateTrades = tradesByDate[firstDate];
                        
                        const firstDateBrokerMargins = {};
                        const allBrokerStrategies = allStrategies.filter(s => !s.startsWith('A.PRO'));
                        
                        firstDateTrades.forEach(trade => {
                            if (trade.strategyDetails) {
                                allBrokerStrategies.forEach(brokerStrat => {
                                    const margin = trade.strategyDetails[brokerStrat]?.margin || 0;
                                    const brokerMatch = brokerStrat.match(/^(B\d+)/);
                                    if (brokerMatch && margin > 0) {
                                        const brokerCode = brokerMatch[1];
                                        if (!firstDateBrokerMargins[brokerCode]) {
                                            firstDateBrokerMargins[brokerCode] = {};
                                        }
                                        firstDateBrokerMargins[brokerCode][brokerStrat] = margin;
                                    }
                                });
                            }
                        });
                        
                        let firstDateMargin = 0;
                        Object.keys(firstDateBrokerMargins).forEach(brokerCode => {
                            const margins = Object.values(firstDateBrokerMargins[brokerCode]);
                            if (margins.length > 0) {
                                firstDateMargin += Math.max(...margins);
                            }
                        });
                        
                        startingCapital = firstDateMargin;
                    }
                }
                
                // Calculate month net PnL
                let monthNet = 0;
                monthTrades.forEach(trade => {
                    if (trade && trade.strategyPnlTax) {
                        Object.entries(trade.strategyPnlTax).forEach(([stratName, pnlTax]) => {
                            if (!stratName.startsWith('A.PRO')) {
                                // If useFilteredTotals is true, only include non-hidden strategies
                                // If useFilteredTotals is false, include all strategies
                                if (!useFilteredTotals || !hiddenStrategies.has(stratName)) {
                                    monthNet += pnlTax;
                                }
                            }
                        });
                    }
                });
                
                cumulativeNetPnl += monthNet;
                const runningCapital = startingCapital + cumulativeNetPnl;
                const chargesWithdrawn = totalMargin - runningCapital - cumulativeCharges;
                
                cumulativeCharges += chargesWithdrawn;
                previousMonthTotalMargin = totalMargin;
                
                result[monthKey] = {
                    totalMargin: totalMargin,
                    expenses: chargesWithdrawn
                };
            });
            
            return result;
        }

        function calculateDailyExpenses(sortedTrades, allStrategiesParam, dailyTotalMargins) {
            const result = {};
            
            // Group trades by date
            const tradesByDate = {};
            sortedTrades.forEach(trade => {
                const dateKey = trade.date;
                if (!tradesByDate[dateKey]) {
                    tradesByDate[dateKey] = [];
                }
                tradesByDate[dateKey].push(trade);
            });
            
            // Sort dates chronologically
            const sortedDates = Object.keys(tradesByDate).sort((a, b) => {
                const dateA = a.split('/').reverse().join('');
                const dateB = b.split('/').reverse().join('');
                return dateA.localeCompare(dateB);
            });
            
            // Calculate starting capital from first date
            let startingCapital = 0;
            if (sortedDates.length > 0) {
                const firstDate = sortedDates[0];
                const firstDateTrades = tradesByDate[firstDate];
                const firstDateBrokerMargins = {};
                const allBrokerStrategies = allStrategiesParam.filter(s => !s.startsWith('A.PRO'));
                
                firstDateTrades.forEach(trade => {
                    if (trade.strategyDetails) {
                        allBrokerStrategies.forEach(brokerStrat => {
                            const margin = trade.strategyDetails[brokerStrat]?.margin || 0;
                            const brokerMatch = brokerStrat.match(/^(B\d+)/);
                            if (brokerMatch && margin > 0) {
                                const brokerCode = brokerMatch[1];
                                if (!firstDateBrokerMargins[brokerCode]) {
                                    firstDateBrokerMargins[brokerCode] = {};
                                }
                                firstDateBrokerMargins[brokerCode][brokerStrat] = margin;
                            }
                        });
                    }
                });
                
                Object.keys(firstDateBrokerMargins).forEach(brokerCode => {
                    const margins = Object.values(firstDateBrokerMargins[brokerCode]);
                    if (margins.length > 0) {
                        startingCapital += Math.max(...margins);
                    }
                });
            }
            
            let cumulativeNetPnl = 0;
            let cumulativeCharges = 0;
            
            // Calculate expenses for each day
            sortedDates.forEach(dateKey => {
                const dayTrades = tradesByDate[dateKey];
                
                // Calculate day net PnL
                let dayNet = 0;
                dayTrades.forEach(trade => {
                    if (trade && trade.strategyPnlTax) {
                        Object.entries(trade.strategyPnlTax).forEach(([stratName, pnlTax]) => {
                            if (!stratName.startsWith('A.PRO')) {
                                dayNet += pnlTax;
                            }
                        });
                    }
                });
                
                cumulativeNetPnl += dayNet;
                const runningCapital = startingCapital + cumulativeNetPnl;
                const totalMargin = dailyTotalMargins[dateKey] || 0;
                const chargesWithdrawn = totalMargin - runningCapital - cumulativeCharges;
                
                cumulativeCharges += chargesWithdrawn;
                
                result[dateKey] = chargesWithdrawn;
            });
            
            return result;
        }

        function calculateDailyTotalMargins(sortedTrades, allStrategiesParam) {
            const result = {};
            
            // Group trades by date
            const tradesByDate = {};
            sortedTrades.forEach(trade => {
                const dateKey = trade.date;
                if (!tradesByDate[dateKey]) {
                    tradesByDate[dateKey] = [];
                }
                tradesByDate[dateKey].push(trade);
            });
            
            // Sort dates chronologically
            const sortedDates = Object.keys(tradesByDate).sort((a, b) => {
                const dateA = a.split('/').reverse().join('');
                const dateB = b.split('/').reverse().join('');
                return dateA.localeCompare(dateB);
            });
            
            // Build PnL Tax by date and broker
            const brokerPnlTaxByDate = {};
            sortedTrades.forEach(trade => {
                const tradeDate = trade.date;
                if (!brokerPnlTaxByDate[tradeDate]) {
                    brokerPnlTaxByDate[tradeDate] = {};
                }
                
                if (trade && trade.strategyPnlTax) {
                    Object.entries(trade.strategyPnlTax).forEach(([stratName, pnlTax]) => {
                        if (!stratName.startsWith('A.PRO')) {
                            const brokerMatch = stratName.match(/^(B\d+)/);
                            if (brokerMatch) {
                                const brokerCode = brokerMatch[1];
                                if (!brokerPnlTaxByDate[tradeDate][brokerCode]) {
                                    brokerPnlTaxByDate[tradeDate][brokerCode] = {};
                                }
                                if (!brokerPnlTaxByDate[tradeDate][brokerCode][stratName]) {
                                    brokerPnlTaxByDate[tradeDate][brokerCode][stratName] = 0;
                                }
                                brokerPnlTaxByDate[tradeDate][brokerCode][stratName] += pnlTax;
                            }
                        }
                    });
                }
            });
            
            // Track previous day's broker-wise max margins and margin dates
            let previousDayBrokerMaxMargins = {};
            let brokerMarginDates = {}; // Track which date each broker's margin comes from
            
            // Calculate margin for each date
            sortedDates.forEach((dateKey, dateIndex) => {
                const dayTrades = tradesByDate[dateKey];
                const dayBrokerMargins = {};
                
                dayTrades.forEach(trade => {
                    if (trade.strategyDetails) {
                        Object.entries(trade.strategyDetails).forEach(([stratName, details]) => {
                            if (!stratName.startsWith('A.PRO')) {
                                const margin = details.margin || 0;
                                const brokerMatch = stratName.match(/^(B\d+)/);
                                if (brokerMatch) {
                                    const brokerCode = brokerMatch[1];
                                    if (!dayBrokerMargins[brokerCode]) {
                                        dayBrokerMargins[brokerCode] = {};
                                    }
                                    // Store max margin for each strategy
                                    if (!dayBrokerMargins[brokerCode][stratName] || margin > dayBrokerMargins[brokerCode][stratName]) {
                                        dayBrokerMargins[brokerCode][stratName] = margin;
                                    }
                                }
                            }
                        });
                    }
                });
                
                // Calculate max margin per broker and track margin date
                const currentDayBrokerMaxMargins = {};
                let dayTotalMargin = 0;
                
                // Get all brokers (from today and yesterday)
                const allBrokers = new Set([...Object.keys(dayBrokerMargins), ...Object.keys(previousDayBrokerMaxMargins)]);
                
                allBrokers.forEach(brokerCode => {
                    let brokerMaxMargin = 0;
                    let marginDate = dateKey;
                    
                    // Calculate today's max margin for this broker
                    if (dayBrokerMargins[brokerCode]) {
                        const margins = Object.values(dayBrokerMargins[brokerCode]);
                        if (margins.length > 0) {
                            brokerMaxMargin = Math.max(...margins);
                        }
                    }
                    
                    // If broker's margin is 0 and we have yesterday's data, use yesterday's margin and date
                    if (brokerMaxMargin === 0 && previousDayBrokerMaxMargins[brokerCode]) {
                        brokerMaxMargin = previousDayBrokerMaxMargins[brokerCode];
                        marginDate = brokerMarginDates[brokerCode] || dateKey;
                    }
                    
                    currentDayBrokerMaxMargins[brokerCode] = brokerMaxMargin;
                    brokerMarginDates[brokerCode] = marginDate;
                    dayTotalMargin += brokerMaxMargin;
                });
                
                // Calculate PnL Tax from margin date forward to current date
                let dayPnlTax = 0;
                
                allBrokers.forEach(brokerCode => {
                    const marginDate = brokerMarginDates[brokerCode];
                    const marginDateIndex = sortedDates.indexOf(marginDate);
                    
                    // Accumulate PnL Tax from margin date forward to current date
                    for (let i = marginDateIndex; i <= dateIndex; i++) {
                        const checkDate = sortedDates[i];
                        if (brokerPnlTaxByDate[checkDate] && brokerPnlTaxByDate[checkDate][brokerCode]) {
                            Object.values(brokerPnlTaxByDate[checkDate][brokerCode]).forEach(pnlTax => {
                                dayPnlTax += pnlTax;
                            });
                        }
                    }
                });
                
                // Total Margin = Margin + PnL Tax from margin date forward
                result[dateKey] = dayTotalMargin + dayPnlTax;
                
                // Store today's broker max margins for next iteration
                previousDayBrokerMaxMargins = { ...currentDayBrokerMaxMargins };
            });
            
            return result;
        }

        function renderPivotTable(monthlyData, dailyData, strategies, monthlyTotals, dailyTotals, monthlyFilteredTotals, dailyFilteredTotals, cumulativeData, monthlyExpensesAndMargins, dailyTotalMargins, dailyExpenses) {
            if (strategies.length === 0) {
                const drawdownHeader = showDrawdown ? '<th class="number-col">DRAWDOWN</th>' : '';
                const colspan = showDrawdown ? '4' : '3';
                elements.tableHeaders.innerHTML = `<tr><th>Period</th><th class="number-col">TOTAL</th><th class="number-col">NET</th>${drawdownHeader}</tr>`;
                elements.tableBody.innerHTML = `<tr><td colspan="${colspan}" class="no-data">No strategies selected. Use "Hide Strategies" filter to show strategies.</td></tr>`;
                return;
            }

            // Separate A.PRO and broker strategies
            const aproStrategies = strategies.filter(s => s.startsWith('A.PRO'));
            const brokerStrategies = strategies.filter(s => !s.startsWith('A.PRO'));
            
            // Group broker strategies by broker code
            const brokerGroups = {};
            brokerStrategies.forEach(strat => {
                const brokerMatch = strat.match(/^(B\d+)/);
                if (brokerMatch) {
                    const brokerCode = brokerMatch[1];
                    if (!brokerGroups[brokerCode]) {
                        brokerGroups[brokerCode] = [];
                    }
                    brokerGroups[brokerCode].push(strat);
                }
            });
            const sortedBrokers = Object.keys(brokerGroups).sort();

            let headerRow1 = '<tr class="header-row-1">';
            headerRow1 += '<th rowspan="2">Period</th>';
            
            // A.PRO section
            if (aproStrategies.length > 0) {
                headerRow1 += `<th colspan="${aproStrategies.length}" class="number-col apro-boundary">Amibroker PNL</th>`;
            }
            
            // LOT section by broker
            if (showLot) {
                const columnLabel = showTradeCount ? 'TRADE COUNT' : 'LOT';
                sortedBrokers.forEach(brokerCode => {
                    const count = brokerGroups[brokerCode].length;
                    headerRow1 += `<th colspan="${count}" class="number-col broker-boundary">${brokerCode} ${columnLabel}</th>`;
                });
            }
            
            // DPNL section by broker
            sortedBrokers.forEach(brokerCode => {
                const count = brokerGroups[brokerCode].length;
                headerRow1 += `<th colspan="${count}" class="number-col broker-boundary">${brokerCode} DPNL</th>`;
            });
            
            // PNL section by broker
            sortedBrokers.forEach(brokerCode => {
                const count = brokerGroups[brokerCode].length;
                headerRow1 += `<th colspan="${count}" class="number-col broker-boundary">${brokerCode} PNL</th>`;
            });
            
            headerRow1 += '<th class="number-col total-net-col" rowspan="2">AMI PNL</th>';
            headerRow1 += '<th class="number-col total-net-col total-col-border" rowspan="2">TOTAL</th>';
            headerRow1 += '<th class="number-col total-net-col" rowspan="2">NET PNL</th>';
            headerRow1 += '<th class="number-col net-pnl-percent-col" rowspan="2">NET %</th>';
            headerRow1 += '<th class="number-col expenses-col" rowspan="2">Expenses</th>';
            headerRow1 += '<th class="number-col total-net-col" rowspan="2">TOTAL MARGIN</th>';
            if (showDrawdown) {
                headerRow1 += '<th class="number-col drawdown-col" rowspan="2">DRAWDOWN</th>';
            }
            headerRow1 += '</tr>';

            let headerRow2 = '<tr class="header-row-2">';
            
            // A.PRO strategy names
            aproStrategies.forEach((strategy, idx) => {
                const displayName = formatStrategyName(strategy);
                const stratIndex = allStrategies.indexOf(strategy);
                const bgClass = `strategy-bg-${stratIndex % 5}`;
                const boundaryClass = idx === aproStrategies.length - 1 ? ' apro-boundary' : '';
                headerRow2 += `<th class="number-col apro-pnl-col ${bgClass}${boundaryClass}">${displayName}</th>`;
            });
            
            // LOT column strategy names
            if (showLot) {
                sortedBrokers.forEach((brokerCode, brokerIdx) => {
                    brokerGroups[brokerCode].forEach((strategy, idx) => {
                        const displayName = formatStrategyName(strategy).replace(/^B\d+\s*/, '');
                        const stratIndex = allStrategies.indexOf(strategy);
                        const bgClass = `strategy-bg-${stratIndex % 5}`;
                        const isLastInBroker = idx === brokerGroups[brokerCode].length - 1;
                        const isLastBroker = brokerIdx === sortedBrokers.length - 1;
                        const boundaryClass = (isLastInBroker && isLastBroker) ? ' broker-boundary' : '';
                        headerRow2 += `<th class="number-col lot-col ${bgClass}${boundaryClass}">${displayName}</th>`;
                    });
                });
            }
            
            // DPNL column strategy names
            sortedBrokers.forEach((brokerCode, brokerIdx) => {
                brokerGroups[brokerCode].forEach((strategy, idx) => {
                    const displayName = formatStrategyName(strategy).replace(/^B\d+\s*/, '');
                    const stratIndex = allStrategies.indexOf(strategy);
                    const bgClass = `strategy-bg-${stratIndex % 5}`;
                    const isLastInBroker = idx === brokerGroups[brokerCode].length - 1;
                    const isLastBroker = brokerIdx === sortedBrokers.length - 1;
                    const boundaryClass = (isLastInBroker && isLastBroker) ? ' broker-boundary' : '';
                    headerRow2 += `<th class="number-col ${bgClass}${boundaryClass}">${displayName}</th>`;
                });
            });
            
            // PNL column strategy names
            sortedBrokers.forEach((brokerCode, brokerIdx) => {
                brokerGroups[brokerCode].forEach((strategy, idx) => {
                    const displayName = formatStrategyName(strategy).replace(/^B\d+\s*/, '');
                    const stratIndex = allStrategies.indexOf(strategy);
                    const bgClass = `strategy-bg-${stratIndex % 5}`;
                    const isLastInBroker = idx === brokerGroups[brokerCode].length - 1;
                    const isLastBroker = brokerIdx === sortedBrokers.length - 1;
                    const boundaryClass = (isLastInBroker && isLastBroker) ? ' broker-boundary' : '';
                    headerRow2 += `<th class="number-col ${bgClass}${boundaryClass}">${displayName}</th>`;
                });
            });
            
            headerRow2 += '</tr>';
            elements.tableHeaders.innerHTML = headerRow1 + headerRow2;

            const sortedMonths = Object.keys(monthlyData).sort();
            const totals = { strategies: {}, totalProfits: 0, netBrProfits: 0, totalAmiPnl: 0, totalExpenses: 0, totalMarginSum: 0 };
            strategies.forEach(strat => {
                totals.strategies[strat] = { lot: 0, pnl: 0, dpnl: 0, net: 0, tradeCount: 0, lotSum: 0, lotCount: 0 };
            });
            
            const totalsToUse = showFilteredTotals ? monthlyFilteredTotals : monthlyTotals;
            Object.values(totalsToUse).forEach(monthTotal => {
                totals.totalProfits += monthTotal.total;
                totals.netBrProfits += monthTotal.net;
                totals.totalAmiPnl += (monthTotal.amiPnl || 0);
            });

            let bodyHtml = '';
            let previousMonthTotalMargin = 0;
            sortedMonths.forEach(month => {
                const displayMonth = monthNames[parseInt(month) - 1];
                bodyHtml += `<tr class="month-row" onclick="toggleMonth('${month}')">`;
                bodyHtml += `<td><span class="expand-icon" id="icon-${month}">▶</span>${displayMonth}</td>`;

                const totalsToUse = showFilteredTotals ? monthlyFilteredTotals : monthlyTotals;
                const monthTotal = totalsToUse[month]?.total || 0;
                const monthNetTotal = totalsToUse[month]?.net || 0;

                // First accumulate strategy data
                strategies.forEach((strategy) => {
                    const stratData = monthlyData[month][strategy] || { lot: 0, pnl: 0, dpnl: 0, net: 0, tradeCount: 0, lotSum: 0, lotCount: 0 };
                    const { pnl, dpnl, net, tradeCount, lotSum, lotCount } = stratData;

                    totals.strategies[strategy].lotSum += lotSum;
                    totals.strategies[strategy].lotCount += lotCount;
                    totals.strategies[strategy].pnl += pnl;
                    totals.strategies[strategy].dpnl += dpnl;
                    totals.strategies[strategy].net += net;
                    totals.strategies[strategy].tradeCount += tradeCount;
                });

                // Output A.PRO PNL columns
                aproStrategies.forEach((strategy, idx) => {
                    const stratData = monthlyData[month][strategy] || { lot: 0, pnl: 0, dpnl: 0, net: 0, tradeCount: 0, lotSum: 0, lotCount: 0 };
                    const pnl = stratData.pnl;
                    const stratIndex = allStrategies.indexOf(strategy);
                    const bgClass = `strategy-bg-${stratIndex % 5}`;
                    const boundaryClass = idx === aproStrategies.length - 1 ? ' apro-boundary' : '';
                    bodyHtml += `<td class="number-col apro-pnl-col ${bgClass} ${pnl >= 0 ? 'positive' : 'negative'}${boundaryClass}">${formatNumber(pnl)}</td>`;
                });
                
                // Output LOT columns grouped by broker
                if (showLot) {
                    sortedBrokers.forEach((brokerCode, brokerIdx) => {
                        brokerGroups[brokerCode].forEach((strategy, idx) => {
                            const stratData = monthlyData[month][strategy] || { lot: 0, pnl: 0, dpnl: 0, net: 0, tradeCount: 0, lotSum: 0, lotCount: 0 };
                            const { tradeCount, lotSum, lotCount } = stratData;
                            const lot = lotCount > 0 ? lotSum / lotCount : 0;
                            const stratIndex = allStrategies.indexOf(strategy);
                            const bgClass = `strategy-bg-${stratIndex % 5}`;
                            const isLastInBroker = idx === brokerGroups[brokerCode].length - 1;
                            const isLastBroker = brokerIdx === sortedBrokers.length - 1;
                            const boundaryClass = (isLastInBroker && isLastBroker) ? ' broker-boundary' : '';
                            const displayValue = showTradeCount ? (tradeCount > 0 ? tradeCount : '') : (lot > 0 ? lot.toFixed(2) : '');
                            bodyHtml += `<td class="number-col lot-col ${bgClass}${boundaryClass}">${displayValue}</td>`;
                        });
                    });
                }
                
                // Output DPNL columns grouped by broker
                sortedBrokers.forEach((brokerCode, brokerIdx) => {
                    brokerGroups[brokerCode].forEach((strategy, idx) => {
                        const stratData = monthlyData[month][strategy] || { lot: 0, pnl: 0, dpnl: 0, net: 0, tradeCount: 0, lotSum: 0, lotCount: 0 };
                        const dpnl = stratData.dpnl;
                        const stratIndex = allStrategies.indexOf(strategy);
                        const bgClass = `strategy-bg-${stratIndex % 5}`;
                        const isLastInBroker = idx === brokerGroups[brokerCode].length - 1;
                        const isLastBroker = brokerIdx === sortedBrokers.length - 1;
                        const boundaryClass = (isLastInBroker && isLastBroker) ? ' broker-boundary' : '';
                        bodyHtml += `<td class="number-col dpnl-section ${bgClass} ${dpnl >= 0 ? 'positive' : 'negative'}${boundaryClass}">${formatNumber(dpnl)}</td>`;
                    });
                });
                
                // Output PNL columns grouped by broker
                sortedBrokers.forEach((brokerCode, brokerIdx) => {
                    brokerGroups[brokerCode].forEach((strategy, idx) => {
                        const stratData = monthlyData[month][strategy] || { lot: 0, pnl: 0, dpnl: 0, net: 0, tradeCount: 0, lotSum: 0, lotCount: 0 };
                        const pnl = showPnlTax ? stratData.net : stratData.pnl;
                        const stratIndex = allStrategies.indexOf(strategy);
                        const bgClass = `strategy-bg-${stratIndex % 5}`;
                        const isLastInBroker = idx === brokerGroups[brokerCode].length - 1;
                        const isLastBroker = brokerIdx === sortedBrokers.length - 1;
                        const boundaryClass = (isLastInBroker && isLastBroker) ? ' broker-boundary' : '';
                        bodyHtml += `<td class="number-col pnl-section ${bgClass} ${pnl >= 0 ? 'positive' : 'negative'}${boundaryClass}">${formatNumber(pnl)}</td>`;
                    });
                });

                // AMI PNL
                const monthAmiPnl = totalsToUse[month]?.amiPnl || 0;
                bodyHtml += `<td class="number-col total-net-col ${monthAmiPnl >= 0 ? 'positive' : 'negative'}">${formatNumber(monthAmiPnl)}</td>`;

                bodyHtml += `<td class="number-col total-net-col total-col-border ${monthTotal >= 0 ? 'positive' : 'negative'}">${formatNumber(monthTotal)}</td>`;
                
                // NET PNL
                bodyHtml += `<td class="number-col total-net-col ${monthNetTotal >= 0 ? 'positive' : 'negative'}">${formatNumber(monthNetTotal)}</td>`;
                
                // NET PNL % calculation
                let netPnlPercent = 0;
                if (previousMonthTotalMargin !== 0) {
                    netPnlPercent = (monthNetTotal / previousMonthTotalMargin) * 100;
                }
                bodyHtml += `<td class="number-col net-pnl-percent-col ${netPnlPercent >= 0 ? 'positive' : 'negative'}">${netPnlPercent !== 0 ? netPnlPercent.toFixed(2) + '%' : ''}</td>`;
                
                // Expenses and TOTAL MARGIN - use calculated values
                const monthExpensesData = monthlyExpensesAndMargins[month] || { expenses: 0, totalMargin: 0 };
                const expenses = monthExpensesData.expenses;
                const totalMargin = monthExpensesData.totalMargin;
                
                // Accumulate total expenses
                totals.totalExpenses += expenses;
                
                // Accumulate total margin sum
                totals.totalMarginSum += totalMargin;
                
                // Store the last total margin globally
                globalLastTotalMargin = totalMargin;
                
                bodyHtml += `<td class="number-col expenses-col ${expenses >= 0 ? 'positive' : 'negative'}">${formatNumber(expenses)}</td>`;
                bodyHtml += `<td class="number-col total-net-col ${totalMargin >= 0 ? 'positive' : 'negative'}">${formatNumber(totalMargin)}</td>`;
                
                if (showDrawdown) {
                    const monthDrawdown = totalsToUse[month]?.drawdown || 0;
                    bodyHtml += `<td class="number-col drawdown-col negative">${formatNumber(monthDrawdown)}</td>`;
                }
                bodyHtml += '</tr>';
                
                // Update previous month total margin for next iteration
                previousMonthTotalMargin = totalMargin;

                if (dailyData[month]) {
                    const sortedDays = Object.keys(dailyData[month]).sort((a, b) => {
                        const dateA = a.split('/').reverse().join('');
                        const dateB = b.split('/').reverse().join('');
                        return dateA.localeCompare(dateB);
                    });

                    sortedDays.forEach(date => {
                        const dateParts = date.split('/');
                        const displayDate = `${dateParts[0]}-${monthNames[parseInt(dateParts[1]) - 1]}`;
                        bodyHtml += `<tr class="day-row" data-month="${month}"><td>${displayDate}</td>`;

                        const totalsToUse = showFilteredTotals ? dailyFilteredTotals : dailyTotals;
                        const dayTotal = totalsToUse[month][date]?.total || 0;
                        const dayNetTotal = totalsToUse[month][date]?.net || 0;

                        // Output A.PRO PNL columns
                        aproStrategies.forEach((strategy, idx) => {
                            const stratData = dailyData[month][date][strategy] || { lot: 0, pnl: 0, dpnl: 0, net: 0, tradeCount: 0, lotSum: 0, lotCount: 0 };
                            const pnl = stratData.pnl;
                            const stratIndex = allStrategies.indexOf(strategy);
                            const bgClass = `strategy-bg-${stratIndex % 5}`;
                            const boundaryClass = idx === aproStrategies.length - 1 ? ' apro-boundary' : '';
                            bodyHtml += `<td class="number-col apro-pnl-col ${bgClass} ${pnl >= 0 ? 'positive' : 'negative'}${boundaryClass}">${formatNumber(pnl)}</td>`;
                        });
                        
                        // Output LOT columns grouped by broker
                        if (showLot) {
                            sortedBrokers.forEach((brokerCode, brokerIdx) => {
                                brokerGroups[brokerCode].forEach((strategy, idx) => {
                                    const stratData = dailyData[month][date][strategy] || { lot: 0, pnl: 0, dpnl: 0, net: 0, tradeCount: 0, lotSum: 0, lotCount: 0 };
                                    const { tradeCount, lotSum, lotCount } = stratData;
                                    const lot = lotCount > 0 ? lotSum / lotCount : 0;
                                    const stratIndex = allStrategies.indexOf(strategy);
                                    const bgClass = `strategy-bg-${stratIndex % 5}`;
                                    const isLastInBroker = idx === brokerGroups[brokerCode].length - 1;
                                    const isLastBroker = brokerIdx === sortedBrokers.length - 1;
                                    const boundaryClass = (isLastInBroker && isLastBroker) ? ' broker-boundary' : '';
                                    const displayValue = showTradeCount ? (tradeCount > 0 ? tradeCount : '') : (lot > 0 ? lot.toFixed(2) : '');
                                    bodyHtml += `<td class="number-col lot-col ${bgClass}${boundaryClass}">${displayValue}</td>`;
                                });
                            });
                        }
                        
                        // Output DPNL columns grouped by broker
                        sortedBrokers.forEach((brokerCode, brokerIdx) => {
                            brokerGroups[brokerCode].forEach((strategy, idx) => {
                                const stratData = dailyData[month][date][strategy] || { lot: 0, pnl: 0, dpnl: 0, net: 0, tradeCount: 0, lotSum: 0, lotCount: 0 };
                                const dpnl = stratData.dpnl;
                                const stratIndex = allStrategies.indexOf(strategy);
                                const bgClass = `strategy-bg-${stratIndex % 5}`;
                                const isLastInBroker = idx === brokerGroups[brokerCode].length - 1;
                                const isLastBroker = brokerIdx === sortedBrokers.length - 1;
                                const boundaryClass = (isLastInBroker && isLastBroker) ? ' broker-boundary' : '';
                                bodyHtml += `<td class="number-col dpnl-section ${bgClass} ${dpnl >= 0 ? 'positive' : 'negative'}${boundaryClass}">${formatNumber(dpnl)}</td>`;
                            });
                        });
                        
                        // Output PNL columns grouped by broker
                        sortedBrokers.forEach((brokerCode, brokerIdx) => {
                            brokerGroups[brokerCode].forEach((strategy, idx) => {
                                const stratData = dailyData[month][date][strategy] || { lot: 0, pnl: 0, dpnl: 0, net: 0, tradeCount: 0, lotSum: 0, lotCount: 0 };
                                const pnl = showPnlTax ? stratData.net : stratData.pnl;
                                const stratIndex = allStrategies.indexOf(strategy);
                                const bgClass = `strategy-bg-${stratIndex % 5}`;
                                const isLastInBroker = idx === brokerGroups[brokerCode].length - 1;
                                const isLastBroker = brokerIdx === sortedBrokers.length - 1;
                                const boundaryClass = (isLastInBroker && isLastBroker) ? ' broker-boundary' : '';
                                bodyHtml += `<td class="number-col pnl-section ${bgClass} ${pnl >= 0 ? 'positive' : 'negative'}${boundaryClass}">${formatNumber(pnl)}</td>`;
                            });
                        });

                        // AMI PNL
                        const dayAmiPnl = totalsToUse[month][date]?.amiPnl || 0;
                        bodyHtml += `<td class="number-col total-net-col ${dayAmiPnl >= 0 ? 'positive' : 'negative'}">${formatNumber(dayAmiPnl)}</td>`;

                        bodyHtml += `<td class="number-col total-net-col total-col-border ${dayTotal >= 0 ? 'positive' : 'negative'}">${formatNumber(dayTotal)}</td>`;
                        
                        // NET PNL
                        bodyHtml += `<td class="number-col total-net-col ${dayNetTotal >= 0 ? 'positive' : 'negative'}">${formatNumber(dayNetTotal)}</td>`;
                        
                        // NET PNL % calculation for day rows
                        let dayNetPnlPercent = 0;
                        if (previousMonthTotalMargin !== 0) {
                            dayNetPnlPercent = (dayNetTotal / previousMonthTotalMargin) * 100;
                        }
                        bodyHtml += `<td class="number-col net-pnl-percent-col ${dayNetPnlPercent >= 0 ? 'positive' : 'negative'}">${dayNetPnlPercent !== 0 ? dayNetPnlPercent.toFixed(2) + '%' : ''}</td>`;
                        
                        // Expenses and TOTAL MARGIN (from pre-calculated data)
                        const dayExpense = dailyExpenses[date] || 0;
                        const dayTotalMargin = dailyTotalMargins[date] || 0;
                        bodyHtml += `<td class="number-col expenses-col ${dayExpense >= 0 ? 'positive' : 'negative'}">${formatNumber(dayExpense)}</td>`;
                        bodyHtml += `<td class="number-col total-net-col ${dayTotalMargin >= 0 ? 'positive' : 'negative'}">${dayTotalMargin > 0 ? formatNumber(dayTotalMargin) : ''}</td>`;
                        
                        if (showDrawdown) {
                            const dayDrawdown = (cumulativeData[month] && cumulativeData[month][date]) ? cumulativeData[month][date].drawdown : 0;
                            bodyHtml += `<td class="number-col drawdown-col negative">${formatNumber(dayDrawdown)}</td>`;
                        }
                        bodyHtml += '</tr>';
                    });
                }
            });

            bodyHtml += '<tr class="total-row"><td>Grand Total</td>';
            
            // Output A.PRO PNL totals
            aproStrategies.forEach((strategy, idx) => {
                const stratTotal = totals.strategies[strategy];
                const stratIndex = allStrategies.indexOf(strategy);
                const bgClass = `strategy-bg-${stratIndex % 5}`;
                const boundaryClass = idx === aproStrategies.length - 1 ? ' apro-boundary' : '';
                bodyHtml += `<td class="number-col apro-pnl-col ${bgClass} ${stratTotal.pnl >= 0 ? 'positive' : 'negative'}${boundaryClass}">${formatNumber(stratTotal.pnl)}</td>`;
            });
            
            // Output LOT totals grouped by broker
            if (showLot) {
                sortedBrokers.forEach((brokerCode, brokerIdx) => {
                    brokerGroups[brokerCode].forEach((strategy, idx) => {
                        const stratTotal = totals.strategies[strategy];
                        const lot = stratTotal.lotCount > 0 ? stratTotal.lotSum / stratTotal.lotCount : 0;
                        const stratIndex = allStrategies.indexOf(strategy);
                        const bgClass = `strategy-bg-${stratIndex % 5}`;
                        const isLastInBroker = idx === brokerGroups[brokerCode].length - 1;
                        const isLastBroker = brokerIdx === sortedBrokers.length - 1;
                        const boundaryClass = (isLastInBroker && isLastBroker) ? ' broker-boundary' : '';
                        const displayValue = showTradeCount ? (stratTotal.tradeCount > 0 ? stratTotal.tradeCount : '') : (lot > 0 ? lot.toFixed(2) : '');
                        bodyHtml += `<td class="number-col lot-col ${bgClass}${boundaryClass}">${displayValue}</td>`;
                    });
                });
            }
            
            // Output DPNL totals grouped by broker
            sortedBrokers.forEach((brokerCode, brokerIdx) => {
                brokerGroups[brokerCode].forEach((strategy, idx) => {
                    const stratTotal = totals.strategies[strategy];
                    const stratIndex = allStrategies.indexOf(strategy);
                    const bgClass = `strategy-bg-${stratIndex % 5}`;
                    const isLastInBroker = idx === brokerGroups[brokerCode].length - 1;
                    const isLastBroker = brokerIdx === sortedBrokers.length - 1;
                    const boundaryClass = (isLastInBroker && isLastBroker) ? ' broker-boundary' : '';
                    bodyHtml += `<td class="number-col dpnl-section ${bgClass} ${stratTotal.dpnl >= 0 ? 'positive' : 'negative'}${boundaryClass}">${formatNumber(stratTotal.dpnl)}</td>`;
                });
            });
            
            // Output PNL totals grouped by broker
            sortedBrokers.forEach((brokerCode, brokerIdx) => {
                brokerGroups[brokerCode].forEach((strategy, idx) => {
                    const stratTotal = totals.strategies[strategy];
                    const pnlValue = showPnlTax ? stratTotal.net : stratTotal.pnl;
                    const stratIndex = allStrategies.indexOf(strategy);
                    const bgClass = `strategy-bg-${stratIndex % 5}`;
                    const isLastInBroker = idx === brokerGroups[brokerCode].length - 1;
                    const isLastBroker = brokerIdx === sortedBrokers.length - 1;
                    const boundaryClass = (isLastInBroker && isLastBroker) ? ' broker-boundary' : '';
                    bodyHtml += `<td class="number-col pnl-section ${bgClass} ${pnlValue >= 0 ? 'positive' : 'negative'}${boundaryClass}">${formatNumber(pnlValue)}</td>`;
                });
            });
            
            // AMI PNL total
            bodyHtml += `<td class="number-col total-net-col ${totals.totalAmiPnl >= 0 ? 'positive' : 'negative'}">${formatNumber(totals.totalAmiPnl)}</td>`;
            
            bodyHtml += `<td class="number-col total-net-col total-col-border ${totals.totalProfits >= 0 ? 'positive' : 'negative'}">${formatNumber(totals.totalProfits)}</td>`;
            
            // NET total
            bodyHtml += `<td class="number-col total-net-col ${totals.netBrProfits >= 0 ? 'positive' : 'negative'}">${formatNumber(totals.netBrProfits)}</td>`;
            
            // NET PNL % total
            const totalNetPnlPercent = totals.totalMarginSum !== 0 ? (totals.netBrProfits / totals.totalMarginSum) * 100 : 0;
            bodyHtml += `<td class="number-col net-pnl-percent-col ${totalNetPnlPercent >= 0 ? 'positive' : 'negative'}">${totalNetPnlPercent !== 0 ? totalNetPnlPercent.toFixed(2) + '%' : ''}</td>`;
            
            // Expenses total and TOTAL MARGIN (empty)
            bodyHtml += `<td class="number-col expenses-col ${totals.totalExpenses >= 0 ? 'positive' : 'negative'}">${formatNumber(totals.totalExpenses)}</td>`;
            bodyHtml += `<td class="number-col total-net-col"></td>`;
            
            if (showDrawdown) {
                let maxDrawdown = 0;
                Object.values(cumulativeData).forEach(monthData => {
                    Object.values(monthData).forEach(dayData => {
                        if (dayData.drawdown > maxDrawdown) maxDrawdown = dayData.drawdown;
                    });
                });
                bodyHtml += `<td class="number-col drawdown-col negative">${formatNumber(maxDrawdown)}</td>`;
            }
            bodyHtml += '</tr>';

            elements.tableBody.innerHTML = bodyHtml;
            
            // Store total expenses globally for summary cards
            globalTotalExpenses = totals.totalExpenses;
        }

        function toggleMonth(month) {
            const dayRows = document.querySelectorAll(`.day-row[data-month="${month}"]`);
            const icon = document.getElementById(`icon-${month}`);
            dayRows.forEach(row => row.classList.toggle('expanded'));
            if (icon) icon.classList.toggle('expanded');
        }

        function expandAll() {
            document.querySelectorAll('.day-row').forEach(row => row.classList.add('expanded'));
            document.querySelectorAll('.expand-icon').forEach(icon => icon.classList.add('expanded'));
        }

        function collapseAll() {
            document.querySelectorAll('.day-row').forEach(row => row.classList.remove('expanded'));
            document.querySelectorAll('.expand-icon').forEach(icon => icon.classList.remove('expanded'));
        }

        function updateSummaryCards(trades) {
            const allMonthlyProfits = {};
            const allMonthlyNetProfits = {};
            let runningCumTotal = 0;
            let peakCumTotal = 0;
            let currentDrawdown = 0;
            const strategyTracking = {};
            
            const sortedAllTrades = [...allTrades].sort((a, b) => {
                const dateA = a.date.split('/').reverse().join('');
                const dateB = b.date.split('/').reverse().join('');
                return dateA.localeCompare(dateB);
            });
            
            // Calculate starting capital from first date of FIRST MONTH only
            globalStartingCapital = 0;
            if (sortedAllTrades.length > 0) {
                // Group trades by month
                const tradesByMonth = {};
                sortedAllTrades.forEach(trade => {
                    const monthKey = trade.date.split('/')[1];
                    if (!tradesByMonth[monthKey]) {
                        tradesByMonth[monthKey] = [];
                    }
                    tradesByMonth[monthKey].push(trade);
                });
                
                const sortedMonths = Object.keys(tradesByMonth).sort();
                if (sortedMonths.length > 0) {
                    const firstMonth = sortedMonths[0];
                    const firstMonthTrades = tradesByMonth[firstMonth];
                    
                    // Get first date in first month
                    const tradesByDate = {};
                    firstMonthTrades.forEach(trade => {
                        const dateKey = trade.date;
                        if (!tradesByDate[dateKey]) {
                            tradesByDate[dateKey] = [];
                        }
                        tradesByDate[dateKey].push(trade);
                    });
                    
                    const sortedDatesInMonth = Object.keys(tradesByDate).sort((a, b) => {
                        const dayA = parseInt(a.split('/')[0]);
                        const dayB = parseInt(b.split('/')[0]);
                        return dayA - dayB;
                    });
                    
                    if (sortedDatesInMonth.length > 0) {
                        const firstDate = sortedDatesInMonth[0];
                        const firstDateTrades = tradesByDate[firstDate];
                        
                        const firstDateBrokerMargins = {};
                        const allBrokerStrategies = allStrategies.filter(s => !s.startsWith('A.PRO'));
                        
                        firstDateTrades.forEach(trade => {
                            if (trade.strategyDetails) {
                                allBrokerStrategies.forEach(brokerStrat => {
                                    const margin = trade.strategyDetails[brokerStrat]?.margin || 0;
                                    const brokerMatch = brokerStrat.match(/^(B\d+)/);
                                    if (brokerMatch && margin > 0) {
                                        const brokerCode = brokerMatch[1];
                                        if (!firstDateBrokerMargins[brokerCode]) {
                                            firstDateBrokerMargins[brokerCode] = {};
                                        }
                                        firstDateBrokerMargins[brokerCode][brokerStrat] = margin;
                                    }
                                });
                            }
                        });
                        
                        Object.keys(firstDateBrokerMargins).forEach(brokerCode => {
                            const margins = Object.values(firstDateBrokerMargins[brokerCode]);
                            if (margins.length > 0) {
                                globalStartingCapital += Math.max(...margins);
                            }
                        });
                    }
                }
            }
            
            sortedAllTrades.forEach(trade => {
                const monthKey = trade.date.split('/')[1];
                if (!allMonthlyProfits[monthKey]) allMonthlyProfits[monthKey] = 0;
                if (!allMonthlyNetProfits[monthKey]) allMonthlyNetProfits[monthKey] = 0;
                
                Object.entries(trade.strategyDetails).forEach(([stratName, details]) => {
                    if (!stratName.startsWith('A.PRO')) {
                        const netPnl = trade.strategyPnlTax[stratName] || 0;
                        allMonthlyProfits[monthKey] += (trade.strategyPnls[stratName] || 0);
                        allMonthlyNetProfits[monthKey] += netPnl;
                        
                        runningCumTotal += netPnl;
                        if (runningCumTotal > peakCumTotal) peakCumTotal = runningCumTotal;
                        
                        if (!strategyTracking[stratName]) {
                            strategyTracking[stratName] = { cumTotal: 0, peak: 0, drawdown: 0 };
                        }
                        strategyTracking[stratName].cumTotal += netPnl;
                        if (strategyTracking[stratName].cumTotal > strategyTracking[stratName].peak) {
                            strategyTracking[stratName].peak = strategyTracking[stratName].cumTotal;
                        }
                        strategyTracking[stratName].drawdown = strategyTracking[stratName].peak - strategyTracking[stratName].cumTotal;
                    }
                });
            });
            
            currentDrawdown = peakCumTotal - runningCumTotal;

            const totalProfitAll = Object.values(allMonthlyProfits).reduce((sum, val) => sum + val, 0);
            const netBrProfitAll = Object.values(allMonthlyNetProfits).reduce((sum, val) => sum + val, 0);

            // Update Starting Capital
            if (elements.startingCapital) {
                elements.startingCapital.textContent = globalStartingCapital > 0 ? '₹' + globalStartingCapital.toLocaleString('en-IN', {maximumFractionDigits: 0}) : '-';
                elements.startingCapital.className = 'summary-card-value';
            }

            // Update Running Profit as PERCENTAGE
            if (elements.runningProfit) {
                if (globalStartingCapital > 0 && netBrProfitAll !== 0) {
                    const profitPercent = (netBrProfitAll / globalStartingCapital) * 100;
                    elements.runningProfit.textContent = profitPercent.toFixed(2) + '%';
                    elements.runningProfit.className = `summary-card-value ${profitPercent >= 0 ? 'positive' : 'negative'}`;
                } else {
                    elements.runningProfit.textContent = '-';
                    elements.runningProfit.className = 'summary-card-value';
                }
            }

            // Update Net Broker Profit without percentage
            elements.netBrProfit.textContent = `₹${netBrProfitAll >= 0 ? '' : '-'}${Math.abs(netBrProfitAll).toLocaleString('en-IN', {maximumFractionDigits: 0})}`;
            elements.netBrProfit.className = `summary-card-value ${netBrProfitAll >= 0 ? 'positive' : 'negative'}`;


            const chargesAll = totalProfitAll - netBrProfitAll;
            elements.charges.textContent = `₹-${Math.abs(chargesAll).toLocaleString('en-IN', {maximumFractionDigits: 0})}`;

            // Update Running Margin stat - use the last month's total margin
            if (elements.runningMargin) {
                if (globalLastTotalMargin > 0) {
                    elements.runningMargin.textContent = `₹${globalLastTotalMargin.toLocaleString('en-IN', {maximumFractionDigits: 0})}`;
                    elements.runningMargin.className = 'summary-card-value ' + (globalLastTotalMargin >= 0 ? 'positive' : 'negative');
                } else {
                    elements.runningMargin.textContent = '-';
                    elements.runningMargin.className = 'summary-card-value';
                }
            }
            
            // Update Total Expense stat - use accumulated expenses from table
            if (elements.totalExpense) {
                elements.totalExpense.textContent = `₹${globalTotalExpenses >= 0 ? '' : '-'}${Math.abs(globalTotalExpenses).toLocaleString('en-IN', {maximumFractionDigits: 0})}`;
                elements.totalExpense.className = 'summary-card-value ' + (globalTotalExpenses >= 0 ? 'positive' : 'negative');
            }
            
            // Update Total Net Profit stat (Net Broker Profit + Total Expense)
            const netProfitValue = netBrProfitAll + globalTotalExpenses;
            if (elements.netProfit) {
                elements.netProfit.textContent = `₹${netProfitValue >= 0 ? '' : '-'}${Math.abs(netProfitValue).toLocaleString('en-IN', {maximumFractionDigits: 0})}`;
                elements.netProfit.className = 'summary-card-value ' + (netProfitValue >= 0 ? 'positive' : 'negative');
            }
        }

        function refreshData() {
            if (window.parent !== window) {
                window.parent.postMessage({ type: 'REQUEST_DATA_REFRESH' }, '*');
            }
            processAndDisplayData();
        }
    </script>
</body>
</html>
