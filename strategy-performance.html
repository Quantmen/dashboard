<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate"><meta http-equiv="Pragma" content="no-cache"><meta http-equiv="Expires" content="0"><title>Strategy Performance</title><link rel="preconnect" href="https://fonts.googleapis.com"><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin><link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet"><style>
*{margin:0;padding:0;box-sizing:border-box;}html, body{width:100%;height:100%;overflow:hidden;}body{font-family:'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;background:#f8fafc;color:#1e293b;}.main-content{overflow-y:auto;overflow-x:auto;padding:16px 16px 32px 32px;background:#f8fafc;height:100vh;width:100%;}.page-header{margin-bottom:16px;max-width:calc(100vw - 48px);position:sticky;left:0;background:#f8fafc;z-index:100;padding-right:16px;margin-right:-16px;}.page-title{font-size:20px;font-weight:700;color:#111827;margin-bottom:4px;letter-spacing:-0.5px;}.page-subtitle{font-size:12px;color:#6b7280;font-weight:400;}
.controls-section{display:flex;gap:8px;margin-bottom:20px;flex-wrap:wrap;align-items:center;justify-content:space-between;max-width:calc(100vw - 48px);position:sticky;left:0;background:#f8fafc;z-index:1000;padding-right:16px;margin-right:-16px;}.controls-section > *{flex:1 1 auto;min-width:0;}.control-group{display:flex;align-items:center;gap:8px;}.control-label{font-size:12px;color:#374151;font-weight:600;}.strategy-filter-container{position:relative;flex:1 1 auto;min-width:0;z-index:10000;}.strategy-filter-button{display:flex;align-items:center;justify-content:center;gap:8px;padding:7px 12px;border:1px solid #d1d5db;border-radius:8px;font-size:11px;font-weight:500;background:white;color:#374151;cursor:pointer;transition:all 0.15s ease;width:100%;white-space:nowrap;}
.strategy-filter-button:hover{border-color:#9ca3af;background:#f9fafb;}.strategy-filter-dropdown{position:absolute;top:100%;left:0;margin-top:6px;background:white;border:1px solid #d1d5db;border-radius:10px;box-shadow:0 10px 15px rgba(0,0,0,0.1), 0 4px 6px rgba(0,0,0,0.05);min-width:180px;max-height:400px;overflow-y:auto;z-index:99999;display:none;}.strategy-filter-dropdown.active{display:block;}#monthFilterDropdown{min-width:160px;max-width:160px;max-height:500px;}#monthFilterDropdown .strategy-filter-label{font-size:12px;}
#monthFilterDropdown .strategy-filter-item{padding:6px 14px;}.strategy-filter-header{padding:10px 12px;border-bottom:1px solid #e2e8f0;display:flex;justify-content:space-between;align-items:center;}.strategy-filter-title{font-size:13px;font-weight:600;color:#1e293b;}.strategy-filter-actions{display:flex;gap:4px;}.filter-action-btn{font-size:11px;color:#1e40af;cursor:pointer;padding:4px 6px;border-radius:4px;transition:background 0.2s ease;}.filter-action-btn:hover{background:#eff6ff;}.filter-action-btn[style*="color:#dc2626"]:hover{background:#fee2e2;}
.strategy-filter-list{padding:8px 0;}.strategy-filter-item{display:flex;align-items:center;padding:8px 14px;cursor:pointer;transition:background 0.2s ease;}.strategy-filter-item:hover{background:#f8fafc;}.strategy-filter-checkbox{margin-right:10px;width:16px;height:16px;cursor:pointer;}.strategy-filter-label{font-size:13px;color:#475569;cursor:pointer;user-select:none;}.filter-badge{display:inline-block;background:#1e40af;color:white;font-size:9px;padding:2px 5px;border-radius:10px;margin-left:6px;font-weight:600;}
select, button{padding:7px 12px;border:1px solid #d1d5db;border-radius:8px;font-size:11px;font-weight:500;background:white;color:#374151;cursor:pointer;transition:all 0.15s ease;font-family:inherit;white-space:nowrap;text-align:center;flex:1 1 auto;min-width:0;}select:hover, button:hover{border-color:#9ca3af;background:#f9fafb;}select:focus, button:focus{outline:none;border-color:#3b82f6;box-shadow:0 0 0 3px rgba(59, 130, 246, 0.1);}button.primary{background:#3b82f6;color:white;border-color:#3b82f6;}
button.primary:hover{background:#2563eb;border-color:#2563eb;}button.active{background:white;color:#3b82f6;border:1px solid #3b82f6;}.custom-date-range{display:flex;gap:4px;align-items:center;padding:4px 8px;background:transparent;border-radius:6px;}.custom-date-range label{font-size:10px;font-weight:600;color:#64748b;text-transform:uppercase;letter-spacing:0.5px;}.custom-date-range input[type="date"]{padding:4px 6px;font-size:10px;border:1px solid #e5e7eb;border-radius:4px;font-family:inherit;color:#475569;cursor:pointer;background:transparent;}.custom-date-range input[type="date"]:focus{outline:none;border-color:#3b82f6;box-shadow:0 0 0 3px rgba(59,130,246,0.1);}.date-range-buttons{display:flex;gap:4px;}.date-range-buttons .btn{padding:6px 12px;font-size:10px;font-weight:600;color:#64748b;background:transparent;border:none;border-radius:6px;cursor:pointer;transition:all 0.2s ease;text-transform:uppercase;letter-spacing:0.5px;}.date-range-buttons .btn:hover{background:#e2e8f0;color:#475569;}.date-range-buttons .btn.active{background:white;color:#3b82f6;border:1px solid #3b82f6;}.table-container{background:white;border-radius:12px;box-shadow:0 1px 3px rgba(0,0,0,0.08), 0 1px 2px rgba(0,0,0,0.06);border:1px solid #e5e7eb;overflow:visible;margin-bottom:16px;position:relative;}.table-wrapper{overflow-x:visible;overflow-y:visible;background:white;border-radius:0;}.performance-table{width:100%;border-collapse:separate;border-spacing:0;font-size:12px;min-width:800px;font-family:'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;font-variant-numeric:tabular-nums;position:relative;isolation:isolate;}
.performance-table thead{position:sticky;top:0;z-index:1000;background:white;isolation:isolate;transform:translateZ(0);}.performance-table thead::after{content:'';position:absolute;top:-1000px;left:0;right:0;height:1000px;background:#f8fafc;z-index:999;pointer-events:none;}.performance-table thead::before{content:'';position:absolute;top:0;left:0;right:0;bottom:0;background:white;z-index:-1;}.performance-table thead tr{height:0;border-spacing:0;border-collapse:collapse;}.performance-table thead tr.header-row-1, .performance-table thead tr.header-row-2{height:auto;}.performance-table thead tr.header-row-1 th{padding:12px 8px 6px 8px;position:sticky;top:0;background:#f3f4f6;z-index:1000;font-size:10px;text-align:center;font-weight:700;color:#1f2937;border-bottom:1px solid #d1d5db;border-right:1px solid #e5e7eb;white-space:nowrap;text-transform:uppercase;letter-spacing:0.5px;line-height:1.2;vertical-align:middle;height:32px;contain:paint;}
.performance-table thead tr.header-row-1 th[rowspan="2"]{border-bottom:2px solid #d1d5db;text-align:center;background:#f3f4f6;padding:12px 8px;height:auto;vertical-align:middle;contain:paint;}.performance-table thead tr.header-row-2 th{padding:9px 8px;font-size:9px;position:sticky;top:32px;background:#f3f4f6;z-index:1000;font-weight:600;color:#374151;text-align:center !important;border-bottom:2px solid #d1d5db;border-right:1px solid #e5e7eb;white-space:nowrap;text-transform:uppercase;line-height:1.2;vertical-align:middle;height:32px;contain:paint;}
.performance-table thead tr.header-row-1 th:first-child{position:sticky;left:0;z-index:2000;background:#f9fafb !important;width:110px;min-width:110px;max-width:110px;border-right:2px solid #cbd5e1;padding:12px 8px;vertical-align:middle;text-align:center;}.performance-table tbody{position:relative;z-index:1;}.performance-table th{background:#f3f4f6;padding:12px 8px;text-align:center;font-weight:700;color:#6b7280;border-bottom:2px solid #d1d5db;border-right:1px solid #e5e7eb;white-space:nowrap;text-transform:uppercase;font-size:10px;letter-spacing:0.5px;min-width:75px;max-width:90px;vertical-align:middle;}
.performance-table th.strategy-group-end{border-right:1px solid #cbd5e1;}.performance-table td.strategy-group-end{border-right:1px solid #cbd5e1;}.performance-table th.apro-boundary{border-right:1px solid #cbd5e1 !important;}.performance-table td.apro-boundary{border-right:1px solid #cbd5e1 !important;}.performance-table th.broker-boundary{border-right:1px solid #cbd5e1 !important;}.performance-table td.broker-boundary{border-right:1px solid #cbd5e1 !important;}.performance-table th.strategy-bg-0, .performance-table td.strategy-bg-0, .performance-table th.strategy-bg-1, .performance-table td.strategy-bg-1, .performance-table th.strategy-bg-2, .performance-table td.strategy-bg-2{background:#f8fcf9;}
.performance-table th.strategy-bg-3, .performance-table td.strategy-bg-3{background:#fefafd;}.performance-table th.strategy-bg-4, .performance-table td.strategy-bg-4{background:#fffaf5;}.performance-table td.lot-col.strategy-bg-0, .performance-table td.lot-col.strategy-bg-1, .performance-table td.lot-col.strategy-bg-2, .performance-table td.lot-col.strategy-bg-3, .performance-table td.lot-col.strategy-bg-4{width:65px;min-width:65px;max-width:65px;background:#eff8fe !important;}.performance-table tr:hover td.strategy-bg-0, .performance-table tr:hover td.strategy-bg-1, .performance-table tr:hover td.strategy-bg-2, .performance-table tr:hover td.strategy-bg-3, .performance-table tr:hover td.strategy-bg-4{background:#fafbfc;}
.performance-table tr:hover td.lot-col.strategy-bg-0, .performance-table tr:hover td.lot-col.strategy-bg-1, .performance-table tr:hover td.lot-col.strategy-bg-2, .performance-table tr:hover td.lot-col.strategy-bg-3, .performance-table tr:hover td.lot-col.strategy-bg-4{background:#fafbfc;width:65px;min-width:65px;max-width:65px;}.performance-table tr:hover td.apro-pnl-col{background:#fafbfc;width:85px;min-width:75px;}.performance-table tr:hover td.apro-pnl-col.strategy-bg-0, .performance-table tr:hover td.apro-pnl-col.strategy-bg-1, .performance-table tr:hover td.apro-pnl-col.strategy-bg-2, .performance-table tr:hover td.apro-pnl-col.strategy-bg-3, .performance-table tr:hover td.apro-pnl-col.strategy-bg-4{background:#fafbfc;width:85px;min-width:75px;}
.performance-table th:first-child{position:sticky;left:0;z-index:10;background:#f8fafc !important;width:110px;min-width:110px;max-width:110px;border-right:2px solid #cbd5e1;vertical-align:middle;text-align:center;}.performance-table th.number-col{text-align:center;max-width:80px;}.performance-table th.apro-pnl-col, .performance-table td.apro-pnl-col{min-width:75px;width:85px;}.performance-table td.apro-pnl-col.strategy-bg-0, .performance-table td.apro-pnl-col.strategy-bg-1, .performance-table td.apro-pnl-col.strategy-bg-2, .performance-table td.apro-pnl-col.strategy-bg-3, .performance-table td.apro-pnl-col.strategy-bg-4{background:#f8fcf9;width:85px;min-width:75px;}
/* Section-based color overrides */ .performance-table td.dpnl-section{background:#fefafd !important;}.performance-table td.pnl-section{background:#fffaf5 !important;}.performance-table td{padding:11px 8px;border-bottom:1px solid #f3f4f6;border-right:1px solid #f3f4f6;color:#374151;text-align:right;white-space:nowrap;min-width:75px;max-width:90px;overflow:hidden;text-overflow:ellipsis;font-size:12px;font-weight:400;}.performance-table td.lot-col{min-width:65px;max-width:65px;width:65px;}.performance-table th.lot-col{min-width:65px;max-width:65px;width:65px;}
.performance-table td:first-child{position:sticky;left:0;background:white !important;font-weight:450;z-index:1;border-right:2px solid #cbd5e1;width:110px;min-width:110px;max-width:110px;padding:11px 8px;text-align:left;color:#111827;}.performance-table td.number-col{text-align:right;font-weight:400;font-size:12px;min-width:75px;max-width:90px;padding:11px 8px;font-variant-numeric:tabular-nums;}.performance-table th.number-col{text-align:center;max-width:90px;}.performance-table td.number-col.total-net-col{min-width:80px;max-width:none;font-weight:450;background:#fefce8 !important;}
.performance-table tbody tr.month-row td.number-col.total-net-col, .performance-table tbody tr.total-row td.number-col.total-net-col{background:#fef9c3 !important;}.performance-table th.total-net-col{min-width:80px;max-width:none;}.performance-table th.total-col-border, .performance-table td.total-col-border{border-right:1px solid #cbd5e1 !important;}.performance-table td.number-col.net-pnl-percent-col{min-width:60px;max-width:60px;font-weight:450;background:#fefce8 !important;font-size:12px;}.performance-table tbody tr.month-row td.number-col.net-pnl-percent-col, .performance-table tbody tr.total-row td.number-col.net-pnl-percent-col{background:#fef9c3 !important;}
.performance-table th.net-pnl-percent-col{min-width:60px;max-width:80px;}.performance-table td.number-col.drawdown-col{min-width:90px;max-width:none;background:#fef2f2 !important;}.performance-table tbody tr.month-row td.number-col.drawdown-col{background:#feecec !important;}.performance-table tbody tr.year-row td.number-col.drawdown-col{background:#fee5e5 !important;}.performance-table tbody tr.total-row td.number-col.drawdown-col{background:#fee2e2 !important;}.performance-table th.drawdown-col{min-width:90px;max-width:none;}.performance-table td.number-col.expenses-col{font-weight:450;background:#fef2f2;border-left:1px solid #cbd5e1;}
.performance-table tbody tr.month-row td.number-col.expenses-col, .performance-table tbody tr.total-row td.number-col.expenses-col{background:#feecec !important;}.performance-table th.expenses-col{min-width:80px;max-width:none;}.performance-table td.positive{color:#059669;}.performance-table td.negative{color:#b96060;}.performance-table tr:hover{background:#fafbfc;}.performance-table tr:hover td:first-child{background:#fafbfc !important;min-width:110px;max-width:110px;border-right:2px solid #cbd5e1;}.performance-table tbody tr.total-row{background:#f9fafb;font-weight:700;border-top:2px solid #d1d5db;transform:translateZ(0);position:relative;z-index:1;}
.performance-table tbody tr.total-row:hover{background:#f3f4f6;}.performance-table tbody tr.total-row td{border-top:2px solid #d1d5db;padding:14px 8px;font-weight:450;font-size:12px;}.performance-table tbody tr.total-row td:first-child{background:#f9fafb !important;min-width:110px;max-width:110px;border-right:2px solid #cbd5e1;}.performance-table tbody tr.total-row:hover td:first-child{background:#f3f4f6 !important;min-width:110px;max-width:110px;border-right:2px solid #cbd5e1;}.performance-table tbody tr.total-row:hover td.strategy-bg-0, .performance-table tbody tr.total-row:hover td.strategy-bg-1, .performance-table tbody tr.total-row:hover td.strategy-bg-2{background:#ecf7f1;}
.performance-table tbody tr.total-row:hover td.strategy-bg-3{background:#fef0f6;}.performance-table tbody tr.total-row:hover td.strategy-bg-4{background:#fff1e1;}.performance-table tbody tr.total-row:hover td.lot-col{width:65px;min-width:65px;max-width:65px;background:#dff0fc !important;}.performance-table tbody tr.total-row:hover td.dpnl-section{background:#fef0f6 !important;}.performance-table tbody tr.total-row:hover td.pnl-section{background:#fff1e1 !important;}.performance-table tbody tr.total-row:hover td.apro-pnl-col{width:85px;min-width:75px;}
.performance-table tbody tr.total-row:hover td.apro-pnl-col.strategy-bg-0, .performance-table tbody tr.total-row:hover td.apro-pnl-col.strategy-bg-1, .performance-table tbody tr.total-row:hover td.apro-pnl-col.strategy-bg-2, .performance-table tbody tr.total-row:hover td.apro-pnl-col.strategy-bg-3, .performance-table tbody tr.total-row:hover td.apro-pnl-col.strategy-bg-4{background:#ecf7f1;}.performance-table tbody tr.total-row td.apro-pnl-col{width:85px;min-width:75px;}.performance-table tbody tr.month-row{background:#f9fafb;font-weight:450 !important;cursor:pointer;user-select:none;border-left:3px solid transparent;transition:all 0.15s ease;}
.performance-table tbody tr.month-row:hover{background:#f3f4f6;border-left-color:#3b82f6;}.performance-table tbody tr.month-row td{font-weight:450 !important;font-size:12px !important;}.performance-table tbody tr.month-row td:first-child{background:#f9fafb !important;color:#111827;min-width:110px;max-width:110px;font-weight:450 !important;font-size:12px !important;border-right:2px solid #cbd5e1;padding-left:20px;}.performance-table tbody tr.month-row:hover td:first-child{background:#f3f4f6 !important;min-width:110px;max-width:110px;border-right:2px solid #cbd5e1;padding-left:20px;}
.performance-table tbody tr.month-row:hover td.strategy-bg-0, .performance-table tbody tr.month-row:hover td.strategy-bg-1, .performance-table tbody tr.month-row:hover td.strategy-bg-2{background:#e3f3ea;}.performance-table tbody tr.month-row:hover td.strategy-bg-3{background:#fde9f3;}.performance-table tbody tr.month-row:hover td.strategy-bg-4{background:#ffecd6;}.performance-table tbody tr.month-row:hover td.lot-col{width:65px;min-width:65px;max-width:65px;background:#d5ebfa !important;}.performance-table tbody tr.month-row:hover td.dpnl-section{background:#fde9f3 !important;}
.performance-table tbody tr.month-row:hover td.pnl-section{background:#ffecd6 !important;}.performance-table tbody tr.month-row:hover td.apro-pnl-col{width:85px;min-width:75px;}.performance-table tbody tr.month-row:hover td.apro-pnl-col.strategy-bg-0, .performance-table tbody tr.month-row:hover td.apro-pnl-col.strategy-bg-1, .performance-table tbody tr.month-row:hover td.apro-pnl-col.strategy-bg-2, .performance-table tbody tr.month-row:hover td.apro-pnl-col.strategy-bg-3, .performance-table tbody tr.month-row:hover td.apro-pnl-col.strategy-bg-4{background:#e3f3ea;}
.performance-table tbody tr.month-row td.strategy-bg-0, .performance-table tbody tr.month-row td.strategy-bg-1, .performance-table tbody tr.month-row td.strategy-bg-2{background:#f0f9f3;}.performance-table tbody tr.month-row td.strategy-bg-3{background:#fef2f8;}.performance-table tbody tr.month-row td.strategy-bg-4{background:#fff3e8;}.performance-table tbody tr.month-row td.lot-col{background:#e8f4fc !important;}.performance-table tbody tr.month-row td.dpnl-section{background:#fef2f8 !important;}
.performance-table tbody tr.month-row td.pnl-section{background:#fff3e8 !important;}.performance-table tbody tr.month-row td.apro-pnl-col.strategy-bg-0, .performance-table tbody tr.month-row td.apro-pnl-col.strategy-bg-1, .performance-table tbody tr.month-row td.apro-pnl-col.strategy-bg-2, .performance-table tbody tr.month-row td.apro-pnl-col.strategy-bg-3, .performance-table tbody tr.month-row td.apro-pnl-col.strategy-bg-4{background:#f0f9f3;width:85px;min-width:75px;}
.performance-table tbody tr.year-row td.strategy-bg-0, .performance-table tbody tr.year-row td.strategy-bg-1, .performance-table tbody tr.year-row td.strategy-bg-2{background:#e9f5ee;}.performance-table tbody tr.year-row td.strategy-bg-3{background:#fbeaf4;}.performance-table tbody tr.year-row td.strategy-bg-4{background:#ffedd9;}.performance-table tbody tr.year-row td.lot-col{background:#dfeef9 !important;}.performance-table tbody tr.year-row td.dpnl-section{background:#fbeaf4 !important;}
.performance-table tbody tr.year-row td.pnl-section{background:#ffedd9 !important;}.performance-table tbody tr.year-row td.apro-pnl-col.strategy-bg-0, .performance-table tbody tr.year-row td.apro-pnl-col.strategy-bg-1, .performance-table tbody tr.year-row td.apro-pnl-col.strategy-bg-2, .performance-table tbody tr.year-row td.apro-pnl-col.strategy-bg-3, .performance-table tbody tr.year-row td.apro-pnl-col.strategy-bg-4{background:#e9f5ee;width:85px;min-width:75px;}
.performance-table tbody tr.year-row td.number-col.total-net-col{background:#fef5cd !important;}.performance-table tbody tr.year-row td.number-col.net-pnl-percent-col{background:#fef5cd !important;}.performance-table tbody tr.year-row td.number-col.expenses-col{background:#fee5e5 !important;}
.performance-table tbody tr.month-row[data-year]:not(.expanded){display:none;}
.performance-table tbody tr.month-row[data-year].expanded{display:table-row;}
.performance-table tbody tr.year-row{background:#f1f3f5 !important;font-weight:650;cursor:pointer;user-select:none;border-left:3px solid transparent;transition:all 0.15s ease;}.performance-table tbody tr.year-row:hover{background:#e5e7eb !important;border-left-color:#3b82f6;}.performance-table tbody tr.year-row td{font-size:12px;font-weight:650;padding:12px 8px;}.performance-table tbody tr.year-row td:first-child{font-weight:700;color:#111827;background:#f1f3f5 !important;}.performance-table tbody tr.year-row:hover td:first-child{background:#e5e7eb !important;}
.performance-table tbody tr.day-row{display:none;}
.performance-table tbody tr.day-row[data-year]:not(.expanded){display:none;}
.performance-table tbody tr.day-row.expanded{display:table-row;}.performance-table tbody tr.day-row td{padding:7px 8px;font-size:12px;}.performance-table tbody tr.day-row td:first-child{padding-left:40px;padding-top:7px;padding-bottom:7px;font-weight:450;color:#6b7280;min-width:110px;max-width:110px;font-size:12px;border-right:2px solid #cbd5e1;background:white !important;}.performance-table tbody tr.day-row td.apro-pnl-col{width:85px;min-width:75px;}.expand-icon{display:inline-block;width:18px;height:18px;margin-right:10px;text-align:center;font-weight:600;color:#6b7280;transition:transform 0.2s ease;font-size:12px;line-height:18px;}
.expand-icon.expanded{transform:rotate(90deg);}.no-data{text-align:center;color:#cbd5e1;padding:40px;font-size:14px;}.main-content::before{content:'';position:fixed;left:0;top:0;width:32px;height:100vh;background:#f8fafc;z-index:30;pointer-events:none;}.summary-cards{display:flex;gap:12px;margin-bottom:16px;flex-wrap:wrap;align-items:stretch;max-width:calc(100vw - 48px);position:sticky;left:0;background:#f8fafc;z-index:100;padding-right:16px;margin-right:-16px;}.summary-card{background:white;border-radius:8px;padding:10px 12px;box-shadow:0 1px 3px rgba(0,0,0,0.08), 0 1px 2px rgba(0,0,0,0.06);border:1px solid #e5e7eb;flex:1 1 0;min-width:140px;}.summary-card-title{font-size:10px;color:#6b7280;text-transform:uppercase;letter-spacing:0.5px;margin-bottom:5px;font-weight:700;}
.summary-card-value{font-size:18px;font-weight:700;line-height:1.2;font-variant-numeric:tabular-nums;}.summary-card-value.positive{color:#059669;}.summary-card-value.negative{color:#b96060;}.summary-card.net-profit-box{background:#f0fdf4;}.summary-card.total-expense-box{background:#fdf2f8;}.summary-card.running-margin-box{background:#fffbeb;}

/* Mobile Safari Critical Fix */
@supports (-webkit-touch-callout: none) {
  /* Safari-only styles */
  .performance-table {
    isolation: auto !important;
  }
  .performance-table thead {
    transform: none !important;
    -webkit-transform: none !important;
  }
  .performance-table thead::after {
    display: none !important;
  }
}

@media screen and (max-width: 1024px) {
  html, body {
    overflow-x: auto !important;
    overflow-y: auto !important;
    height: auto !important;
    width: 100%;
  }
  
  .main-content {
    overflow: visible !important;
    height: auto !important;
    min-height: 100vh;
    padding: 16px;
    width: max-content;
    min-width: 100%;
  }
  
  .main-content::before {
    display: none !important;
  }
  
  .page-header {
    position: relative !important;
    max-width: none !important;
  }
  
  .summary-cards {
    position: relative !important;
    max-width: none !important;
    flex-wrap: nowrap;
    overflow-x: auto;
  }
  
  .controls-section {
    position: relative !important;
    max-width: none !important;
    z-index: 99999 !important;
  }
  
  /* Fix dropdowns to appear in front */
  .strategy-filter-container {
    position: relative !important;
    z-index: 99999 !important;
  }
  
  .strategy-filter-dropdown {
    position: absolute !important;
    z-index: 999999 !important;
  }
  
  .strategy-filter-dropdown.active {
    display: block !important;
    z-index: 999999 !important;
  }
  
  .table-container {
    overflow: visible !important;
    width: auto !important;
    z-index: 1 !important;
  }
  
  .table-wrapper {
    overflow: visible !important;
    width: auto !important;
  }
  
  .performance-table {
    isolation: auto !important;
    min-width: 800px;
  }
  
  .performance-table thead {
    position: relative !important;
    transform: none !important;
    -webkit-transform: none !important;
    isolation: auto !important;
  }
  
  .performance-table thead::after,
  .performance-table thead::before {
    display: none !important;
    content: none !important;
    height: 0 !important;
  }
  
  .performance-table thead tr.header-row-1 th,
  .performance-table thead tr.header-row-2 th,
  .performance-table th:first-child,
  .performance-table td:first-child {
    position: relative !important;
    top: auto !important;
    left: auto !important;
    contain: none !important;
  }
  
  .performance-table tbody {
    display: table-row-group !important;
    visibility: visible !important;
    opacity: 1 !important;
  }
  
  .performance-table tbody tr {
    display: table-row !important;
    visibility: visible !important;
    height: auto !important;
  }
  
  .performance-table tbody tr.year-row,
  .performance-table tbody tr.total-row {
    display: table-row !important;
    transform: none !important;
  }
  
  /* Fix expand/collapse - month rows hidden by default, shown when expanded */
  .performance-table tbody tr.month-row[data-year] {
    display: none !important;
  }
  
  .performance-table tbody tr.month-row[data-year].expanded {
    display: table-row !important;
  }
  
  .performance-table tbody tr.day-row {
    display: none !important;
  }
  
  .performance-table tbody tr.day-row.expanded {
    display: table-row !important;
  }
  
  .performance-table tbody td {
    display: table-cell !important;
    visibility: visible !important;
  }
}

/* Tablet Layout - Dynamic columns based on card count */
</style></head><body><div class="main-content"><div class="page-header" style="display: flex; justify-content: space-between; align-items: flex-start;"><div><h1 class="page-title">Strategy Performance</h1><p class="page-subtitle">Detailed profit and loss analysis by strategy and time period</p></div><div style="display: flex; gap: 3px; align-items: center; padding: 5px 6px; background: #f1f5f9; border-radius: 8px; white-space: nowrap;"><div class="custom-date-range" style="padding: 0px 2px;"><label style="font-size: 10px;">FROM:</label><input type="date" id="fromDate" style="width: 95px; padding: 5px 4px; font-size: 10px;"></div><div class="custom-date-range" style="padding: 0px 2px;"><label style="font-size: 10px;">TO:</label><input type="date" id="toDate" style="width: 95px; padding: 5px 4px; font-size: 10px;"></div><div class="date-range-buttons" style="gap: 2px;"><button class="btn" onclick="setDateRange('3M')" style="padding: 5px 8px; font-size: 10px;">LAST 3M</button><button class="btn" onclick="setDateRange('YTD')" style="padding: 5px 8px; font-size: 10px;">YTD</button><button class="btn active" onclick="setDateRange('ALL')" style="padding: 5px 8px; font-size: 10px;">ALL TIME</button></div></div></div><div class="summary-cards" id="summaryCards"><div class="summary-card running-margin-box"><div class="summary-card-title">Running Margin</div><div class="summary-card-value" id="runningMargin">-</div></div><div class="summary-card"><div class="summary-card-title">Starting Capital</div><div class="summary-card-value" id="startingCapital">₹0</div></div><div class="summary-card"><div class="summary-card-title">Net Broker Profit</div><div class="summary-card-value" id="netBrProfit">₹0</div></div><div class="summary-card"><div class="summary-card-title">Net Broker Profit(%)</div><div class="summary-card-value" id="runningProfit">0%</div></div><div class="summary-card"><div class="summary-card-title">BROKER CHARGES</div><div class="summary-card-value negative" id="charges">₹0</div></div><div class="summary-card total-expense-box"><div class="summary-card-title">Total Expense/Withdrawn</div><div class="summary-card-value" id="totalExpense">-</div></div><div class="summary-card net-profit-box"><div class="summary-card-title">Total Margin Addition</div><div class="summary-card-value" id="netProfit">-</div></div></div><div class="controls-section"><div class="strategy-filter-container"><button class="strategy-filter-button" onclick="toggleMonthFilter()"><span>Select Months</span><span class="filter-badge" id="monthFilterBadge" style="display: none;">0</span><span>▼</span></button><div class="strategy-filter-dropdown" id="monthFilterDropdown"><div class="strategy-filter-header"><span class="strategy-filter-title">Months</span><div class="strategy-filter-actions"><span class="filter-action-btn" onclick="selectAllMonths()">All</span><span class="filter-action-btn" onclick="clearAllMonths()" style="color: #dc2626;">Clear</span></div></div><div class="strategy-filter-list" id="monthFilterList"></div></div></div><div class="strategy-filter-container"><button class="strategy-filter-button" onclick="toggleStrategyFilter()"><span>Select Strategies</span><span class="filter-badge" id="filterBadge" style="display: none;">0</span><span>▼</span></button><div class="strategy-filter-dropdown" id="strategyFilterDropdown"><div class="strategy-filter-header"><span class="strategy-filter-title">Strategies</span><div class="strategy-filter-actions"><span class="filter-action-btn" onclick="selectAllStrategies()">All</span><span class="filter-action-btn" onclick="deselectAllStrategies()" style="color: #dc2626;">Clear</span></div></div><div class="strategy-filter-list" id="strategyFilterList"></div></div></div><div class="strategy-filter-container"><button class="strategy-filter-button" onclick="toggleBrokerFilter()"><span>Select Brokers</span><span class="filter-badge" id="brokerFilterBadge" style="display: none;">0</span><span>▼</span></button><div class="strategy-filter-dropdown" id="brokerFilterDropdown"><div class="strategy-filter-header"><span class="strategy-filter-title">Brokers</span><div class="strategy-filter-actions"><span class="filter-action-btn" onclick="selectAllBrokers()">All</span><span class="filter-action-btn" onclick="clearAllBrokers()" style="color: #dc2626;">Clear</span></div></div><div class="strategy-filter-list" id="brokerFilterList"></div></div></div><button onclick="toggleFilteredTotalsButton()" id="filteredTotalsButton">Show Filtered Totals</button><button onclick="toggleTradeCountButton()" id="tradeCountButton">Show Trade Count</button><button onclick="toggleDrawdownButton()" id="drawdownButton">Show Drawdown</button><button onclick="toggleLotButton()" id="lotButton">Show Lot</button><button onclick="toggleLotPnlButton()" id="lotPnlButton">Show Lot PNL</button><button onclick="togglePnlTaxModeButton()" id="pnlTaxButton">Show Tax PNL</button><button onclick="expandAll()">Expand All</button><button onclick="collapseAll()">Collapse All</button><button onclick="exportToCSV()">Export to csv</button><button class="primary" onclick="resetAllFilters()">Reset Filter</button></div><div class="table-container"><div class="table-wrapper"><table class="performance-table" id="performanceTable"><thead id="tableHeaders"></thead><tbody id="tableBody"><tr><td colspan="100" class="no-data">Upload Excel file to view performance data</td></tr></tbody></table></div></div></div><script>
const elements = {
startingCapital: document.getElementById('startingCapital'),
runningProfit: document.getElementById('runningProfit'),
netBrProfit: document.getElementById('netBrProfit'),
charges: document.getElementById('charges'),
runningMargin: document.getElementById('runningMargin'),
totalExpense: document.getElementById('totalExpense'),
netProfit: document.getElementById('netProfit'),
monthFilterDropdown: document.getElementById('monthFilterDropdown'),
monthFilterList: document.getElementById('monthFilterList'),
monthFilterBadge: document.getElementById('monthFilterBadge'),
strategyFilterDropdown: document.getElementById('strategyFilterDropdown'),
strategyFilterList: document.getElementById('strategyFilterList'),
filterBadge: document.getElementById('filterBadge'),
brokerFilterDropdown: document.getElementById('brokerFilterDropdown'),
brokerFilterList: document.getElementById('brokerFilterList'),
brokerFilterBadge: document.getElementById('brokerFilterBadge'),
tableHeaders: document.getElementById('tableHeaders'),
tableBody: document.getElementById('tableBody')
};
let allTrades = [], hiddenStrategies = new Set(), savedHiddenStrategies = new Set(), selectedMonths = new Set(), selectedBrokers = new Set(['A']), allStrategies = [], allBrokers = [], brokersInitialized = false, globalTotalExpenses = 0, globalLastTotalMargin = 0;
let originalAllTrades = []; // Store original trades before date filtering
let customFromDate = null;
let customToDate = null;
let globalStartingCapital = 0;
let updateTimeout;
let showFilteredTotals = false, showTradeCount = false, showDrawdown = false, showLot = false;
let showPnlTax = false;
let showLotPnl = false;
let monthsCleared = false;
function extractBrokerCode(strategyName) {
if (!strategyName) return null;
if (strategyName.startsWith('A.PRO')) return 'A';
const cleanName = strategyName.replace(/\s+/g, '');
const match = cleanName.match(/^(.+?)PRO/);
return match ? match[1] : null;
}
const monthNames = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];
window.addEventListener('DOMContentLoaded', () => {
// Mobile Safari fix - force tbody visibility
if (/iPhone|iPad|iPod/.test(navigator.userAgent) || (navigator.userAgent.includes('Safari') && !navigator.userAgent.includes('Chrome'))) {
  const fixMobileSafari = () => {
    const table = document.querySelector('.performance-table');
    const thead = document.querySelector('.performance-table thead');
    const tbody = document.querySelector('.performance-table tbody');
    if (table) {
      table.style.isolation = 'auto';
    }
    if (thead) {
      thead.style.position = 'relative';
      thead.style.transform = 'none';
      thead.style.webkitTransform = 'none';
    }
    if (tbody) {
      tbody.style.display = 'table-row-group';
      tbody.style.visibility = 'visible';
      // Force reflow
      tbody.offsetHeight;
    }
  };
  fixMobileSafari();
  // Run again after a short delay to catch dynamically loaded content
  setTimeout(fixMobileSafari, 100);
  setTimeout(fixMobileSafari, 500);
}
loadSavedFilters();
initializeHeadersOnly(); // Initialize headers only on page load
// Set up event delegation for strategy filter checkboxes
elements.strategyFilterList.addEventListener('change', function(e) {
if (e.target.classList.contains('strategy-filter-checkbox')) {
const strategyName = e.target.getAttribute('data-strategy-name');
if (strategyName) {
if (e.target.checked) {
hiddenStrategies.delete(strategyName);
} else {
hiddenStrategies.add(strategyName);
}
saveFilters();
updateFilterBadge();
processAndDisplayData();
}
}
});
// Set up click handler for entire strategy filter row
elements.strategyFilterList.addEventListener('click', function(e) {
// Stop the event from bubbling up to the document click handler
e.stopPropagation();
// Find the closest strategy-filter-item div
const filterItem = e.target.closest('.strategy-filter-item');
if (filterItem && !e.target.classList.contains('strategy-filter-checkbox')) {
// Find the checkbox inside this item
const checkbox = filterItem.querySelector('.strategy-filter-checkbox');
if (checkbox) {
checkbox.checked = !checkbox.checked;
// Trigger the change event
const changeEvent = new Event('change', { bubbles: true });
checkbox.dispatchEvent(changeEvent);
}
}
});
// Set up event delegation for month filter checkboxes
elements.monthFilterList.addEventListener('change', function(e) {
if (e.target.classList.contains('strategy-filter-checkbox')) {
// Handle year checkbox
if (e.target.classList.contains('year-checkbox')) {
const year = e.target.getAttribute('data-year');
const isChecked = e.target.checked;
// Find all months for this year and update them
const monthCheckboxes = elements.monthFilterList.querySelectorAll(`input.month-checkbox[data-year="${year}"]`);
monthCheckboxes.forEach(checkbox => {
const monthYear = checkbox.getAttribute('data-month');
if (isChecked) {
selectedMonths.add(monthYear);
checkbox.checked = true;
monthsCleared = false;
} else {
selectedMonths.delete(monthYear);
checkbox.checked = false;
}
});
// If all months are now deselected, set monthsCleared flag
if (selectedMonths.size === 0) {
monthsCleared = true;
}
saveMonthFilters();
updateMonthFilterBadge();
processAndDisplayData();
}
// Handle month checkbox
else if (e.target.classList.contains('month-checkbox')) {
const month = e.target.getAttribute('data-month');
const year = e.target.getAttribute('data-year');
if (month) {
if (e.target.checked) {
selectedMonths.add(month);
monthsCleared = false;
} else {
selectedMonths.delete(month);
}
// Update year checkbox state
const yearCheckbox = document.getElementById(`year_check_${year}`);
if (yearCheckbox) {
const allMonthsInYear = elements.monthFilterList.querySelectorAll(`input.month-checkbox[data-year="${year}"]`);
const allChecked = Array.from(allMonthsInYear).every(cb => cb.checked);
yearCheckbox.checked = allChecked;
}
saveMonthFilters();
updateMonthFilterBadge();
processAndDisplayData();
}
}
}
});
// Set up click handler for entire month filter row
elements.monthFilterList.addEventListener('click', function(e) {
// Stop the event from bubbling up to the document click handler
e.stopPropagation();

// Handle year header clicks (label or div area)
const yearHeader = e.target.closest('.year-header');
if (yearHeader && !e.target.classList.contains('year-checkbox')) {
const yearCheckbox = yearHeader.querySelector('.year-checkbox');
if (yearCheckbox) {
yearCheckbox.checked = !yearCheckbox.checked;
const changeEvent = new Event('change', { bubbles: true });
yearCheckbox.dispatchEvent(changeEvent);
return;
}
}

// Handle month filter item clicks
const filterItem = e.target.closest('.strategy-filter-item');
if (filterItem && !e.target.classList.contains('strategy-filter-checkbox')) {
const checkbox = filterItem.querySelector('.strategy-filter-checkbox');
if (checkbox) {
checkbox.checked = !checkbox.checked;
const changeEvent = new Event('change', { bubbles: true });
checkbox.dispatchEvent(changeEvent);
}
}
});
// Set up event delegation for broker filter checkboxes
elements.brokerFilterList.addEventListener('change', function(e) {
if (e.target.classList.contains('strategy-filter-checkbox')) {
const broker = e.target.getAttribute('data-broker');
if (broker) {
if (broker === 'A') {
e.target.checked = true;
selectedBrokers.add('A');
return;
}
if (e.target.checked) {
selectedBrokers.add(broker);
} else {
selectedBrokers.delete(broker);
}
selectedBrokers.add('A');
updateBrokerFilterBadge();
processAndDisplayData();
}
}
});
// Set up click handler for entire broker filter row
elements.brokerFilterList.addEventListener('click', function(e) {
// Stop the event from bubbling up to the document click handler
e.stopPropagation();
const filterItem = e.target.closest('.strategy-filter-item');
if (filterItem && !e.target.classList.contains('strategy-filter-checkbox')) {
const checkbox = filterItem.querySelector('.strategy-filter-checkbox');
if (checkbox) {
checkbox.checked = !checkbox.checked;
const changeEvent = new Event('change', { bubbles: true });
checkbox.dispatchEvent(changeEvent);
}
}
});
// Prevent dropdown close when clicking inside any dropdown
elements.strategyFilterDropdown.addEventListener('click', function(e) {
e.stopPropagation();
});
elements.monthFilterDropdown.addEventListener('click', function(e) {
e.stopPropagation();
});
elements.brokerFilterDropdown.addEventListener('click', function(e) {
e.stopPropagation();
});
document.addEventListener('click', (event) => {
if (!elements.strategyFilterDropdown.contains(event.target) &&
!event.target.closest('.strategy-filter-button')) {
elements.strategyFilterDropdown.classList.remove('active');
}
if (!elements.brokerFilterDropdown.contains(event.target) &&
!event.target.closest('.strategy-filter-button')) {
elements.brokerFilterDropdown.classList.remove('active');
}
const clickedButton = event.target.closest('.strategy-filter-button');
const isMonthButton = clickedButton && clickedButton.querySelector('#monthFilterBadge');
if (!elements.monthFilterDropdown.contains(event.target) && !isMonthButton) {
elements.monthFilterDropdown.classList.remove('active');
}
});
// Removed auto-close on mouseleave - dropdowns now only close when clicking outside
// This allows users to select multiple items without the dropdown closing
const closeTimeouts = new Map();
document.querySelectorAll('.strategy-filter-container').forEach(container => {
const dropdown = container.querySelector('.strategy-filter-dropdown');
if (dropdown) {
// Close dropdown after 300ms when mouse leaves
container.addEventListener('mouseleave', () => {
const timeoutId = setTimeout(() => {
dropdown.classList.remove('active');
closeTimeouts.delete(container);
}, 300);
closeTimeouts.set(container, timeoutId);
});
// Cancel close timeout when mouse enters back
container.addEventListener('mouseenter', () => {
if (closeTimeouts.has(container)) {
clearTimeout(closeTimeouts.get(container));
closeTimeouts.delete(container);
}
});
}
});
});
window.addEventListener('message', (event) => {
const { type, data } = event.data;
if (type === 'TRADES_DATA') {
originalAllTrades = data; // Store original data
resetToAllTimeWithDataRange(); // Reset dates based on data
applyDateFilter(); // Apply date filter
selectedBrokers.clear(); // Clear broker selections on new data load
brokersInitialized = false; // Reset flag on new data load to allow auto-selection
// Load filters from localStorage instead of clearing them
try {
const savedFilters = localStorage.getItem('strategyPerformance_hiddenStrategies');
if (savedFilters) {
hiddenStrategies = new Set(JSON.parse(savedFilters));
savedHiddenStrategies = new Set(JSON.parse(savedFilters)); // Keep a copy of saved filters
}
const savedMonths = localStorage.getItem('strategyPerformance_selectedMonths');
if (savedMonths) {
selectedMonths = new Set(JSON.parse(savedMonths));
}
} catch (e) {
console.error('Failed to load saved filters:', e);
}
processAndDisplayData();
} else if (type === 'LOAD_SAMPLE_DATA') {
loadSampleData();
}
});
function applyDateFilter() {
if (!originalAllTrades) {
allTrades = [];
return;
}
const fromDateInput = document.getElementById('fromDate');
const toDateInput = document.getElementById('toDate');
let filteredTrades = originalAllTrades;
const fromDate = fromDateInput?.value ? new Date(fromDateInput.value) : null;
const toDate = toDateInput?.value ? new Date(toDateInput.value) : null;
if (fromDate || toDate) {
filteredTrades = originalAllTrades.filter(trade => {
const dateParts = trade.date.split('/');
if (dateParts.length !== 3) return true;
let year = parseInt(dateParts[2]);
if (year < 100) year += 2000;
const tradeDate = new Date(year, parseInt(dateParts[1]) - 1, parseInt(dateParts[0]));
if (fromDate) {
const fromDateStart = new Date(fromDate);
fromDateStart.setHours(0, 0, 0, 0);
if (tradeDate < fromDateStart) return false;
}
if (toDate) {
const toDateEnd = new Date(toDate);
toDateEnd.setHours(23, 59, 59, 999);
if (tradeDate > toDateEnd) return false;
}
return true;
});
}
allTrades = filteredTrades;
}
function resetToAllTimeWithDataRange() {
const fromDateInput = document.getElementById('fromDate');
const toDateInput = document.getElementById('toDate');
if (originalAllTrades && originalAllTrades.length > 0) {
let minDate = null, maxDate = null;
originalAllTrades.forEach(trade => {
const dateParts = trade.date.split('/');
if (dateParts.length === 3) {
let year = parseInt(dateParts[2]);
if (year < 100) year += 2000;
const tradeDate = new Date(year, parseInt(dateParts[1]) - 1, parseInt(dateParts[0]));
if (!minDate || tradeDate < minDate) minDate = tradeDate;
if (!maxDate || tradeDate > maxDate) maxDate = tradeDate;
}
});
if (fromDateInput && minDate) {
const year = minDate.getFullYear();
const month = String(minDate.getMonth() + 1).padStart(2, '0');
const day = String(minDate.getDate()).padStart(2, '0');
fromDateInput.value = `${year}-${month}-${day}`;
fromDateInput.min = `${year}-${month}-${day}`;
if (maxDate) {
const maxYear = maxDate.getFullYear();
const maxMonth = String(maxDate.getMonth() + 1).padStart(2, '0');
const maxDay = String(maxDate.getDate()).padStart(2, '0');
fromDateInput.max = `${maxYear}-${maxMonth}-${maxDay}`;
}
}
if (toDateInput && maxDate) {
const year = maxDate.getFullYear();
const month = String(maxDate.getMonth() + 1).padStart(2, '0');
const day = String(maxDate.getDate()).padStart(2, '0');
toDateInput.value = `${year}-${month}-${day}`;
if (minDate) {
const minYear = minDate.getFullYear();
const minMonth = String(minDate.getMonth() + 1).padStart(2, '0');
const minDay = String(minDate.getDate()).padStart(2, '0');
toDateInput.min = `${minYear}-${minMonth}-${minDay}`;
}
toDateInput.max = `${year}-${month}-${day}`;
}
} else {
const today = new Date();
const year = today.getFullYear();
const month = String(today.getMonth() + 1).padStart(2, '0');
const day = String(today.getDate()).padStart(2, '0');
if (fromDateInput) fromDateInput.value = '';
if (toDateInput) toDateInput.value = `${year}-${month}-${day}`;
}
document.querySelectorAll('.date-range-buttons .btn').forEach(btn => {
btn.classList.remove('active');
if (btn.textContent.trim() === 'ALL TIME') btn.classList.add('active');
});
}
function setDateRange(range) {
const today = new Date();
const toDateInput = document.getElementById('toDate');
const fromDateInput = document.getElementById('fromDate');
const todayYear = today.getFullYear();
const todayMonth = String(today.getMonth() + 1).padStart(2, '0');
const todayDay = String(today.getDate()).padStart(2, '0');
toDateInput.value = `${todayYear}-${todayMonth}-${todayDay}`;
if (range === '3M') {
const threeMonthsAgo = new Date(today);
threeMonthsAgo.setMonth(today.getMonth() - 3);
const year = threeMonthsAgo.getFullYear();
const month = String(threeMonthsAgo.getMonth() + 1).padStart(2, '0');
const day = String(threeMonthsAgo.getDate()).padStart(2, '0');
fromDateInput.value = `${year}-${month}-${day}`;
} else if (range === 'YTD') {
const year = today.getFullYear();
fromDateInput.value = `${year}-01-01`;
} else if (range === 'ALL') {
resetToAllTimeWithDataRange();
applyDateFilter();
processAndDisplayData();
return;
}
document.querySelectorAll('.date-range-buttons .btn').forEach(btn => btn.classList.remove('active'));
event.target.classList.add('active');
applyDateFilter();
processAndDisplayData();
}
function saveFilters() {
try {
localStorage.setItem('strategyPerformance_hiddenStrategies', JSON.stringify(Array.from(hiddenStrategies)));
savedHiddenStrategies = new Set(hiddenStrategies); // Update saved copy
} catch (e) {
console.error('Failed to save filters:', e);
}
}
function saveMonthFilters() {
try {
localStorage.setItem('strategyPerformance_selectedMonths', JSON.stringify(Array.from(selectedMonths)));
} catch (e) {
console.error('Failed to save month filters:', e);
}
}
function loadSavedFilters() {
try {
localStorage.removeItem('selectedBrokers');
const savedFilters = localStorage.getItem('strategyPerformance_hiddenStrategies');
if (savedFilters) {
hiddenStrategies = new Set(JSON.parse(savedFilters));
}
const savedMonths = localStorage.getItem('strategyPerformance_selectedMonths');
if (savedMonths) {
selectedMonths = new Set(JSON.parse(savedMonths));
}
const savedTotalsMode = localStorage.getItem('strategyPerformance_showFilteredTotals');
if (savedTotalsMode !== null) {
showFilteredTotals = savedTotalsMode === 'true';
const button = document.getElementById('filteredTotalsButton');
if (button) button.textContent = showFilteredTotals ? 'Hide Filtered Totals' : 'Show Filtered Totals';
}
const savedTradeMode = localStorage.getItem('strategyPerformance_showTradeCount');
if (savedTradeMode !== null) {
showTradeCount = savedTradeMode === 'true';
const button = document.getElementById('tradeCountButton');
if (button) button.textContent = showTradeCount ? 'Hide Trade Count' : 'Show Trade Count';
}
const savedDrawdownMode = localStorage.getItem('strategyPerformance_showDrawdown');
if (savedDrawdownMode !== null) {
showDrawdown = savedDrawdownMode === 'true';
const button = document.getElementById('drawdownButton');
if (button) button.textContent = showDrawdown ? 'Hide Drawdown' : 'Show Drawdown';
}
const savedLotMode = localStorage.getItem('strategyPerformance_showLot');
if (savedLotMode !== null) {
showLot = savedLotMode === 'true';
const button = document.getElementById('lotButton');
if (button) button.textContent = showLot ? 'Hide Lot' : 'Show Lot';
}
const savedPnlTaxMode = localStorage.getItem('strategyPerformance_showPnlTax');
if (savedPnlTaxMode !== null) {
showPnlTax = savedPnlTaxMode === 'true';
const button = document.getElementById('pnlTaxButton');
if (button) button.textContent = showPnlTax ? 'Hide Tax PNL' : 'Show Tax PNL';
}
const savedLotPnlMode = localStorage.getItem('strategyPerformance_showLotPnl');
if (savedLotPnlMode !== null) {
showLotPnl = savedLotPnlMode === 'true';
const button = document.getElementById('lotPnlButton');
if (button) button.textContent = showLotPnl ? 'Hide Lot PNL' : 'Show Lot PNL';
}
} catch (e) {
hiddenStrategies = new Set();
}
}
function toggleTotalsMode() {
const checkbox = document.getElementById('showFilteredTotals');
showFilteredTotals = checkbox.checked;
try {
} catch (e) {}
processAndDisplayData();
}
function toggleDrawdownMode() {
const checkbox = document.getElementById('showDrawdown');
showDrawdown = checkbox.checked;
try {
} catch (e) {}
processAndDisplayData();
}
function toggleLotMode() {
const checkbox = document.getElementById('showLot');
showLot = checkbox.checked;
try {
} catch (e) {}
processAndDisplayData();
}
function togglePnlTaxMode() {
const checkbox = document.getElementById('showPnlTax');
showPnlTax = checkbox.checked;
try {
} catch (e) {}
processAndDisplayData();
}
function togglePnlTaxModeButton() {
showPnlTax = !showPnlTax;
const button = document.getElementById('pnlTaxButton');
if (button) {
button.textContent = showPnlTax ? 'Hide Tax PNL' : 'Show Tax PNL';
}
try {
localStorage.setItem('strategyPerformance_showPnlTax', showPnlTax.toString());
} catch (e) {}
processAndDisplayData();
}
function toggleFilteredTotalsButton() {
showFilteredTotals = !showFilteredTotals;
const button = document.getElementById('filteredTotalsButton');
if (button) {
button.textContent = showFilteredTotals ? 'Hide Filtered Totals' : 'Show Filtered Totals';
}
try {
localStorage.setItem('strategyPerformance_showFilteredTotals', showFilteredTotals.toString());
} catch (e) {}
processAndDisplayData();
}
function toggleTradeCountButton() {
showTradeCount = !showTradeCount;
const button = document.getElementById('tradeCountButton');
if (button) {
button.textContent = showTradeCount ? 'Hide Trade Count' : 'Show Trade Count';
}
if (showTradeCount && !showLot) {
showLot = true;
const lotButton = document.getElementById('lotButton');
if (lotButton) lotButton.textContent = 'Hide Lot';
try { localStorage.setItem('strategyPerformance_showLot', showLot.toString()); } catch (e) {}
}
if (!showTradeCount && showLot) {
showLot = false;
const lotButton = document.getElementById('lotButton');
if (lotButton) lotButton.textContent = 'Show Lot';
try { localStorage.setItem('strategyPerformance_showLot', showLot.toString()); } catch (e) {}
}
try { localStorage.setItem('strategyPerformance_showTradeCount', showTradeCount.toString()); } catch (e) {}
processAndDisplayData();
}
function toggleDrawdownButton() {
showDrawdown = !showDrawdown;
const button = document.getElementById('drawdownButton');
if (button) {
button.textContent = showDrawdown ? 'Hide Drawdown' : 'Show Drawdown';
}
try {
localStorage.setItem('strategyPerformance_showDrawdown', showDrawdown.toString());
} catch (e) {}
processAndDisplayData();
}
function toggleLotButton() {
showLot = !showLot;
const button = document.getElementById('lotButton');
if (button) {
button.textContent = showLot ? 'Hide Lot' : 'Show Lot';
}
// If showing lot column, disable trade count to show lot sizes
if (showLot && showTradeCount) {
showTradeCount = false;
const tradeCountButton = document.getElementById('tradeCountButton');
if (tradeCountButton) tradeCountButton.textContent = 'Show Trade Count';
try { localStorage.setItem('strategyPerformance_showTradeCount', showTradeCount.toString()); } catch (e) {}
}
try {
localStorage.setItem('strategyPerformance_showLot', showLot.toString());
} catch (e) {}
processAndDisplayData();
}
function toggleLotPnlButton() {
showLotPnl = !showLotPnl;
const button = document.getElementById('lotPnlButton');
if (button) {
button.textContent = showLotPnl ? 'Hide Lot PNL' : 'Show Lot PNL';
}
try {
localStorage.setItem('strategyPerformance_showLotPnl', showLotPnl.toString());
} catch (e) {}
processAndDisplayData();
}
function toggleLotPnlMode() {
const checkbox = document.getElementById('showLotPnl');
showLotPnl = checkbox.checked;
try {
} catch (e) {}
processAndDisplayData();
}
function updateStrategyFilterList() {
if (allStrategies.length > 0) {
const validHiddenStrategies = new Set();
hiddenStrategies.forEach(strategy => {
if (allStrategies.includes(strategy)) {
validHiddenStrategies.add(strategy);
}
});
hiddenStrategies = validHiddenStrategies;
}
const html = allStrategies.map(strategy => {
const isChecked = !hiddenStrategies.has(strategy);
const displayName = formatStrategyName(strategy);
const safeId = strategy.replace(/[^a-zA-Z0-9]/g, '_');
return `<div class="strategy-filter-item"><input type="checkbox" class="strategy-filter-checkbox" id="check_${safeId}" data-strategy-name="${strategy.replace(/"/g, '&quot;')}" ${isChecked ? 'checked' : ''}><label class="strategy-filter-label" for="check_${safeId}">${displayName}</label></div>`;
}).join('');
elements.strategyFilterList.innerHTML = html;
updateFilterBadge();
}
function toggleStrategyFilter() {
elements.monthFilterDropdown.classList.remove('active');
elements.strategyFilterDropdown.classList.toggle('active');
}
function updateStrategyFilterList() {
if (allStrategies.length > 0) {
const validHiddenStrategies = new Set();
hiddenStrategies.forEach(strategy => {
if (allStrategies.includes(strategy)) {
validHiddenStrategies.add(strategy);
}
});
hiddenStrategies = validHiddenStrategies;
}
const html = allStrategies.map(strategy => {
const isChecked = !hiddenStrategies.has(strategy);
const displayName = formatStrategyName(strategy);
const safeId = strategy.replace(/[^a-zA-Z0-9]/g, '_');
return `<div class="strategy-filter-item"><input type="checkbox" class="strategy-filter-checkbox" id="check_${safeId}" data-strategy-name="${strategy.replace(/"/g, '&quot;')}" ${isChecked ? 'checked' : ''}><label class="strategy-filter-label" for="check_${safeId}">${displayName}</label></div>`;
}).join('');
elements.strategyFilterList.innerHTML = html;
updateFilterBadge();
}
function handleStrategyCheckboxChange(strategyName) {
const escapedId = CSS.escape(strategyName);
const checkbox = document.getElementById(`check_${escapedId}`);
if (!checkbox) return;
if (checkbox.checked) {
hiddenStrategies.delete(strategyName);
} else {
hiddenStrategies.add(strategyName);
}
// Only save to localStorage if all brokers are selected
const allBrokersSelected = allBrokers.length > 0 && allBrokers.every(broker => selectedBrokers.has(broker));
if (allBrokersSelected) {
saveFilters();
}
updateFilterBadge();
processAndDisplayData();
}
function toggleStrategyRow(strategyName) {
const checkbox = document.getElementById(`check_${strategyName}`);
if (!checkbox) return;
// If this was triggered by clicking the div (not the checkbox), toggle the checkbox
// If triggered by checkbox click, checkbox state is already changed
if (event && event.target.type !== 'checkbox') {
checkbox.checked = !checkbox.checked;
}
if (checkbox.checked) {
hiddenStrategies.delete(strategyName);
} else {
hiddenStrategies.add(strategyName);
}
// Only save to localStorage if all brokers are selected
const allBrokersSelected = allBrokers.length > 0 && allBrokers.every(broker => selectedBrokers.has(broker));
if (allBrokersSelected) {
saveFilters();
}
updateFilterBadge();
clearTimeout(updateTimeout);
updateTimeout = setTimeout(() => processAndDisplayData(), 250);
}
function selectAllStrategies() {
hiddenStrategies.clear();
saveFilters();
allStrategies.forEach(strategy => {
const safeId = strategy.replace(/[^a-zA-Z0-9]/g, '_');
const checkbox = document.getElementById(`check_${safeId}`);
if (checkbox) checkbox.checked = true;
});
updateFilterBadge();
processAndDisplayData();
}
function deselectAllStrategies() {
allStrategies.forEach(strategy => hiddenStrategies.add(strategy));
saveFilters();
allStrategies.forEach(strategy => {
const safeId = strategy.replace(/[^a-zA-Z0-9]/g, '_');
const checkbox = document.getElementById(`check_${safeId}`);
if (checkbox) checkbox.checked = false;
});
updateFilterBadge();
processAndDisplayData();
}
function toggleMonthFilter() {
elements.strategyFilterDropdown.classList.remove('active');
elements.monthFilterDropdown.classList.toggle('active');
}
function updateMonthFilterList() {
const monthYearSet = new Set();
allTrades.forEach(trade => {
const parts = trade.date.split('/');
if (parts.length >= 3) monthYearSet.add(`${parts[1]}/${parts[2]}`); // MM/YY format
});
const monthYearArray = Array.from(monthYearSet).sort((a, b) => {
const [monthA, yearA] = a.split('/');
const [monthB, yearB] = b.split('/');
if (yearA !== yearB) return yearB.localeCompare(yearA); // Descending year
return parseInt(monthA) - parseInt(monthB); // Ascending month (Jan to Dec)
});
if (selectedMonths.size === 0 && !monthsCleared) {
monthYearArray.forEach(monthYear => selectedMonths.add(monthYear));
}
// Group by year
const yearGroups = {};
monthYearArray.forEach(monthYear => {
const [month, year] = monthYear.split('/');
const fullYear = year.length === 2 ? (parseInt(year) > 50 ? `19${year}` : `20${year}`) : year;
if (!yearGroups[fullYear]) yearGroups[fullYear] = [];
yearGroups[fullYear].push({ monthYear, month, year });
});
// Build HTML with year headers
let html = '';
Object.keys(yearGroups).sort((a, b) => b.localeCompare(a)).forEach(fullYear => {
const yearMonths = yearGroups[fullYear];
const allYearSelected = yearMonths.every(({monthYear}) => selectedMonths.has(monthYear));
html += `<div class="year-header" style="padding: 8px 14px; font-weight: 600; font-size: 11px; color: #1f2937; background: #f3f4f6; border-bottom: 1px solid #d1d5db; display: flex; align-items: center; gap: 8px; cursor: pointer;">
<input type="checkbox" class="strategy-filter-checkbox year-checkbox" id="year_check_${fullYear}" data-year="${fullYear}" ${allYearSelected ? 'checked' : ''} style="width: 14px; height: 14px; cursor: pointer;">
<label for="year_check_${fullYear}" style="cursor: pointer; user-select: none; flex: 1;">${fullYear}</label>
</div>`;
yearGroups[fullYear].forEach(({ monthYear, month }) => {
const isChecked = selectedMonths.has(monthYear);
const displayName = monthNames[parseInt(month) - 1];
html += `<div class="strategy-filter-item" style="padding-left: 28px;"><input type="checkbox" class="strategy-filter-checkbox month-checkbox" id="month_check_${monthYear.replace('/', '_')}" data-month="${monthYear}" data-year="${fullYear}" ${isChecked ? 'checked' : ''}><label class="strategy-filter-label" for="month_check_${monthYear.replace('/', '_')}">${displayName}</label></div>`;
});
});
elements.monthFilterList.innerHTML = html;
updateMonthFilterBadge();
}
function handleMonthCheckboxChange(month) {
const checkbox = document.getElementById(`month_check_${month}`);
if (!checkbox) return;
if (checkbox.checked) {
selectedMonths.add(month);
} else {
selectedMonths.delete(month);
}
saveMonthFilters();
updateMonthFilterBadge();
processAndDisplayData();
}
function toggleMonthRow(month) {
const checkbox = document.getElementById(`month_check_${month}`);
if (!checkbox) return;
// If this was triggered by clicking the div (not the checkbox), toggle the checkbox
// If triggered by checkbox click, checkbox state is already changed
if (event && event.target.type !== 'checkbox') {
checkbox.checked = !checkbox.checked;
}
if (checkbox.checked) {
selectedMonths.add(month);
} else {
selectedMonths.delete(month);
}
saveMonthFilters();
updateMonthFilterBadge();
processAndDisplayData();
}
function updateMonthFilterBadge() {
const monthsSet = new Set();
allTrades.forEach(trade => {
const parts = trade.date.split('/');
if (parts.length >= 3) monthsSet.add(`${parts[1]}/${parts[2]}`);
});
const totalMonths = monthsSet.size;
const selectedCount = selectedMonths.size;
if (selectedCount > 0 && selectedCount < totalMonths) {
elements.monthFilterBadge.textContent = selectedCount;
elements.monthFilterBadge.style.display = 'inline-block';
} else {
elements.monthFilterBadge.style.display = 'none';
}
}
function toggleBrokerFilter() {
elements.strategyFilterDropdown.classList.remove('active');
elements.monthFilterDropdown.classList.remove('active');
elements.brokerFilterDropdown.classList.toggle('active');
}
function updateBrokerFilterList() {
const brokersSet = new Set();
allTrades.forEach((trade) => {
if (trade.strategyDetails) {
Object.keys(trade.strategyDetails).forEach(stratName => {
const brokerCode = extractBrokerCode(stratName);
if (brokerCode) {
brokersSet.add(brokerCode);
}
});
}
});
allBrokers = Array.from(brokersSet).sort();
const selectableBrokers = allBrokers.filter(broker => broker !== 'A'), html = selectableBrokers.map(broker => {
const isChecked = selectedBrokers.has(broker);
return `<div class="strategy-filter-item"><input type="checkbox" class="strategy-filter-checkbox" id="broker_check_${broker}" data-broker="${broker}" ${isChecked ? 'checked' : ''}><label class="strategy-filter-label" for="broker_check_${broker}">${broker}</label></div>`;
}).join('');
elements.brokerFilterList.innerHTML = html;
updateBrokerFilterBadge();
}
function handleBrokerCheckboxChange(broker) {
const checkbox = document.getElementById(`broker_check_${broker}`);
if (!checkbox) return;
if (broker === 'A') {
checkbox.checked = true;
selectedBrokers.add('A');
return;
}
if (checkbox.checked) {
selectedBrokers.add(broker);
} else {
selectedBrokers.delete(broker);
}
selectedBrokers.add('A');
updateBrokerFilterBadge();
processAndDisplayData();
}
function toggleBrokerRow(broker) {
const checkbox = document.getElementById(`broker_check_${broker}`);
if (!checkbox) return;
if (broker === 'A') {
checkbox.checked = true;
selectedBrokers.add('A');
return;
}
// If this was triggered by clicking the div (not the checkbox), toggle the checkbox
// If triggered by checkbox click, checkbox state is already changed
if (event && event.target.type !== 'checkbox') {
checkbox.checked = !checkbox.checked;
}
if (checkbox.checked) {
selectedBrokers.add(broker);
} else {
selectedBrokers.delete(broker);
}
selectedBrokers.add('A');
updateBrokerFilterBadge();
processAndDisplayData();
}
function updateBrokerFilterBadge() {
const selectableBrokers = allBrokers.filter(b => b !== 'A');
const totalSelectable = selectableBrokers.length;
const selectedSelectable = selectableBrokers.filter(b => selectedBrokers.has(b)).length;
if (selectedSelectable > 0 && selectedSelectable < totalSelectable) {
elements.brokerFilterBadge.textContent = selectedSelectable;
elements.brokerFilterBadge.style.display = 'inline-block';
} else {
elements.brokerFilterBadge.style.display = 'none';
}
}
function selectAllBrokers() {
allBrokers.forEach(broker => selectedBrokers.add(broker));
allBrokers.forEach(broker => {
if (broker !== 'A') {
const checkbox = document.getElementById(`broker_check_${broker}`);
if (checkbox) checkbox.checked = true;
}
});
updateBrokerFilterBadge();
processAndDisplayData();
}
function clearAllBrokers() {
selectedBrokers.clear();
selectedBrokers.add('A'); // Always keep Amibroker selected
allBrokers.forEach(broker => {
if (broker !== 'A') {
const checkbox = document.getElementById(`broker_check_${broker}`);
if (checkbox) checkbox.checked = false;
}
});
updateBrokerFilterBadge();
processAndDisplayData();
}
function selectAllMonths() {
const monthsSet = new Set();
allTrades.forEach(trade => {
const parts = trade.date.split('/');
if (parts.length >= 3) monthsSet.add(`${parts[1]}/${parts[2]}`);
});
const availableMonths = Array.from(monthsSet);
selectedMonths.clear();
monthsCleared = false;
availableMonths.forEach(monthYear => {
selectedMonths.add(monthYear);
const checkbox = document.getElementById(`month_check_${monthYear.replace('/', '_')}`);
if (checkbox) checkbox.checked = true;
});
saveMonthFilters();
updateMonthFilterBadge();
processAndDisplayData();
}
function clearAllMonths() {
selectedMonths.clear();
monthsCleared = true;
const monthsSet = new Set();
allTrades.forEach(trade => {
const parts = trade.date.split('/');
if (parts.length >= 3) monthsSet.add(`${parts[1]}/${parts[2]}`);
});
const availableMonths = Array.from(monthsSet);
availableMonths.forEach(monthYear => {
const checkbox = document.getElementById(`month_check_${monthYear.replace('/', '_')}`);
if (checkbox) checkbox.checked = false;
});
saveMonthFilters();
updateMonthFilterBadge();
processAndDisplayData();
}
function resetAllFilters() {
// Reset strategy filters - show all strategies
hiddenStrategies.clear();
saveFilters();
allStrategies.forEach(strategy => {
const safeId = strategy.replace(/[^a-zA-Z0-9]/g, '_');
const checkbox = document.getElementById(`check_${safeId}`);
if (checkbox) checkbox.checked = true;
});
// Reset month filters - select all months
const monthsSet = new Set();
allTrades.forEach(trade => {
const parts = trade.date.split('/');
if (parts.length >= 3) monthsSet.add(`${parts[1]}/${parts[2]}`);
});
selectedMonths.clear();
monthsCleared = false;
monthsSet.forEach(monthYear => {
selectedMonths.add(monthYear);
const checkbox = document.getElementById(`month_check_${monthYear.replace('/', '_')}`);
if (checkbox) checkbox.checked = true;
});
saveMonthFilters();
// Reset broker filters - select all brokers
selectedBrokers.clear();
allBrokers.forEach(broker => {
selectedBrokers.add(broker);
const checkbox = document.getElementById(`broker_check_${broker}`);
if (checkbox) checkbox.checked = true;
});
// Update badges and refresh display
updateFilterBadge();
updateMonthFilterBadge();
updateBrokerFilterBadge();
processAndDisplayData();
}
function updateFilterBadge() {
const hiddenCount = hiddenStrategies.size;
if (hiddenCount > 0 && allStrategies.length > 0) {
elements.filterBadge.textContent = hiddenCount;
elements.filterBadge.style.display = 'inline-block';
} else {
elements.filterBadge.style.display = 'none';
}
}
function formatStrategyName(strategyName) {
if (!strategyName) return strategyName;
if (strategyName.startsWith('A.PRO')) return strategyName;
const formatted = strategyName.replace(/_/g, ' ');
const match = formatted.match(/^(.+?)PRO\s*(\d+)$/);
if (match) {
return `${match[1]} PRO ${match[2]}`;
}
return formatted.replace(/(\d)(PRO)/g, '$1 $2');
}
function formatNumber(num) {
if (num === 0) return '';
const formatted = Math.abs(num).toLocaleString('en-IN', { maximumFractionDigits: 0 });
return num >= 0 ? formatted : `-${formatted}`;
}
function initializeHeadersOnly() {
const tempAProStrategies = ['A.PRO 2', 'A.PRO 3'], tempBrokerStrategies = ['B1PRO2', 'B1PRO3', 'B2PRO2', 'B2PRO3'], tempStrategies = [...tempAProStrategies, ...tempBrokerStrategies], aproStrategies = tempAProStrategies, brokerStrategies = tempBrokerStrategies;
const brokerGroups = {};
brokerStrategies.forEach(strat => {
const cleanName = strat.replace(/\s+/g, '');
const brokerMatch = cleanName.match(/^(.+?)PRO/);
if (brokerMatch) {
const brokerCode = brokerMatch[1];
if (!brokerGroups[brokerCode]) {
brokerGroups[brokerCode] = [];
}
brokerGroups[brokerCode].push(strat);
}
});
const sortedBrokers = Object.keys(brokerGroups).sort();
let headerRow1 = '<tr class="header-row-1">';
headerRow1 += '<th rowspan="2">Period</th>';
if (aproStrategies.length > 0) {
headerRow1 += `<th colspan="${aproStrategies.length}" class="number-col apro-boundary">Amibroker PNL</th>`;
}
sortedBrokers.forEach(brokerCode => {
const count = brokerGroups[brokerCode].length;
headerRow1 += `<th colspan="${count}" class="number-col broker-boundary">${brokerCode} DPNL</th>`;
});
let brokerPnlHeaderText;
if (showLotPnl) {
brokerPnlHeaderText = showPnlTax ? 'LOT PNL TAX' : 'LOT PNL';
} else {
brokerPnlHeaderText = showPnlTax ? 'PNL TAX' : 'PNL';
}
sortedBrokers.forEach(brokerCode => {
const count = brokerGroups[brokerCode].length;
headerRow1 += `<th colspan="${count}" class="number-col broker-boundary">${brokerCode} ${brokerPnlHeaderText}</th>`;
});
headerRow1 += '<th class="number-col total-net-col" rowspan="2">AMI PNL</th>';
const netPnlHeaderText = showPnlTax ? 'NET PNL TAX' : 'NET PNL';
headerRow1 += `<th class="number-col total-net-col" rowspan="2">${netPnlHeaderText}</th>`;
headerRow1 += '<th class="number-col net-pnl-percent-col" rowspan="2">NET PNL%</th>';
headerRow1 += '<th class="number-col expenses-col" rowspan="2">Expenses</th>';
headerRow1 += '<th class="number-col total-net-col" rowspan="2">TOTAL MARGIN</th>';
headerRow1 += '</tr>';
let headerRow2 = '<tr class="header-row-2">';
aproStrategies.forEach((strategy, idx) => {
const displayName = formatStrategyName(strategy), stratIndex = tempStrategies.indexOf(strategy);
const bgClass = `strategy-bg-${stratIndex % 5}`;
const boundaryClass = idx === aproStrategies.length - 1 ? ' apro-boundary' : '';
headerRow2 += `<th class="number-col apro-pnl-col ${bgClass}${boundaryClass}">${displayName}</th>`;
});
sortedBrokers.forEach((brokerCode, brokerIdx) => {
brokerGroups[brokerCode].forEach((strategy, idx) => {
const displayName = formatStrategyName(strategy).replace(/^[A-Z]+\d*\s*/, ''), stratIndex = tempStrategies.indexOf(strategy), bgClass = `strategy-bg-${stratIndex % 5}`, isLastInBroker = idx === brokerGroups[brokerCode].length - 1;
const isLastBroker = brokerIdx === sortedBrokers.length - 1;
const boundaryClass = (isLastInBroker && isLastBroker) ? ' broker-boundary' : '';
headerRow2 += `<th class="number-col ${bgClass}${boundaryClass}">${displayName}</th>`;
});
});
sortedBrokers.forEach((brokerCode, brokerIdx) => {
brokerGroups[brokerCode].forEach((strategy, idx) => {
const displayName = formatStrategyName(strategy).replace(/^[A-Z]+\d*\s*/, ''), stratIndex = tempStrategies.indexOf(strategy), bgClass = `strategy-bg-${stratIndex % 5}`, isLastInBroker = idx === brokerGroups[brokerCode].length - 1;
const isLastBroker = brokerIdx === sortedBrokers.length - 1;
const boundaryClass = (isLastInBroker && isLastBroker) ? ' broker-boundary' : '';
headerRow2 += `<th class="number-col ${bgClass}${boundaryClass}">${displayName}</th>`;
});
});
headerRow2 += '</tr>';
elements.tableHeaders.innerHTML = headerRow1 + headerRow2;
elements.tableBody.innerHTML = '<tr><td colspan="100%" class="no-data">No data loaded yet.</td></tr>';
}
function processAndDisplayData() {
if (allTrades.length === 0) return;
const brokersSet = new Set();
allTrades.forEach(trade => {
if (trade.strategyDetails) {
Object.keys(trade.strategyDetails).forEach(stratName => {
const brokerCode = extractBrokerCode(stratName);
if (brokerCode) brokersSet.add(brokerCode);
});
}
});
const tempAllBrokers = Array.from(brokersSet).sort();
if (tempAllBrokers.includes('A')) {
selectedBrokers.add('A');
}
if (!brokersInitialized && selectedBrokers.size <= 1 && tempAllBrokers.length > 0) {
tempAllBrokers.forEach(broker => selectedBrokers.add(broker));
brokersInitialized = true;
}
let filteredTrades = allTrades.filter(trade => {
const parts = trade.date?.split('/');
const monthYear = parts && parts.length >= 3 ? `${parts[1]}/${parts[2]}` : null;
if (monthsCleared && selectedMonths.size === 0) return false;
return selectedMonths.size === 0 || (monthYear && selectedMonths.has(monthYear));
});
filteredTrades = filteredTrades.map(trade => {
const filteredTrade = { ...trade }, filteredStrategyPnls = {}, filteredStrategyPnlTax = {}, filteredStrategyDetails = {}, filteredBrokerCodes = {};
const selectedBaseStrategies = new Set();
if (selectedBrokers.size > 0 && trade.strategyDetails) {
Object.keys(trade.strategyDetails).forEach(strategyName => {
let brokerCode = null;
if (strategyName.startsWith('A.PRO')) {
brokerCode = 'A';
} else {
const cleanName = strategyName.replace(/\s+/g, '');
const match = cleanName.match(/^(.+?)PRO/);
if (match) {
brokerCode = match[1];
}
}
if (brokerCode && selectedBrokers.has(brokerCode)) {
if (brokerCode !== 'A') {
let baseStrategy = strategyName.replace(/^[A-Z]+\d*/, '').trim();
baseStrategy = baseStrategy.replace(/\s+/g, '');
if (baseStrategy) {
selectedBaseStrategies.add(baseStrategy);
}
}
if (trade.strategyPnls && trade.strategyPnls[strategyName] !== undefined) {
filteredStrategyPnls[strategyName] = trade.strategyPnls[strategyName];
}
if (trade.strategyPnlTax && trade.strategyPnlTax[strategyName] !== undefined) {
filteredStrategyPnlTax[strategyName] = trade.strategyPnlTax[strategyName];
}
if (trade.strategyDetails && trade.strategyDetails[strategyName]) {
filteredStrategyDetails[strategyName] = trade.strategyDetails[strategyName];
}
filteredBrokerCodes[strategyName] = brokerCode;
}
});
}
filteredTrade.strategyPnls = filteredStrategyPnls;
filteredTrade.strategyPnlTax = filteredStrategyPnlTax;
filteredTrade.strategyDetails = filteredStrategyDetails;
filteredTrade.brokerCodes = filteredBrokerCodes;
return filteredTrade;
});
displayPivotData(filteredTrades);
updateMonthFilterList();
updateBrokerFilterList();
updateSummaryCards(filteredTrades);
updateStrategyFilterList();
}
function displayPivotData(trades) {
const monthlyData = {}, dailyData = {}, strategies = new Set(), monthlyTotals = {}, dailyTotals = {}, monthlyFilteredTotals = {}, dailyFilteredTotals = {}, cumulativeData = {};
let runningTotal = 0, peakTotal = 0;
const sortedTrades = [...trades].sort((a, b) => {
const dateA = a.date.split('/').reverse().join('');
const dateB = b.date.split('/').reverse().join('');
return dateA.localeCompare(dateB);
});
sortedTrades.forEach(trade => {
const dateParts = trade.date.split('/'), monthKey = `${dateParts[1]}/${dateParts[2]}`;
const dateKey = trade.date;
if (!monthlyData[monthKey]) monthlyData[monthKey] = {};
if (!dailyData[monthKey]) dailyData[monthKey] = {};
if (!dailyData[monthKey][dateKey]) dailyData[monthKey][dateKey] = {};
if (!monthlyTotals[monthKey]) monthlyTotals[monthKey] = { total: 0, net: 0, amiPnl: 0, margin: 0, pnlTax: 0 };
if (!dailyTotals[monthKey]) dailyTotals[monthKey] = {};
if (!dailyTotals[monthKey][dateKey]) dailyTotals[monthKey][dateKey] = { total: 0, net: 0, amiPnl: 0, margin: 0, pnlTax: 0 };
if (!monthlyFilteredTotals[monthKey]) monthlyFilteredTotals[monthKey] = { total: 0, net: 0, amiPnl: 0, margin: 0, pnlTax: 0 };
if (!dailyFilteredTotals[monthKey]) dailyFilteredTotals[monthKey] = {};
if (!dailyFilteredTotals[monthKey][dateKey]) dailyFilteredTotals[monthKey][dateKey] = { total: 0, net: 0, amiPnl: 0, margin: 0, pnlTax: 0 };
Object.entries(trade.strategyDetails).forEach(([stratName, details]) => {
strategies.add(stratName);
if (!monthlyData[monthKey][stratName]) {
monthlyData[monthKey][stratName] = { lot: 0, pnl: 0, dpnl: 0, net: 0, tradeCount: 0, lotSum: 0, lotCount: 0 };
}
if (!dailyData[monthKey][dateKey][stratName]) {
dailyData[monthKey][dateKey][stratName] = { lot: 0, pnl: 0, dpnl: 0, net: 0, tradeCount: 0, lotSum: 0, lotCount: 0 };
}
if (details.lot > 0) {
monthlyData[monthKey][stratName].lotSum += details.lot;
monthlyData[monthKey][stratName].lotCount += 1;
monthlyData[monthKey][stratName].tradeCount += 1;
}
monthlyData[monthKey][stratName].pnl += details.pnl;
monthlyData[monthKey][stratName].dpnl += details.dpnl;
monthlyData[monthKey][stratName].net += (trade.strategyPnlTax[stratName] || 0);
if (details.lot > 0) {
dailyData[monthKey][dateKey][stratName].lotSum += details.lot;
dailyData[monthKey][dateKey][stratName].lotCount += 1;
dailyData[monthKey][dateKey][stratName].tradeCount += 1;
}
dailyData[monthKey][dateKey][stratName].pnl += details.pnl;
dailyData[monthKey][dateKey][stratName].dpnl += details.dpnl;
dailyData[monthKey][dateKey][stratName].net += (trade.strategyPnlTax[stratName] || 0);
const isAPro = stratName.startsWith('A.PRO');
if (!isAPro) {
const netPnl = trade.strategyPnlTax[stratName] || 0;
runningTotal += netPnl;
monthlyTotals[monthKey].total += details.pnl;
monthlyTotals[monthKey].net += netPnl;
monthlyTotals[monthKey].margin += (trade.strategyMargins?.[stratName] || 0);
monthlyTotals[monthKey].pnlTax += netPnl;
dailyTotals[monthKey][dateKey].total += details.pnl;
dailyTotals[monthKey][dateKey].net += netPnl;
dailyTotals[monthKey][dateKey].margin += (trade.strategyMargins?.[stratName] || 0);
dailyTotals[monthKey][dateKey].pnlTax += netPnl;
if (!hiddenStrategies.has(stratName)) {
monthlyFilteredTotals[monthKey].total += details.pnl;
monthlyFilteredTotals[monthKey].net += netPnl;
monthlyFilteredTotals[monthKey].margin += (trade.strategyMargins?.[stratName] || 0);
monthlyFilteredTotals[monthKey].pnlTax += netPnl;
dailyFilteredTotals[monthKey][dateKey].total += details.pnl;
dailyFilteredTotals[monthKey][dateKey].net += netPnl;
dailyFilteredTotals[monthKey][dateKey].margin += (trade.strategyMargins?.[stratName] || 0);
dailyFilteredTotals[monthKey][dateKey].pnlTax += netPnl;
}
}
if (runningTotal > peakTotal) {
peakTotal = runningTotal;
}
if (!cumulativeData[monthKey]) cumulativeData[monthKey] = {};
cumulativeData[monthKey][dateKey] = {
cumTotal: runningTotal,
peak: peakTotal,
drawdown: peakTotal - runningTotal  // Now drawdown will be 0 when runningTotal == peakTotal (new high)
};
});
});
Object.keys(monthlyData).forEach(monthKey => {
const datesInMonth = Object.keys(dailyData[monthKey] || {}).sort((a, b) => {
const dateA = a.split('/').reverse().join('');
const dateB = b.split('/').reverse().join('');
return dateA.localeCompare(dateB);
});
if (datesInMonth.length > 0) {
const lastDate = datesInMonth[datesInMonth.length - 1];
if (cumulativeData[monthKey] && cumulativeData[monthKey][lastDate]) {
monthlyTotals[monthKey].cumTotal = cumulativeData[monthKey][lastDate].cumTotal;
monthlyTotals[monthKey].peak = cumulativeData[monthKey][lastDate].peak;
monthlyTotals[monthKey].drawdown = cumulativeData[monthKey][lastDate].drawdown;
monthlyFilteredTotals[monthKey].cumTotal = cumulativeData[monthKey][lastDate].cumTotal;
monthlyFilteredTotals[monthKey].peak = cumulativeData[monthKey][lastDate].peak;
monthlyFilteredTotals[monthKey].drawdown = cumulativeData[monthKey][lastDate].drawdown;
}
}
});
const aproStrategies = Array.from(strategies).filter(s => s.startsWith('A.PRO'));
Object.keys(monthlyTotals).forEach(monthKey => {
let amiPnlTotal = 0, amiPnlFiltered = 0;
const monthTrades = trades.filter(trade => {
const tradeParts = trade.date.split('/');
const tradeMonthKey = `${tradeParts[1]}/${tradeParts[2]}`;
return tradeMonthKey === monthKey;
});
const dailyMaxLots = {};
monthTrades.forEach(trade => {
const dateKey = trade.date;
if (!dailyMaxLots[dateKey]) {
dailyMaxLots[dateKey] = {};
}
if (trade.strategyDetails) {
const allBrokerStrategies = Array.from(strategies).filter(s => !s.startsWith('A.PRO'));
allBrokerStrategies.forEach(brokerStrat => {
let lotSize = trade.strategyDetails[brokerStrat]?.lot || 0;
if (lotSize > 0) {
if (!dailyMaxLots[dateKey][brokerStrat] || lotSize > dailyMaxLots[dateKey][brokerStrat]) {
dailyMaxLots[dateKey][brokerStrat] = lotSize;
}
}
});
}
});
monthTrades.forEach(trade => {
if (trade.strategyDetails) {
aproStrategies.forEach(aproStrat => {
const aproPnl = trade.strategyDetails[aproStrat]?.pnl || 0;
if (aproPnl !== 0) {
const proMatch = aproStrat.match(/PRO\s*(\d+)/i);
if (proMatch) {
const proNum = proMatch[1];
const allBrokerStrategies = Array.from(strategies).filter(s => !s.startsWith('A.PRO'));
allBrokerStrategies.forEach(brokerStrat => {
const brokerProMatch = brokerStrat.match(/PRO\s*(\d+)/i);
if (brokerProMatch && brokerProMatch[1] === proNum) {
let lotSize = trade.strategyDetails[brokerStrat]?.lot || 0;
if (lotSize === 0 && dailyMaxLots[trade.date]?.[brokerStrat]) {
lotSize = dailyMaxLots[trade.date][brokerStrat];
}
const contribution = aproPnl * lotSize;
amiPnlTotal += contribution;
if (!hiddenStrategies.has(brokerStrat)) {
let brokerCode = null;
const cleanName = brokerStrat.replace(/\s+/g, '');
const match = cleanName.match(/^(.+?)PRO/);
if (match) {
brokerCode = match[1];
}
if (!brokerCode || selectedBrokers.size === 0 || selectedBrokers.has(brokerCode)) {
amiPnlFiltered += contribution;
}
}
}
});
}
}
});
}
});
monthlyTotals[monthKey].amiPnl = amiPnlTotal;
monthlyFilteredTotals[monthKey].amiPnl = amiPnlFiltered;
Object.keys(dailyData[monthKey] || {}).forEach(dateKey => {
let dailyAmiPnl = 0, dailyAmiPnlFiltered = 0;
const dayTrades = monthTrades.filter(t => t.date === dateKey);
dayTrades.forEach(trade => {
if (trade.strategyDetails) {
aproStrategies.forEach(aproStrat => {
const aproPnl = trade.strategyDetails[aproStrat]?.pnl || 0;
if (aproPnl !== 0) {
const proMatch = aproStrat.match(/PRO\s*(\d+)/i);
if (proMatch) {
const proNum = proMatch[1];
const allBrokerStrategies = Array.from(strategies).filter(s => !s.startsWith('A.PRO'));
allBrokerStrategies.forEach(brokerStrat => {
const brokerProMatch = brokerStrat.match(/PRO\s*(\d+)/i);
if (brokerProMatch && brokerProMatch[1] === proNum) {
let lotSize = trade.strategyDetails[brokerStrat]?.lot || 0;
if (lotSize === 0 && dailyMaxLots[dateKey]?.[brokerStrat]) {
lotSize = dailyMaxLots[dateKey][brokerStrat];
}
const contribution = aproPnl * lotSize;
dailyAmiPnl += contribution;
if (!hiddenStrategies.has(brokerStrat)) {
let brokerCode = null;
const cleanName = brokerStrat.replace(/\s+/g, '');
const match = cleanName.match(/^(.+?)PRO/);
if (match) {
brokerCode = match[1];
}
if (!brokerCode || selectedBrokers.size === 0 || selectedBrokers.has(brokerCode)) {
dailyAmiPnlFiltered += contribution;
}
}
}
});
}
}
});
}
});
dailyTotals[monthKey][dateKey].amiPnl = dailyAmiPnl;
dailyFilteredTotals[monthKey][dateKey].amiPnl = dailyAmiPnlFiltered;
});
});
allStrategies = Array.from(strategies).sort((a, b) => {
const aIsAPro = a.startsWith('A.PRO');
const bIsAPro = b.startsWith('A.PRO');
if (aIsAPro && !bIsAPro) return -1;
if (!aIsAPro && bIsAPro) return 1;
if (aIsAPro && bIsAPro) {
const aNum = parseInt(a.match(/\d+/)?.[0] || '0');
const bNum = parseInt(b.match(/\d+/)?.[0] || '0');
return aNum - bNum;
}
return a.localeCompare(b);
});
if (selectedBrokers.size > 0 && allBrokers.length > 0) {
const selectedBaseStrategies = new Set();
// First pass: collect base strategies from selected brokers
allStrategies.forEach(stratName => {
if (stratName.startsWith('A.PRO')) {
return; // Skip A.PRO in first pass
}
let brokerCode = null;
const cleanName = stratName.replace(/\s+/g, '');
const match = cleanName.match(/^(.+?)PRO/);
if (match) {
brokerCode = match[1];
}
if (brokerCode && selectedBrokers.has(brokerCode)) {
let baseStrategy = stratName.replace(/^[A-Z0-9]+\s*PRO\s*/i, '').trim();
baseStrategy = baseStrategy.replace(/\s+/g, '');
if (baseStrategy) {
selectedBaseStrategies.add(baseStrategy);
}
}
});
// Second pass: filter strategies based on broker selection and matching base strategies
allStrategies = allStrategies.filter(stratName => {
if (stratName.startsWith('A.PRO')) {
// For A.PRO strategies, only show if their base strategy matches selected brokers
let baseStrategy = stratName.replace(/^A\.PRO\s*/, '').trim();
baseStrategy = baseStrategy.replace(/\s+/g, '');
return selectedBaseStrategies.has(baseStrategy);
}
let brokerCode = null;
const cleanName = stratName.replace(/\s+/g, '');
const match = cleanName.match(/^(.+?)PRO/);
if (match) {
brokerCode = match[1];
}
if (!brokerCode || !selectedBrokers.has(brokerCode)) {
return false;
}
return true;
});
// Check if all brokers are selected
const allBrokersSelected = allBrokers.every(broker => selectedBrokers.has(broker));
if (allBrokersSelected) {
// Restore saved hidden strategies when All brokers are selected
hiddenStrategies = new Set(savedHiddenStrategies);
} else {
// Clear hidden strategies temporarily when specific brokers are selected
hiddenStrategies = new Set();
}
// Update the strategy filter dropdown to reflect currently available strategies
updateStrategyFilterList();
}
const visibleStrategies = allStrategies.filter(s => !hiddenStrategies.has(s)), sortedFilteredTrades = [...trades].sort((a, b) => {
const dateA = a.date.split('/').reverse().join('');
const dateB = b.date.split('/').reverse().join('');
return dateA.localeCompare(dateB);
});
const dailyTotalMargins = calculateDailyTotalMargins(sortedFilteredTrades, Array.from(strategies));
const marginDrawdownData = calculateMarginDrawdown(dailyTotalMargins);
const dailyExpenses = calculateDailyExpenses(sortedFilteredTrades, Array.from(strategies), dailyTotalMargins);
const monthlyExpensesAndMargins = calculateExpensesAndMargins(sortedFilteredTrades, hiddenStrategies, Array.from(strategies), showFilteredTotals, dailyTotalMargins, dailyExpenses);
renderPivotTable(monthlyData, dailyData, visibleStrategies, monthlyTotals, dailyTotals, monthlyFilteredTotals, dailyFilteredTotals, cumulativeData, monthlyExpensesAndMargins, dailyTotalMargins, dailyExpenses, marginDrawdownData);
}
function calculateExpensesAndMargins(sortedTrades, hiddenStrategies, allStrategiesParam, useFilteredTotals, dailyTotalMargins, dailyExpenses) {
const result = {};
const tradesByMonth = {};
sortedTrades.forEach(trade => {
const dateParts = trade.date.split('/');
const monthKey = `${dateParts[1]}/${dateParts[2]}`;
if (!tradesByMonth[monthKey]) {
tradesByMonth[monthKey] = [];
}
tradesByMonth[monthKey].push(trade);
});
const allStrategies = allStrategiesParam;
const sortedMonths = Object.keys(tradesByMonth).sort((a, b) => {
const [monthA, yearA] = a.split('/');
const [monthB, yearB] = b.split('/');
if (yearA !== yearB) return yearA.localeCompare(yearB);
return monthA.localeCompare(monthB);
});
sortedMonths.forEach((monthKey, monthIdx) => {
const monthTrades = tradesByMonth[monthKey];
const tradesByDate = {};
monthTrades.forEach(trade => {
const dateKey = trade.date;
if (!tradesByDate[dateKey]) {
tradesByDate[dateKey] = [];
}
tradesByDate[dateKey].push(trade);
});
const sortedDatesInMonth = Object.keys(tradesByDate).sort((a, b) => {
const dayA = parseInt(a.split('/')[0]);
const dayB = parseInt(b.split('/')[0]);
return dayA - dayB;
});
let monthExpenses = 0;
sortedDatesInMonth.forEach(dateKey => {
monthExpenses += (dailyExpenses[dateKey] || 0);
});
let monthTotalMargin = 0;
if (sortedDatesInMonth.length > 0) {
const lastDate = sortedDatesInMonth[sortedDatesInMonth.length - 1];
monthTotalMargin = dailyTotalMargins[lastDate] || 0;
}
result[monthKey] = {
totalMargin: monthTotalMargin,
expenses: monthExpenses
};
});
return result;
}
function calculateDailyExpenses(sortedTrades, allStrategiesParam, dailyTotalMargins) {
const result = {};
const tradesByDate = {};
sortedTrades.forEach(trade => {
const dateKey = trade.date;
if (!tradesByDate[dateKey]) {
tradesByDate[dateKey] = [];
}
tradesByDate[dateKey].push(trade);
});
const sortedDates = Object.keys(tradesByDate).sort((a, b) => {
const dateA = a.split('/').reverse().join('');
const dateB = b.split('/').reverse().join('');
return dateA.localeCompare(dateB);
});
let startingCapital = 0;
if (sortedDates.length > 0) {
const firstDate = sortedDates[0], firstDateTrades = tradesByDate[firstDate];
const firstDateBrokerMargins = {};
const allBrokerStrategies = allStrategiesParam.filter(s => !s.startsWith('A.PRO'));
firstDateTrades.forEach(trade => {
if (trade.strategyDetails) {
allBrokerStrategies.forEach(brokerStrat => {
const margin = trade.strategyDetails[brokerStrat]?.margin || 0, cleanName = brokerStrat.replace(/\s+/g, '');
const brokerMatch = cleanName.match(/^(.+?)PRO/);
if (brokerMatch && margin > 0) {
const brokerCode = brokerMatch[1];
if (!firstDateBrokerMargins[brokerCode]) {
firstDateBrokerMargins[brokerCode] = {};
}
firstDateBrokerMargins[brokerCode][brokerStrat] = margin;
}
});
}
});
Object.keys(firstDateBrokerMargins).forEach(brokerCode => {
const margins = Object.values(firstDateBrokerMargins[brokerCode]);
if (margins.length > 0) {
startingCapital += Math.max(...margins);
}
});
}
let cumulativeNetPnl = 0;
let cumulativeCharges = 0;
sortedDates.forEach(dateKey => {
const dayTrades = tradesByDate[dateKey];
let dayNet = 0;
dayTrades.forEach(trade => {
if (trade && trade.strategyPnlTax) {
Object.entries(trade.strategyPnlTax).forEach(([stratName, pnlTax]) => {
if (!stratName.startsWith('A.PRO')) {
dayNet += pnlTax;
}
});
}
});
cumulativeNetPnl += dayNet;
const runningCapital = startingCapital + cumulativeNetPnl, totalMargin = dailyTotalMargins[dateKey] || 0;
const chargesWithdrawn = totalMargin - runningCapital - cumulativeCharges;
cumulativeCharges += chargesWithdrawn;
result[dateKey] = chargesWithdrawn;
});
return result;
}
function calculateDailyTotalMargins(sortedTrades, allStrategiesParam) {
const result = {};
const tradesByDate = {};
sortedTrades.forEach(trade => {
const dateKey = trade.date;
if (!tradesByDate[dateKey]) {
tradesByDate[dateKey] = [];
}
tradesByDate[dateKey].push(trade);
});
const sortedDates = Object.keys(tradesByDate).sort((a, b) => {
const dateA = a.split('/').reverse().join('');
const dateB = b.split('/').reverse().join('');
return dateA.localeCompare(dateB);
});
const brokerPnlTaxByDate = {};
sortedTrades.forEach(trade => {
const tradeDate = trade.date;
if (!brokerPnlTaxByDate[tradeDate]) {
brokerPnlTaxByDate[tradeDate] = {};
}
if (trade && trade.strategyPnlTax) {
Object.entries(trade.strategyPnlTax).forEach(([stratName, pnlTax]) => {
if (!stratName.startsWith('A.PRO')) {
const cleanName = stratName.replace(/\s+/g, '');
const brokerMatch = cleanName.match(/^(.+?)PRO/);
if (brokerMatch) {
const brokerCode = brokerMatch[1];
if (!brokerPnlTaxByDate[tradeDate][brokerCode]) {
brokerPnlTaxByDate[tradeDate][brokerCode] = {};
}
if (!brokerPnlTaxByDate[tradeDate][brokerCode][stratName]) {
brokerPnlTaxByDate[tradeDate][brokerCode][stratName] = 0;
}
brokerPnlTaxByDate[tradeDate][brokerCode][stratName] += pnlTax;
}
}
});
}
});
let previousDayBrokerMaxMargins = {};
const brokerMarginDates = {}; // Track which date each broker's margin comes from
sortedDates.forEach((dateKey, dateIndex) => {
const dayTrades = tradesByDate[dateKey];
const dayBrokerMargins = {};
dayTrades.forEach(trade => {
if (trade.strategyDetails) {
Object.entries(trade.strategyDetails).forEach(([stratName, details]) => {
if (!stratName.startsWith('A.PRO')) {
const margin = details.margin || 0, cleanName = stratName.replace(/\s+/g, '');
const brokerMatch = cleanName.match(/^(.+?)PRO/);
if (brokerMatch) {
const brokerCode = brokerMatch[1];
if (!dayBrokerMargins[brokerCode]) {
dayBrokerMargins[brokerCode] = {};
}
if (!dayBrokerMargins[brokerCode][stratName] || margin > dayBrokerMargins[brokerCode][stratName]) {
dayBrokerMargins[brokerCode][stratName] = margin;
}
}
}
});
}
});
const currentDayBrokerMaxMargins = {};
let dayTotalMargin = 0;
const allBrokers = new Set([...Object.keys(dayBrokerMargins), ...Object.keys(previousDayBrokerMaxMargins)]);
allBrokers.forEach(brokerCode => {
let brokerMaxMargin = 0;
let marginDate = dateKey;
if (dayBrokerMargins[brokerCode]) {
const margins = Object.values(dayBrokerMargins[brokerCode]);
if (margins.length > 0) {
brokerMaxMargin = Math.max(...margins);
}
}
if (brokerMaxMargin === 0 && previousDayBrokerMaxMargins[brokerCode]) {
brokerMaxMargin = previousDayBrokerMaxMargins[brokerCode];
marginDate = brokerMarginDates[brokerCode] || dateKey;
}
currentDayBrokerMaxMargins[brokerCode] = brokerMaxMargin;
brokerMarginDates[brokerCode] = marginDate;
dayTotalMargin += brokerMaxMargin;
});
let dayPnlTax = 0;
allBrokers.forEach(brokerCode => {
const marginDate = brokerMarginDates[brokerCode];
const marginDateIndex = sortedDates.indexOf(marginDate);
for (let i = marginDateIndex; i <= dateIndex; i++) {
const checkDate = sortedDates[i];
if (brokerPnlTaxByDate[checkDate] && brokerPnlTaxByDate[checkDate][brokerCode]) {
Object.values(brokerPnlTaxByDate[checkDate][brokerCode]).forEach(pnlTax => {
dayPnlTax += pnlTax;
});
}
}
});
result[dateKey] = dayTotalMargin + dayPnlTax;
previousDayBrokerMaxMargins = { ...currentDayBrokerMaxMargins };
});
return result;
}
function calculateMarginDrawdown(dailyTotalMargins) {
const result = {}, sortedDates = Object.keys(dailyTotalMargins).sort((a, b) => {
const dateA = a.split('/').reverse().join('');
const dateB = b.split('/').reverse().join('');
return dateA.localeCompare(dateB);
});
let peakMargin = 0;
sortedDates.forEach(dateKey => {
const currentMargin = dailyTotalMargins[dateKey] || 0;
if (currentMargin > peakMargin) {
peakMargin = currentMargin;
}
const drawdown = peakMargin - currentMargin, dateParts = dateKey.split('/');
const monthKey = `${dateParts[1]}/${dateParts[2]}`;  // Use MM/YY format
if (!result[monthKey]) {
result[monthKey] = {};
}
result[monthKey][dateKey] = {
peak: peakMargin,
current: currentMargin,
drawdown: drawdown  // Will be 0 when currentMargin == peakMargin (new high)
};
});
return result;
}
function renderPivotTable(monthlyData, dailyData, strategies, monthlyTotals, dailyTotals, monthlyFilteredTotals, dailyFilteredTotals, cumulativeData, monthlyExpensesAndMargins, dailyTotalMargins, dailyExpenses, marginDrawdownData) {
if (strategies.length === 0) {
const drawdownHeader = showDrawdown ? '<th class="number-col">DRAWDOWN</th>' : '';
const colspan = showDrawdown ? '3' : '2';
const netPnlHeaderText = showPnlTax ? 'NET PNL TAX' : 'NET PNL';
elements.tableHeaders.innerHTML = `<tr><th>Period</th><th class="number-col">${netPnlHeaderText}</th>${drawdownHeader}</tr>`;
elements.tableBody.innerHTML = `<tr><td colspan="${colspan}" class="no-data">No strategies selected. Use "Hide Strategies" filter to show strategies.</td></tr>`;
return;
}
const aproStrategies = strategies.filter(s => s.startsWith('A.PRO')), brokerStrategies = strategies.filter(s => !s.startsWith('A.PRO'));
const brokerGroups = {};
brokerStrategies.forEach(strat => {
const cleanName = strat.replace(/\s+/g, '');
const brokerMatch = cleanName.match(/^(.+?)PRO/);
if (brokerMatch) {
const brokerCode = brokerMatch[1];
if (!brokerGroups[brokerCode]) {
brokerGroups[brokerCode] = [];
}
brokerGroups[brokerCode].push(strat);
}
});
const sortedBrokers = Object.keys(brokerGroups).sort();
let headerRow1 = '<tr class="header-row-1">';
headerRow1 += '<th rowspan="2">Period</th>';
if (aproStrategies.length > 0) {
headerRow1 += `<th colspan="${aproStrategies.length}" class="number-col apro-boundary">Amibroker PNL</th>`;
}
if (showLot) {
const columnLabel = showTradeCount ? 'TRADE COUNT' : 'LOT';
sortedBrokers.forEach(brokerCode => {
const count = brokerGroups[brokerCode].length;
headerRow1 += `<th colspan="${count}" class="number-col broker-boundary">${brokerCode} ${columnLabel}</th>`;
});
}
sortedBrokers.forEach(brokerCode => {
const count = brokerGroups[brokerCode].length;
headerRow1 += `<th colspan="${count}" class="number-col broker-boundary">${brokerCode} DPNL</th>`;
});
let brokerPnlHeaderText;
if (showLotPnl) {
brokerPnlHeaderText = showPnlTax ? 'LOT PNL TAX' : 'LOT PNL';
} else {
brokerPnlHeaderText = showPnlTax ? 'PNL TAX' : 'PNL';
}
sortedBrokers.forEach(brokerCode => {
const count = brokerGroups[brokerCode].length;
headerRow1 += `<th colspan="${count}" class="number-col broker-boundary">${brokerCode} ${brokerPnlHeaderText}</th>`;
});
headerRow1 += '<th class="number-col total-net-col" rowspan="2">AMI PNL</th>';
const netPnlHeaderText = showPnlTax ? 'NET PNL TAX' : 'NET PNL';
headerRow1 += `<th class="number-col total-net-col" rowspan="2">${netPnlHeaderText}</th>`;
headerRow1 += '<th class="number-col net-pnl-percent-col" rowspan="2">NET PNL%</th>';
headerRow1 += '<th class="number-col expenses-col" rowspan="2">Expenses</th>';
headerRow1 += '<th class="number-col total-net-col" rowspan="2">TOTAL MARGIN</th>';
if (showDrawdown) {
headerRow1 += '<th class="number-col drawdown-col" rowspan="2">DRAWDOWN</th>';
}
headerRow1 += '</tr>';
let headerRow2 = '<tr class="header-row-2">';
aproStrategies.forEach((strategy, idx) => {
const displayName = formatStrategyName(strategy), stratIndex = allStrategies.indexOf(strategy);
const bgClass = `strategy-bg-${stratIndex % 5}`;
const boundaryClass = idx === aproStrategies.length - 1 ? ' apro-boundary' : '';
headerRow2 += `<th class="number-col apro-pnl-col ${bgClass}${boundaryClass}">${displayName}</th>`;
});
if (showLot) {
sortedBrokers.forEach((brokerCode, brokerIdx) => {
brokerGroups[brokerCode].forEach((strategy, idx) => {
const displayName = formatStrategyName(strategy).replace(/^[A-Z]+\d*\s*/, ''), stratIndex = allStrategies.indexOf(strategy), bgClass = `strategy-bg-${stratIndex % 5}`, isLastInBroker = idx === brokerGroups[brokerCode].length - 1;
const isLastBroker = brokerIdx === sortedBrokers.length - 1;
const boundaryClass = (isLastInBroker && isLastBroker) ? ' broker-boundary' : '';
headerRow2 += `<th class="number-col lot-col ${bgClass}${boundaryClass}">${displayName}</th>`;
});
});
}
sortedBrokers.forEach((brokerCode, brokerIdx) => {
brokerGroups[brokerCode].forEach((strategy, idx) => {
const displayName = formatStrategyName(strategy).replace(/^[A-Z]+\d*\s*/, ''), stratIndex = allStrategies.indexOf(strategy), bgClass = `strategy-bg-${stratIndex % 5}`, isLastInBroker = idx === brokerGroups[brokerCode].length - 1;
const isLastBroker = brokerIdx === sortedBrokers.length - 1;
const boundaryClass = (isLastInBroker && isLastBroker) ? ' broker-boundary' : '';
headerRow2 += `<th class="number-col ${bgClass}${boundaryClass}">${displayName}</th>`;
});
});
sortedBrokers.forEach((brokerCode, brokerIdx) => {
brokerGroups[brokerCode].forEach((strategy, idx) => {
const displayName = formatStrategyName(strategy).replace(/^[A-Z]+\d*\s*/, ''), stratIndex = allStrategies.indexOf(strategy), bgClass = `strategy-bg-${stratIndex % 5}`, isLastInBroker = idx === brokerGroups[brokerCode].length - 1;
const isLastBroker = brokerIdx === sortedBrokers.length - 1;
const boundaryClass = (isLastInBroker && isLastBroker) ? ' broker-boundary' : '';
headerRow2 += `<th class="number-col ${bgClass}${boundaryClass}">${displayName}</th>`;
});
});
headerRow2 += '</tr>';
elements.tableHeaders.innerHTML = headerRow1 + headerRow2;
const sortedMonths = Object.keys(monthlyData).sort((a, b) => {
const [monthA, yearA] = a.split('/');
const [monthB, yearB] = b.split('/');
if (yearA !== yearB) return yearA.localeCompare(yearB);
return monthA.localeCompare(monthB);
});
const totals = { strategies: {}, totalProfits: 0, netBrProfits: 0, totalAmiPnl: 0, totalExpenses: 0, totalMarginSum: 0, monthCount: 0 };
strategies.forEach(strat => {
totals.strategies[strat] = { lot: 0, pnl: 0, dpnl: 0, net: 0, tradeCount: 0, lotSum: 0, lotCount: 0 };
});
const totalsToUse = showFilteredTotals ? monthlyFilteredTotals : monthlyTotals;
Object.values(totalsToUse).forEach(monthTotal => {
totals.totalProfits += monthTotal.total;
totals.netBrProfits += monthTotal.net;
totals.totalAmiPnl += (monthTotal.amiPnl || 0);
});

// Group months by year
const monthsByYear = {};
sortedMonths.forEach(month => {
const [monthNum, year] = month.split('/');
const fullYear = year.length === 2 ? (parseInt(year) > 50 ? `19${year}` : `20${year}`) : year;
if (!monthsByYear[fullYear]) {
monthsByYear[fullYear] = [];
}
monthsByYear[fullYear].push(month);
});

const years = Object.keys(monthsByYear).sort((a, b) => a.localeCompare(b));
const hasMultipleYears = years.length > 1;

let bodyHtml = '', previousMonthTotalMargin = 0;
let monthIdx = 0;

years.forEach(year => {
const yearMonths = monthsByYear[year];
let yearFirstDateMargin = 0; // Reset for each year
// Calculate year totals for each strategy
const yearTotals = {};
strategies.forEach(strat => {
yearTotals[strat] = { pnl: 0, dpnl: 0, net: 0, lotSum: 0, lotCount: 0 };
});
yearMonths.forEach(month => {
strategies.forEach(strat => {
const stratData = monthlyData[month][strat] || { pnl: 0, dpnl: 0, net: 0, lotSum: 0, lotCount: 0 };
yearTotals[strat].pnl += stratData.pnl;
yearTotals[strat].dpnl += stratData.dpnl;
yearTotals[strat].net += stratData.net;
yearTotals[strat].lotSum += stratData.lotSum;
yearTotals[strat].lotCount += stratData.lotCount;
});
});

// Calculate year summary totals
const totalsSource = showFilteredTotals ? monthlyFilteredTotals : monthlyTotals;
let yearAmiPnl = 0, yearNetPnl = 0, yearTotalPnl = 0, yearExpenses = 0, yearTotalMargin = 0;
yearMonths.forEach((month, idx) => {
yearAmiPnl += (totalsSource[month]?.amiPnl || 0);
yearNetPnl += (totalsSource[month]?.net || 0);
yearTotalPnl += (totalsSource[month]?.total || 0);
const monthExpensesData = monthlyExpensesAndMargins[month] || { expenses: 0, totalMargin: 0 };
yearExpenses += monthExpensesData.expenses;
// For TOTAL MARGIN, use the latest (last month's) value instead of sum
if (idx === yearMonths.length - 1) {
yearTotalMargin = monthExpensesData.totalMargin;
}
});

// Add year row if multiple years
if (hasMultipleYears) {
bodyHtml += `<tr class="year-row" onclick="toggleYear(event, '${year}')">`;
bodyHtml += `<td><span class="expand-icon" id="year-icon-${year}">▶</span>${year}</td>`;

// Add APRO strategies (always show pnl)
aproStrategies.forEach((strategy, idx) => {
const pnl = yearTotals[strategy]?.pnl || 0;
const stratIndex = allStrategies.indexOf(strategy);
const bgClass = `strategy-bg-${stratIndex % 5}`;
const boundaryClass = idx === aproStrategies.length - 1 ? ' apro-boundary' : '';
bodyHtml += `<td class="number-col apro-pnl-col ${bgClass} ${pnl >= 0 ? 'positive' : 'negative'}${boundaryClass}">${formatNumber(pnl)}</td>`;
});

// Add LOT columns (if shown) - show trade count or average lot for year row
if (showLot) {
sortedBrokers.forEach((brokerCode, brokerIdx) => {
brokerGroups[brokerCode].forEach((strategy, idx) => {
const stratIndex = allStrategies.indexOf(strategy);
const bgClass = `strategy-bg-${stratIndex % 5}`;
const isLastInBroker = idx === brokerGroups[brokerCode].length - 1;
const isLastBroker = brokerIdx === sortedBrokers.length - 1;
const boundaryClass = (isLastInBroker && isLastBroker) ? ' broker-boundary' : '';
const stratData = yearTotals[strategy] || { lotSum: 0, lotCount: 0 };
let displayValue = '';
if (showTradeCount) {
displayValue = stratData.lotCount > 0 ? stratData.lotCount : '';
} else {
const avgLot = stratData.lotCount > 0 ? (stratData.lotSum / stratData.lotCount) : 0;
displayValue = avgLot > 0 ? avgLot.toFixed(2) : '';
}
bodyHtml += `<td class="number-col lot-col ${bgClass}${boundaryClass}">${displayValue}</td>`;
});
});
}

// Add DPNL section (always show dpnl)
sortedBrokers.forEach((brokerCode, brokerIdx) => {
brokerGroups[brokerCode].forEach((strategy, idx) => {
const dpnl = yearTotals[strategy]?.dpnl || 0;
const stratIndex = allStrategies.indexOf(strategy);
const bgClass = `strategy-bg-${stratIndex % 5}`;
const isLastInBroker = idx === brokerGroups[brokerCode].length - 1;
const isLastBroker = brokerIdx === sortedBrokers.length - 1;
const boundaryClass = (isLastInBroker && isLastBroker) ? ' broker-boundary' : '';
bodyHtml += `<td class="number-col dpnl-section ${bgClass} ${dpnl >= 0 ? 'positive' : 'negative'}${boundaryClass}">${formatNumber(dpnl)}</td>`;
});
});

// Add PNL section (respect showPnlTax and showLotPnl)
sortedBrokers.forEach((brokerCode, brokerIdx) => {
brokerGroups[brokerCode].forEach((strategy, idx) => {
const stratData = yearTotals[strategy] || { pnl: 0, net: 0, lotSum: 0, lotCount: 0 };
let pnl;
if (showLotPnl) {
const avgLot = stratData.lotCount > 0 ? (stratData.lotSum / stratData.lotCount) : 0;
pnl = avgLot > 0 ? (showPnlTax ? (stratData.net / avgLot) : (stratData.pnl / avgLot)) : 0;
} else {
pnl = showPnlTax ? stratData.net : stratData.pnl;
}
const stratIndex = allStrategies.indexOf(strategy);
const bgClass = `strategy-bg-${stratIndex % 5}`;
const isLastInBroker = idx === brokerGroups[brokerCode].length - 1;
const isLastBroker = brokerIdx === sortedBrokers.length - 1;
const boundaryClass = (isLastInBroker && isLastBroker) ? ' broker-boundary' : '';
bodyHtml += `<td class="number-col pnl-section ${bgClass} ${pnl >= 0 ? 'positive' : 'negative'}${boundaryClass}">${formatNumber(pnl)}</td>`;
});
});
// Add AMI PNL
bodyHtml += `<td class="number-col total-net-col ${yearAmiPnl >= 0 ? 'positive' : 'negative'}">${formatNumber(yearAmiPnl)}</td>`;
// Add NET PNL (respects showPnlTax)
const yearNetPnlValue = showPnlTax ? yearNetPnl : yearTotalPnl;
bodyHtml += `<td class="number-col total-net-col ${yearNetPnlValue >= 0 ? 'positive' : 'negative'}">${formatNumber(yearNetPnlValue)}</td>`;
// Add NET PNL% - will be calculated after first month is processed
bodyHtml += `<td class="number-col net-pnl-percent-col" id="year-net-pnl-percent-${year}"></td>`;
// Add EXPENSES
bodyHtml += `<td class="number-col expenses-col ${yearExpenses >= 0 ? 'positive' : 'negative'}">${formatNumber(yearExpenses)}</td>`;
// Add TOTAL MARGIN
bodyHtml += `<td class="number-col total-net-col ${yearTotalMargin >= 0 ? 'positive' : 'negative'}">${formatNumber(yearTotalMargin)}</td>`;
// Add DRAWDOWN (if shown) - show latest drawdown (last date of year)
if (showDrawdown) {
let yearDrawdown = 0;
// Find the last month with data
for (let i = yearMonths.length - 1; i >= 0; i--) {
const month = yearMonths[i];
if (marginDrawdownData[month]) {
// Get all dates in this month and sort them
const datesInMonth = Object.keys(marginDrawdownData[month]).sort((a, b) => {
const dateA = a.split('/').reverse().join('');
const dateB = b.split('/').reverse().join('');
return dateA.localeCompare(dateB);
});
if (datesInMonth.length > 0) {
const lastDate = datesInMonth[datesInMonth.length - 1];
yearDrawdown = marginDrawdownData[month][lastDate].drawdown || 0;
break; // Found the last date, stop searching
}
}
}
const drawdownDisplay = yearDrawdown > 0 ? `-${formatNumber(yearDrawdown)}` : formatNumber(yearDrawdown);
bodyHtml += `<td class="number-col drawdown-col negative">${drawdownDisplay}</td>`;
}
bodyHtml += '</tr>';
}

yearMonths.forEach(month => {
const [monthNum, yearPart] = month.split('/');
const fullYear = yearPart.length === 2 ? (parseInt(yearPart) > 50 ? `19${yearPart}` : `20${yearPart}`) : yearPart;
const shortYear = yearPart.slice(-2); // Get last 2 digits
const displayMonth = `${monthNames[parseInt(monthNum) - 1]}-${shortYear}`;
const dataYearAttr = hasMultipleYears ? ` data-year="${fullYear}"` : '';
const isFirstMonthOfYear = (month === yearMonths[0]);
bodyHtml += `<tr class="month-row" data-month="${month}"${dataYearAttr} onclick="toggleMonth('${month}')">`;
bodyHtml += `<td><span class="expand-icon" id="icon-${month}">▶</span>${displayMonth}</td>`;
const totalsToUse = showFilteredTotals ? monthlyFilteredTotals : monthlyTotals, monthTotal = totalsToUse[month]?.total || 0;
const monthNetTotal = totalsToUse[month]?.net || 0;
strategies.forEach((strategy) => {
const stratData = monthlyData[month][strategy] || { lot: 0, pnl: 0, dpnl: 0, net: 0, tradeCount: 0, lotSum: 0, lotCount: 0 };
const { pnl, dpnl, net, tradeCount, lotSum, lotCount } = stratData;
totals.strategies[strategy].lotSum += lotSum;
totals.strategies[strategy].lotCount += lotCount;
totals.strategies[strategy].pnl += pnl;
totals.strategies[strategy].dpnl += dpnl;
totals.strategies[strategy].net += net;
totals.strategies[strategy].tradeCount += tradeCount;
});
aproStrategies.forEach((strategy, idx) => {
const stratData = monthlyData[month][strategy] || { lot: 0, pnl: 0, dpnl: 0, net: 0, tradeCount: 0, lotSum: 0, lotCount: 0 };
let pnl = stratData.pnl, stratIndex = allStrategies.indexOf(strategy);
const bgClass = `strategy-bg-${stratIndex % 5}`;
const boundaryClass = idx === aproStrategies.length - 1 ? ' apro-boundary' : '';
bodyHtml += `<td class="number-col apro-pnl-col ${bgClass} ${pnl >= 0 ? 'positive' : 'negative'}${boundaryClass}">${formatNumber(pnl)}</td>`;
});
if (showLot) {
sortedBrokers.forEach((brokerCode, brokerIdx) => {
brokerGroups[brokerCode].forEach((strategy, idx) => {
const stratData = monthlyData[month][strategy] || { lot: 0, pnl: 0, dpnl: 0, net: 0, tradeCount: 0, lotSum: 0, lotCount: 0 };
const { tradeCount, lotSum, lotCount } = stratData, lot = lotCount > 0 ? lotSum / lotCount : 0, stratIndex = allStrategies.indexOf(strategy), bgClass = `strategy-bg-${stratIndex % 5}`, isLastInBroker = idx === brokerGroups[brokerCode].length - 1;
const isLastBroker = brokerIdx === sortedBrokers.length - 1;
const boundaryClass = (isLastInBroker && isLastBroker) ? ' broker-boundary' : '';
const displayValue = showTradeCount ? (tradeCount > 0 ? tradeCount : '') : (lot > 0 ? lot.toFixed(2) : '');
bodyHtml += `<td class="number-col lot-col ${bgClass}${boundaryClass}">${displayValue}</td>`;
});
});
}
sortedBrokers.forEach((brokerCode, brokerIdx) => {
brokerGroups[brokerCode].forEach((strategy, idx) => {
const stratData = monthlyData[month][strategy] || { lot: 0, pnl: 0, dpnl: 0, net: 0, tradeCount: 0, lotSum: 0, lotCount: 0 };
const dpnl = stratData.dpnl, stratIndex = allStrategies.indexOf(strategy), bgClass = `strategy-bg-${stratIndex % 5}`, isLastInBroker = idx === brokerGroups[brokerCode].length - 1;
const isLastBroker = brokerIdx === sortedBrokers.length - 1;
const boundaryClass = (isLastInBroker && isLastBroker) ? ' broker-boundary' : '';
bodyHtml += `<td class="number-col dpnl-section ${bgClass} ${dpnl >= 0 ? 'positive' : 'negative'}${boundaryClass}">${formatNumber(dpnl)}</td>`;
});
});
sortedBrokers.forEach((brokerCode, brokerIdx) => {
brokerGroups[brokerCode].forEach((strategy, idx) => {
const stratData = monthlyData[month][strategy] || { lot: 0, pnl: 0, dpnl: 0, net: 0, tradeCount: 0, lotSum: 0, lotCount: 0 };
let pnl;
if (showLotPnl) {
const avgLot = stratData.lotCount > 0 ? (stratData.lotSum / stratData.lotCount) : 0;
pnl = avgLot > 0 ? (showPnlTax ? (stratData.net / avgLot) : (stratData.pnl / avgLot)) : 0;
} else {
pnl = showPnlTax ? stratData.net : stratData.pnl;
}
const stratIndex = allStrategies.indexOf(strategy), bgClass = `strategy-bg-${stratIndex % 5}`, isLastInBroker = idx === brokerGroups[brokerCode].length - 1;
const isLastBroker = brokerIdx === sortedBrokers.length - 1;
const boundaryClass = (isLastInBroker && isLastBroker) ? ' broker-boundary' : '';
bodyHtml += `<td class="number-col pnl-section ${bgClass} ${pnl >= 0 ? 'positive' : 'negative'}${boundaryClass}">${formatNumber(pnl)}</td>`;
});
});
const monthAmiPnl = totalsToUse[month]?.amiPnl || 0;
bodyHtml += `<td class="number-col total-net-col ${monthAmiPnl >= 0 ? 'positive' : 'negative'}">${formatNumber(monthAmiPnl)}</td>`;
const netPnlValue = showPnlTax ? monthNetTotal : monthTotal;
bodyHtml += `<td class="number-col total-net-col ${netPnlValue >= 0 ? 'positive' : 'negative'}">${formatNumber(netPnlValue)}</td>`;
let netPnlPercent = 0;
if (monthIdx === 0 || isFirstMonthOfYear) {
const monthTrades = allTrades.filter(trade => {
const tradeParts = trade.date.split('/');
const tradeMonthKey = `${tradeParts[1]}/${tradeParts[2]}`;
return tradeMonthKey === month;
});
if (monthTrades.length > 0) {
// Group trades by broker and date to find first trading date per broker
const allBrokerStrategies = allStrategies.filter(s => !s.startsWith('A.PRO'));
const brokerFirstDateMargins = {}; // {brokerCode: {strategy: margin}}

// For each broker, find their first trading date and extract margins
const brokerDates = {}; // {brokerCode: [dates]}
monthTrades.forEach(trade => {
if (trade.strategyDetails) {
allBrokerStrategies.forEach(brokerStrat => {
const margin = trade.strategyDetails[brokerStrat]?.margin || 0;
const cleanName = brokerStrat.replace(/\s+/g, '');
const brokerMatch = cleanName.match(/^(.+?)PRO/);
if (brokerMatch && margin > 0) {
const brokerCode = brokerMatch[1];
if (!brokerDates[brokerCode]) {
brokerDates[brokerCode] = [];
}
if (!brokerDates[brokerCode].includes(trade.date)) {
brokerDates[brokerCode].push(trade.date);
}
}
});
}
});

// For each broker, find their first date and extract margins from that date
Object.keys(brokerDates).forEach(brokerCode => {
const dates = brokerDates[brokerCode].sort((a, b) => {
const dayA = parseInt(a.split('/')[0]);
const dayB = parseInt(b.split('/')[0]);
return dayA - dayB;
});
const brokerFirstDate = dates[0];

// Get all trades from this broker's first date
const brokerFirstDateTrades = monthTrades.filter(t => t.date === brokerFirstDate);
brokerFirstDateMargins[brokerCode] = {};

brokerFirstDateTrades.forEach(trade => {
if (trade.strategyDetails) {
allBrokerStrategies.forEach(brokerStrat => {
const cleanName = brokerStrat.replace(/\s+/g, '');
const brokerMatch = cleanName.match(/^(.+?)PRO/);
if (brokerMatch && brokerMatch[1] === brokerCode) {
const margin = trade.strategyDetails[brokerStrat]?.margin || 0;
if (margin > 0) {
brokerFirstDateMargins[brokerCode][brokerStrat] = margin;
}
}
});
}
});
});

// Calculate total margin: MAX per broker from their first trading date
let firstDateMargin = 0;
Object.keys(brokerFirstDateMargins).forEach(brokerCode => {
const margins = Object.values(brokerFirstDateMargins[brokerCode]);
if (margins.length > 0) {
firstDateMargin += Math.max(...margins);
}
});

const firstDateTotalMargin = firstDateMargin; // Use margin only, without PNL Tax
if (isFirstMonthOfYear) {
yearFirstDateMargin = firstDateTotalMargin; // Store for year NET PNL% calculation
}
if (firstDateTotalMargin !== 0) {
netPnlPercent = (netPnlValue / firstDateTotalMargin) * 100;
}
}
} else if (previousMonthTotalMargin === 0) {
netPnlPercent = 0;
} else {
netPnlPercent = (netPnlValue / previousMonthTotalMargin) * 100;
}
bodyHtml += `<td class="number-col net-pnl-percent-col ${netPnlPercent >= 0 ? 'positive' : 'negative'}">${netPnlPercent !== 0 ? netPnlPercent.toFixed(2) + '%' : ''}</td>`;
const monthExpensesData = monthlyExpensesAndMargins[month] || { expenses: 0, totalMargin: 0 };
const expenses = monthExpensesData.expenses;
const totalMargin = monthExpensesData.totalMargin;
totals.totalExpenses += expenses;
totals.totalMarginSum += totalMargin;
totals.monthCount += 1;
globalLastTotalMargin = totalMargin;
bodyHtml += `<td class="number-col expenses-col ${expenses >= 0 ? 'positive' : 'negative'}">${formatNumber(expenses)}</td>`;
bodyHtml += `<td class="number-col total-net-col ${totalMargin >= 0 ? 'positive' : 'negative'}">${formatNumber(totalMargin)}</td>`;
if (showDrawdown) {
const datesInMonth = Object.keys(dailyData[month] || {}).sort((a, b) => {
const dateA = a.split('/').reverse().join('');
const dateB = b.split('/').reverse().join('');
return dateA.localeCompare(dateB);
});
let monthDrawdown = 0;
if (datesInMonth.length > 0) {
const lastDate = datesInMonth[datesInMonth.length - 1];
monthDrawdown = (marginDrawdownData[month] && marginDrawdownData[month][lastDate]) ? marginDrawdownData[month][lastDate].drawdown : 0;
}
const drawdownDisplay = monthDrawdown > 0 ? `-${formatNumber(monthDrawdown)}` : formatNumber(monthDrawdown);
bodyHtml += `<td class="number-col drawdown-col negative">${drawdownDisplay}</td>`;
}
bodyHtml += '</tr>';
previousMonthTotalMargin = totalMargin;
if (dailyData[month]) {
const sortedDays = Object.keys(dailyData[month]).sort((a, b) => {
const dateA = a.split('/').reverse().join('');
const dateB = b.split('/').reverse().join('');
return dateA.localeCompare(dateB);
});
let previousDayMargin = previousMonthTotalMargin; // Initialize with month's starting margin
sortedDays.forEach((date, dayIndex) => {
const dateParts = date.split('/');
const displayDate = `${dateParts[0]}-${monthNames[parseInt(dateParts[1]) - 1]}`;
const dataYearAttr = hasMultipleYears ? ` data-year="${fullYear}"` : '';
bodyHtml += `<tr class="day-row" data-month="${month}"${dataYearAttr}><td>${displayDate}</td>`;
const totalsToUse = showFilteredTotals ? dailyFilteredTotals : dailyTotals, dayTotal = totalsToUse[month][date]?.total || 0;
const dayNetTotal = totalsToUse[month][date]?.net || 0;
aproStrategies.forEach((strategy, idx) => {
const stratData = dailyData[month][date][strategy] || { lot: 0, pnl: 0, dpnl: 0, net: 0, tradeCount: 0, lotSum: 0, lotCount: 0 };
let pnl = stratData.pnl, stratIndex = allStrategies.indexOf(strategy);
const bgClass = `strategy-bg-${stratIndex % 5}`;
const boundaryClass = idx === aproStrategies.length - 1 ? ' apro-boundary' : '';
bodyHtml += `<td class="number-col apro-pnl-col ${bgClass} ${pnl >= 0 ? 'positive' : 'negative'}${boundaryClass}">${formatNumber(pnl)}</td>`;
});
if (showLot) {
sortedBrokers.forEach((brokerCode, brokerIdx) => {
brokerGroups[brokerCode].forEach((strategy, idx) => {
const stratData = dailyData[month][date][strategy] || { lot: 0, pnl: 0, dpnl: 0, net: 0, tradeCount: 0, lotSum: 0, lotCount: 0 };
const { tradeCount, lotSum, lotCount } = stratData, lot = lotCount > 0 ? lotSum / lotCount : 0, stratIndex = allStrategies.indexOf(strategy), bgClass = `strategy-bg-${stratIndex % 5}`, isLastInBroker = idx === brokerGroups[brokerCode].length - 1;
const isLastBroker = brokerIdx === sortedBrokers.length - 1;
const boundaryClass = (isLastInBroker && isLastBroker) ? ' broker-boundary' : '';
const displayValue = showTradeCount ? (tradeCount > 0 ? tradeCount : '') : (lot > 0 ? lot.toFixed(2) : '');
bodyHtml += `<td class="number-col lot-col ${bgClass}${boundaryClass}">${displayValue}</td>`;
});
});
}
sortedBrokers.forEach((brokerCode, brokerIdx) => {
brokerGroups[brokerCode].forEach((strategy, idx) => {
const stratData = dailyData[month][date][strategy] || { lot: 0, pnl: 0, dpnl: 0, net: 0, tradeCount: 0, lotSum: 0, lotCount: 0 };
const dpnl = stratData.dpnl, stratIndex = allStrategies.indexOf(strategy), bgClass = `strategy-bg-${stratIndex % 5}`, isLastInBroker = idx === brokerGroups[brokerCode].length - 1;
const isLastBroker = brokerIdx === sortedBrokers.length - 1;
const boundaryClass = (isLastInBroker && isLastBroker) ? ' broker-boundary' : '';
bodyHtml += `<td class="number-col dpnl-section ${bgClass} ${dpnl >= 0 ? 'positive' : 'negative'}${boundaryClass}">${formatNumber(dpnl)}</td>`;
});
});
sortedBrokers.forEach((brokerCode, brokerIdx) => {
brokerGroups[brokerCode].forEach((strategy, idx) => {
const stratData = dailyData[month][date][strategy] || { lot: 0, pnl: 0, dpnl: 0, net: 0, tradeCount: 0, lotSum: 0, lotCount: 0 };
let pnl;
if (showLotPnl) {
const avgLot = stratData.lotCount > 0 ? (stratData.lotSum / stratData.lotCount) : 0;
pnl = avgLot > 0 ? (showPnlTax ? (stratData.net / avgLot) : (stratData.pnl / avgLot)) : 0;
} else {
pnl = showPnlTax ? stratData.net : stratData.pnl;
}
const stratIndex = allStrategies.indexOf(strategy), bgClass = `strategy-bg-${stratIndex % 5}`, isLastInBroker = idx === brokerGroups[brokerCode].length - 1;
const isLastBroker = brokerIdx === sortedBrokers.length - 1;
const boundaryClass = (isLastInBroker && isLastBroker) ? ' broker-boundary' : '';
bodyHtml += `<td class="number-col pnl-section ${bgClass} ${pnl >= 0 ? 'positive' : 'negative'}${boundaryClass}">${formatNumber(pnl)}</td>`;
});
});
const dayAmiPnl = totalsToUse[month][date]?.amiPnl || 0;
bodyHtml += `<td class="number-col total-net-col ${dayAmiPnl >= 0 ? 'positive' : 'negative'}">${formatNumber(dayAmiPnl)}</td>`;
const dayNetPnlValue = showPnlTax ? dayNetTotal : dayTotal;
bodyHtml += `<td class="number-col total-net-col ${dayNetPnlValue >= 0 ? 'positive' : 'negative'}">${formatNumber(dayNetPnlValue)}</td>`;
let dayNetPnlPercent = 0;
// For the first day of the first month, calculate starting capital from first date trades
if ((monthIdx === 0 || isFirstMonthOfYear) && dayIndex === 0) {
// Calculate starting capital from first date trades
let firstDayStartingCapital = 0;
const firstDayTrades = allTrades.filter(t => t.date === date);
const firstDateBrokerMargins = {};
const allBrokerStrategies = allStrategies.filter(s => !s.startsWith('A.PRO'));
firstDayTrades.forEach(trade => {
if (trade.strategyDetails) {
allBrokerStrategies.forEach(brokerStrat => {
const margin = trade.strategyDetails[brokerStrat]?.margin || 0;
const cleanName = brokerStrat.replace(/\s+/g, '');
const brokerMatch = cleanName.match(/^(.+?)PRO/);
if (brokerMatch && margin > 0) {
const brokerCode = brokerMatch[1];
if (!firstDateBrokerMargins[brokerCode]) {
firstDateBrokerMargins[brokerCode] = {};
}
firstDateBrokerMargins[brokerCode][brokerStrat] = margin;
}
});
}
});
Object.keys(firstDateBrokerMargins).forEach(brokerCode => {
const margins = Object.values(firstDateBrokerMargins[brokerCode]);
if (margins.length > 0) {
firstDayStartingCapital += Math.max(...margins);
}
});
if (firstDayStartingCapital !== 0) {
dayNetPnlPercent = (dayNetPnlValue / firstDayStartingCapital) * 100;
}
} else if (previousDayMargin !== 0) {
dayNetPnlPercent = (dayNetPnlValue / previousDayMargin) * 100;
}
bodyHtml += `<td class="number-col net-pnl-percent-col ${dayNetPnlPercent >= 0 ? 'positive' : 'negative'}">${dayNetPnlPercent !== 0 ? dayNetPnlPercent.toFixed(2) + '%' : ''}</td>`;
const dayExpense = dailyExpenses[date] || 0;
const dayTotalMargin = dailyTotalMargins[date] || 0;
bodyHtml += `<td class="number-col expenses-col ${dayExpense >= 0 ? 'positive' : 'negative'}">${formatNumber(dayExpense)}</td>`;
bodyHtml += `<td class="number-col total-net-col ${dayTotalMargin >= 0 ? 'positive' : 'negative'}">${dayTotalMargin > 0 ? formatNumber(dayTotalMargin) : ''}</td>`;
if (showDrawdown) {
const dayMarginDrawdown = (marginDrawdownData[month] && marginDrawdownData[month][date]) ? marginDrawdownData[month][date].drawdown : 0;
const drawdownDisplay = dayMarginDrawdown > 0 ? `-${formatNumber(dayMarginDrawdown)}` : formatNumber(dayMarginDrawdown);
bodyHtml += `<td class="number-col drawdown-col negative">${drawdownDisplay}</td>`;
}
bodyHtml += '</tr>';
// Update previousDayMargin for the next day
previousDayMargin = dayTotalMargin;
});
}
monthIdx++;
}); // Close yearMonths.forEach

// After processing all months, calculate and update year NET PNL%
if (hasMultipleYears && yearFirstDateMargin !== 0) {
const yearNetPnlValue = showPnlTax ? yearNetPnl : yearTotalPnl;
const yearNetPnlPercent = (yearNetPnlValue / yearFirstDateMargin) * 100;
// Will update via DOM after table is rendered
setTimeout(() => {
const cell = document.getElementById(`year-net-pnl-percent-${year}`);
if (cell) {
cell.textContent = yearNetPnlPercent !== 0 ? yearNetPnlPercent.toFixed(2) + '%' : '';
cell.className = `number-col net-pnl-percent-col ${yearNetPnlPercent >= 0 ? 'positive' : 'negative'}`;
}
}, 0);
}

}); // Close years.forEach
const totalBrokerStrategies = Array.from(strategies).filter(s => !s.startsWith('A.PRO'));
const totalBrokerGroups = {};
totalBrokerStrategies.forEach(strat => {
const cleanName = strat.replace(/\s+/g, '');
const brokerMatch = cleanName.match(/^(.+?)PRO/);
if (brokerMatch) {
const brokerCode = brokerMatch[1];
if (!totalBrokerGroups[brokerCode]) {
totalBrokerGroups[brokerCode] = [];
}
totalBrokerGroups[brokerCode].push(strat);
}
});
const totalSortedBrokers = Object.keys(totalBrokerGroups).sort();
bodyHtml += '<tr class="total-row"><td>Grand Total</td>';
aproStrategies.forEach((strategy, idx) => {
const stratTotal = totals.strategies[strategy], stratIndex = allStrategies.indexOf(strategy);
const bgClass = `strategy-bg-${stratIndex % 5}`;
const boundaryClass = idx === aproStrategies.length - 1 ? ' apro-boundary' : '';
bodyHtml += `<td class="number-col apro-pnl-col ${bgClass} ${stratTotal.pnl >= 0 ? 'positive' : 'negative'}${boundaryClass}">${formatNumber(stratTotal.pnl)}</td>`;
});
if (showLot) {
totalSortedBrokers.forEach((brokerCode, brokerIdx) => {
totalBrokerGroups[brokerCode].forEach((strategy, idx) => {
const stratTotal = totals.strategies[strategy];
const lot = stratTotal.lotCount > 0 ? stratTotal.lotSum / stratTotal.lotCount : 0;
const stratIndex = allStrategies.indexOf(strategy), bgClass = `strategy-bg-${stratIndex % 5}`, isLastInBroker = idx === totalBrokerGroups[brokerCode].length - 1;
const isLastBroker = brokerIdx === totalSortedBrokers.length - 1;
const boundaryClass = (isLastInBroker && isLastBroker) ? ' broker-boundary' : '';
const displayValue = showTradeCount ? (stratTotal.tradeCount > 0 ? stratTotal.tradeCount : '') : (lot > 0 ? lot.toFixed(2) : '');
bodyHtml += `<td class="number-col lot-col ${bgClass}${boundaryClass}">${displayValue}</td>`;
});
});
}
totalSortedBrokers.forEach((brokerCode, brokerIdx) => {
totalBrokerGroups[brokerCode].forEach((strategy, idx) => {
const stratTotal = totals.strategies[strategy], stratIndex = allStrategies.indexOf(strategy), bgClass = `strategy-bg-${stratIndex % 5}`, isLastInBroker = idx === totalBrokerGroups[brokerCode].length - 1;
const isLastBroker = brokerIdx === totalSortedBrokers.length - 1;
const boundaryClass = (isLastInBroker && isLastBroker) ? ' broker-boundary' : '';
bodyHtml += `<td class="number-col dpnl-section ${bgClass} ${stratTotal.dpnl >= 0 ? 'positive' : 'negative'}${boundaryClass}">${formatNumber(stratTotal.dpnl)}</td>`;
});
});
totalSortedBrokers.forEach((brokerCode, brokerIdx) => {
totalBrokerGroups[brokerCode].forEach((strategy, idx) => {
const stratTotal = totals.strategies[strategy];
let pnlValue;
if (showLotPnl) {
const avgLot = stratTotal.lotCount > 0 ? (stratTotal.lotSum / stratTotal.lotCount) : 0;
pnlValue = avgLot > 0 ? (showPnlTax ? (stratTotal.net / avgLot) : (stratTotal.pnl / avgLot)) : 0;
} else {
pnlValue = showPnlTax ? stratTotal.net : stratTotal.pnl;
}
const stratIndex = allStrategies.indexOf(strategy), bgClass = `strategy-bg-${stratIndex % 5}`, isLastInBroker = idx === totalBrokerGroups[brokerCode].length - 1;
const isLastBroker = brokerIdx === totalSortedBrokers.length - 1;
const boundaryClass = (isLastInBroker && isLastBroker) ? ' broker-boundary' : '';
bodyHtml += `<td class="number-col pnl-section ${bgClass} ${pnlValue >= 0 ? 'positive' : 'negative'}${boundaryClass}">${formatNumber(pnlValue)}</td>`;
});
});
bodyHtml += `<td class="number-col total-net-col ${totals.totalAmiPnl >= 0 ? 'positive' : 'negative'}">${formatNumber(totals.totalAmiPnl)}</td>`;
const totalNetPnlValue = showPnlTax ? totals.netBrProfits : totals.totalProfits;
bodyHtml += `<td class="number-col total-net-col ${totalNetPnlValue >= 0 ? 'positive' : 'negative'}">${formatNumber(totalNetPnlValue)}</td>`;
const totalNetPnlPercent = globalLastTotalMargin !== 0 ? (totalNetPnlValue / globalLastTotalMargin) * 100 : 0;
bodyHtml += `<td class="number-col net-pnl-percent-col ${totalNetPnlPercent >= 0 ? 'positive' : 'negative'}">${totalNetPnlPercent !== 0 ? totalNetPnlPercent.toFixed(2) + '%' : ''}</td>`;
bodyHtml += `<td class="number-col expenses-col ${totals.totalExpenses >= 0 ? 'positive' : 'negative'}">${formatNumber(totals.totalExpenses)}</td>`;
bodyHtml += `<td class="number-col total-net-col ${globalLastTotalMargin >= 0 ? 'positive' : 'negative'}">${formatNumber(globalLastTotalMargin)}</td>`;
if (showDrawdown) {
bodyHtml += `<td class="number-col drawdown-col"></td>`;
}
bodyHtml += '</tr>';
elements.tableBody.innerHTML = bodyHtml;
// Mobile Safari fix after render
if (/iPhone|iPad|iPod/.test(navigator.userAgent) || (navigator.userAgent.includes('Safari') && !navigator.userAgent.includes('Chrome'))) {
  elements.tableBody.style.display = 'table-row-group';
  elements.tableBody.style.visibility = 'visible';
  elements.tableBody.offsetHeight; // Force reflow
}
globalTotalExpenses = totals.totalExpenses;
// Restore previously expanded months
restoreExpandState();
}
function toggleMonth(month) {
const dayRows = document.querySelectorAll(`.day-row[data-month="${month}"]`);
const icon = document.getElementById(`icon-${month}`);
const isExpanded = icon?.classList.contains('expanded');
dayRows.forEach(row => row.classList.toggle('expanded'));
if (icon) icon.classList.toggle('expanded');
// Save expand state to localStorage
saveExpandState(month, !isExpanded);
}
function toggleYear(event, year) {
if (event) event.stopPropagation();
const monthRows = document.querySelectorAll(`.month-row[data-year="${year}"]`);
const dayRows = document.querySelectorAll(`.day-row[data-year="${year}"]`);
const icon = document.getElementById(`year-icon-${year}`);
const isExpanded = icon?.classList.contains('expanded');
monthRows.forEach(row => row.classList.toggle('expanded'));
dayRows.forEach(row => row.classList.remove('expanded'));
if (icon) icon.classList.toggle('expanded');
// Collapse all month icons in this year when collapsing year
if (isExpanded) {
monthRows.forEach(row => {
const monthIcon = row.querySelector('.expand-icon');
if (monthIcon) monthIcon.classList.remove('expanded');
});
}
// Save year expand state to localStorage
saveYearExpandState(year, !isExpanded);
}
function expandAll() {
document.querySelectorAll('.day-row').forEach(row => row.classList.add('expanded'));
document.querySelectorAll('.month-row').forEach(row => row.classList.add('expanded'));
document.querySelectorAll('.expand-icon').forEach(icon => icon.classList.add('expanded'));
// Save all months and years as expanded
const expandedMonths = new Set();
const expandedYears = new Set();
document.querySelectorAll('.expand-icon').forEach(icon => {
if (icon.id.startsWith('year-icon-')) {
const year = icon.id.replace('year-icon-', '');
expandedYears.add(year);
} else if (icon.id.startsWith('icon-')) {
const monthKey = icon.id.replace('icon-', '');
expandedMonths.add(monthKey);
}
});
localStorage.setItem('strategyPerformance_expandedMonths', JSON.stringify(Array.from(expandedMonths)));
localStorage.setItem('strategyPerformance_expandedYears', JSON.stringify(Array.from(expandedYears)));
}
function collapseAll() {
document.querySelectorAll('.day-row').forEach(row => row.classList.remove('expanded'));
document.querySelectorAll('.month-row').forEach(row => row.classList.remove('expanded'));
document.querySelectorAll('.expand-icon').forEach(icon => icon.classList.remove('expanded'));
// Clear all expanded months and years
localStorage.setItem('strategyPerformance_expandedMonths', JSON.stringify([]));
localStorage.setItem('strategyPerformance_expandedYears', JSON.stringify([]));
}
function saveExpandState(month, isExpanded) {
try {
const saved = localStorage.getItem('strategyPerformance_expandedMonths');
const expandedMonths = saved ? new Set(JSON.parse(saved)) : new Set();
if (isExpanded) {
expandedMonths.add(month);
} else {
expandedMonths.delete(month);
}
localStorage.setItem('strategyPerformance_expandedMonths', JSON.stringify(Array.from(expandedMonths)));
} catch (e) {
console.warn('Failed to save expand state:', e);
}
}
function saveYearExpandState(year, isExpanded) {
try {
const saved = localStorage.getItem('strategyPerformance_expandedYears');
const expandedYears = saved ? new Set(JSON.parse(saved)) : new Set();
if (isExpanded) {
expandedYears.add(year);
} else {
expandedYears.delete(year);
}
localStorage.setItem('strategyPerformance_expandedYears', JSON.stringify(Array.from(expandedYears)));
} catch (e) {
console.warn('Failed to save year expand state:', e);
}
}
function restoreExpandState() {
try {
// Restore expanded years first
const savedYears = localStorage.getItem('strategyPerformance_expandedYears');
const expandedYears = savedYears ? new Set(JSON.parse(savedYears)) : new Set();
if (savedYears) {
expandedYears.forEach(year => {
const monthRows = document.querySelectorAll(`.month-row[data-year="${year}"]`);
const icon = document.getElementById(`year-icon-${year}`);
monthRows.forEach(row => row.classList.add('expanded'));
if (icon) icon.classList.add('expanded');
});
}
// Then restore expanded months - but only if their parent year is expanded
const saved = localStorage.getItem('strategyPerformance_expandedMonths');
if (saved) {
const expandedMonths = new Set(JSON.parse(saved));
expandedMonths.forEach(month => {
// Extract year from month (format: MM/YY or MM/YYYY)
const [monthNum, yearPart] = month.split('/');
const fullYear = yearPart.length === 2 ? (parseInt(yearPart) > 50 ? `19${yearPart}` : `20${yearPart}`) : yearPart;
// Only restore if parent year is expanded (or if no multi-year scenario)
const monthRow = document.querySelector(`.month-row[data-month="${month}"]`);
const hasDataYear = monthRow && monthRow.hasAttribute('data-year');
if (!hasDataYear || expandedYears.has(fullYear)) {
const dayRows = document.querySelectorAll(`.day-row[data-month="${month}"]`);
const icon = document.getElementById(`icon-${month}`);
dayRows.forEach(row => row.classList.add('expanded'));
if (icon) icon.classList.add('expanded');
}
});
}
} catch (e) {
console.warn('Failed to restore expand state:', e);
}
}
function updateSummaryCards(trades) {
const allMonthlyProfits = {}, allMonthlyNetProfits = {}, strategyTracking = {};
let runningCumTotal = 0, peakCumTotal = 0, currentDrawdown = 0;
const sortedAllTrades = [...trades].sort((a, b) => {
const dateA = a.date.split('/').reverse().join('');
const dateB = b.date.split('/').reverse().join('');
return dateA.localeCompare(dateB);
});
globalStartingCapital = 0;
if (sortedAllTrades.length > 0) {
const tradesByMonth = {};
sortedAllTrades.forEach(trade => {
const dateParts = trade.date.split('/');
const monthKey = `${dateParts[1]}/${dateParts[2]}`;
if (!tradesByMonth[monthKey]) {
tradesByMonth[monthKey] = [];
}
tradesByMonth[monthKey].push(trade);
});
const sortedMonths = Object.keys(tradesByMonth).sort((a, b) => {
const [monthA, yearA] = a.split('/');
const [monthB, yearB] = b.split('/');
if (yearA !== yearB) return yearA.localeCompare(yearB);
return monthA.localeCompare(monthB);
});
if (sortedMonths.length > 0) {
const firstMonth = sortedMonths[0], firstMonthTrades = tradesByMonth[firstMonth];
const tradesByDate = {};
firstMonthTrades.forEach(trade => {
const dateKey = trade.date;
if (!tradesByDate[dateKey]) {
tradesByDate[dateKey] = [];
}
tradesByDate[dateKey].push(trade);
});
const sortedDatesInMonth = Object.keys(tradesByDate).sort((a, b) => {
const dayA = parseInt(a.split('/')[0]);
const dayB = parseInt(b.split('/')[0]);
return dayA - dayB;
});
if (sortedDatesInMonth.length > 0) {
const firstDate = sortedDatesInMonth[0], firstDateTrades = tradesByDate[firstDate], firstDateBrokerMargins = {};
const allBrokerStrategies = allStrategies.filter(s => !s.startsWith('A.PRO'));
firstDateTrades.forEach(trade => {
if (trade.strategyDetails) {
allBrokerStrategies.forEach(brokerStrat => {
const margin = trade.strategyDetails[brokerStrat]?.margin || 0, cleanName = brokerStrat.replace(/\s+/g, '');
const brokerMatch = cleanName.match(/^(.+?)PRO/);
if (brokerMatch && margin > 0) {
const brokerCode = brokerMatch[1];
if (!firstDateBrokerMargins[brokerCode]) {
firstDateBrokerMargins[brokerCode] = {};
}
firstDateBrokerMargins[brokerCode][brokerStrat] = margin;
}
});
}
});
Object.keys(firstDateBrokerMargins).forEach(brokerCode => {
const margins = Object.values(firstDateBrokerMargins[brokerCode]);
if (margins.length > 0) {
globalStartingCapital += Math.max(...margins);
}
});
}
}
}
sortedAllTrades.forEach(trade => {
const monthKey = trade.date.split('/')[1];
if (!allMonthlyProfits[monthKey]) allMonthlyProfits[monthKey] = 0;
if (!allMonthlyNetProfits[monthKey]) allMonthlyNetProfits[monthKey] = 0;
Object.entries(trade.strategyDetails).forEach(([stratName, details]) => {
if (!stratName.startsWith('A.PRO')) {
const netPnl = trade.strategyPnlTax[stratName] || 0;
allMonthlyProfits[monthKey] += (trade.strategyPnls[stratName] || 0);
allMonthlyNetProfits[monthKey] += netPnl;
runningCumTotal += netPnl;
if (runningCumTotal > peakCumTotal) peakCumTotal = runningCumTotal;
if (!strategyTracking[stratName]) {
strategyTracking[stratName] = { cumTotal: 0, peak: 0, drawdown: 0 };
}
strategyTracking[stratName].cumTotal += netPnl;
if (strategyTracking[stratName].cumTotal > strategyTracking[stratName].peak) {
strategyTracking[stratName].peak = strategyTracking[stratName].cumTotal;
}
strategyTracking[stratName].drawdown = strategyTracking[stratName].peak - strategyTracking[stratName].cumTotal;
}
});
});
currentDrawdown = peakCumTotal - runningCumTotal;
const totalProfitAll = Object.values(allMonthlyProfits).reduce((sum, val) => sum + val, 0);
const netBrProfitAll = Object.values(allMonthlyNetProfits).reduce((sum, val) => sum + val, 0);
if (elements.startingCapital) {
elements.startingCapital.textContent = globalStartingCapital > 0 ? '₹' + globalStartingCapital.toLocaleString('en-IN', {maximumFractionDigits: 0}) : '-';
elements.startingCapital.className = 'summary-card-value';
}
if (elements.runningProfit) {
if (globalStartingCapital > 0 && netBrProfitAll !== 0) {
const profitPercent = (netBrProfitAll / globalStartingCapital) * 100;
elements.runningProfit.textContent = profitPercent.toFixed(2) + '%';
elements.runningProfit.className = `summary-card-value ${profitPercent >= 0 ? 'positive' : 'negative'}`;
} else {
elements.runningProfit.textContent = '-';
elements.runningProfit.className = 'summary-card-value';
}
}
elements.netBrProfit.textContent = `₹${netBrProfitAll >= 0 ? '' : '-'}${Math.abs(netBrProfitAll).toLocaleString('en-IN', {maximumFractionDigits: 0})}`;
elements.netBrProfit.className = `summary-card-value ${netBrProfitAll >= 0 ? 'positive' : 'negative'}`;
const chargesAll = totalProfitAll - netBrProfitAll;
elements.charges.textContent = `₹-${Math.abs(chargesAll).toLocaleString('en-IN', {maximumFractionDigits: 0})}`;
if (elements.runningMargin) {
if (globalLastTotalMargin > 0) {
elements.runningMargin.textContent = `₹${globalLastTotalMargin.toLocaleString('en-IN', {maximumFractionDigits: 0})}`;
elements.runningMargin.className = 'summary-card-value ' + (globalLastTotalMargin >= 0 ? 'positive' : 'negative');
} else {
elements.runningMargin.textContent = '-';
elements.runningMargin.className = 'summary-card-value';
}
}
if (elements.totalExpense) {
elements.totalExpense.textContent = `₹${globalTotalExpenses >= 0 ? '' : '-'}${Math.abs(globalTotalExpenses).toLocaleString('en-IN', {maximumFractionDigits: 0})}`;
elements.totalExpense.className = 'summary-card-value ' + (globalTotalExpenses >= 0 ? 'positive' : 'negative');
}
const netProfitValue = netBrProfitAll + globalTotalExpenses;
if (elements.netProfit) {
elements.netProfit.textContent = `₹${netProfitValue >= 0 ? '' : '-'}${Math.abs(netProfitValue).toLocaleString('en-IN', {maximumFractionDigits: 0})}`;
elements.netProfit.className = 'summary-card-value ' + (netProfitValue >= 0 ? 'positive' : 'negative');
}
}
function exportToCSV() {
const table = document.getElementById('performanceTable'), rows = [], headerRow1 = table.querySelector('thead tr.header-row-1');
const headerRow2 = table.querySelector('thead tr.header-row-2');
if (headerRow1 && headerRow2) {
const headers1 = [];
const headers2 = [];
headerRow1.querySelectorAll('th').forEach(th => {
const text = th.textContent.trim(), colspan = parseInt(th.getAttribute('colspan')) || 1;
const rowspan = parseInt(th.getAttribute('rowspan')) || 1;
for (let i = 0; i < colspan; i++) {
headers1.push(rowspan === 2 ? text : text);
}
});
headerRow2.querySelectorAll('th').forEach(th => {
const text = th.textContent.trim();
headers2.push(text);
});
const finalHeaders = [];
let row2Index = 0;
headerRow1.querySelectorAll('th').forEach(th => {
const text = th.textContent.trim(), colspan = parseInt(th.getAttribute('colspan')) || 1;
const rowspan = parseInt(th.getAttribute('rowspan')) || 1;
if (rowspan === 2) {
finalHeaders.push(text);
} else {
for (let i = 0; i < colspan; i++) {
const subHeader = headers2[row2Index] || '';
if (text && subHeader) {
finalHeaders.push(`${text} ${subHeader}`);
} else {
finalHeaders.push(text || subHeader);
}
row2Index++;
}
}
});
rows.push(finalHeaders.map(h => {
if (h.includes(',') || h.includes('"') || h.includes('\n')) {
return '"' + h.replace(/"/g, '""') + '"';
}
return h;
}).join(','));
}
const bodyRows = table.querySelectorAll('tbody tr');
bodyRows.forEach(row => {
if (row.classList.contains('day-row') && !row.classList.contains('expanded')) {
return;
}
const cells = row.querySelectorAll('td');
const rowData = [];
cells.forEach(cell => {
let text = cell.textContent.trim();
text = text.replace(/[►▼]/g, '').trim();
if (text.includes(',') || text.includes('"') || text.includes('\n')) {
text = '"' + text.replace(/"/g, '""') + '"';
}
rowData.push(text);
});
if (rowData.length > 0) {
rows.push(rowData.join(','));
}
});
const csvContent = rows.join('\n'), blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' }), link = document.createElement('a'), today = new Date(), dateStr = today.toISOString().split('T')[0];
const filename = `Strategy_Performance_${dateStr}.csv`;
if (navigator.msSaveBlob) {
navigator.msSaveBlob(blob, filename);
} else {
link.href = URL.createObjectURL(blob);
link.download = filename;
link.style.display = 'none';
document.body.appendChild(link);
link.click();
document.body.removeChild(link);
}
}
window.addEventListener('DOMContentLoaded', () => {
const fromDateInput = document.getElementById('fromDate');
const toDateInput = document.getElementById('toDate');
const today = new Date();
const year = today.getFullYear();
const month = String(today.getMonth() + 1).padStart(2, '0');
const day = String(today.getDate()).padStart(2, '0');
if (toDateInput) toDateInput.value = `${year}-${month}-${day}`;
if (fromDateInput) fromDateInput.value = '';
document.querySelectorAll('.date-range-buttons .btn').forEach((btn) => {
if (btn.textContent.trim() === 'ALL TIME') btn.classList.add('active');
});
if (fromDateInput) {
fromDateInput.addEventListener('change', () => {
document.querySelectorAll('.date-range-buttons .btn').forEach(btn => btn.classList.remove('active'));
applyDateFilter();
processAndDisplayData();
});
}
if (toDateInput) {
toDateInput.addEventListener('change', () => {
document.querySelectorAll('.date-range-buttons .btn').forEach(btn => btn.classList.remove('active'));
applyDateFilter();
processAndDisplayData();
});
}
document.addEventListener('click', function(event) {
const isFromDate = fromDateInput && fromDateInput.contains(event.target);
const isToDate = toDateInput && toDateInput.contains(event.target);
if (!isFromDate && !isToDate) {
if (fromDateInput && document.activeElement === fromDateInput) fromDateInput.blur();
if (toDateInput && document.activeElement === toDateInput) toDateInput.blur();
}
});
document.addEventListener('keydown', function(event) {
if (event.key === 'Escape') {
if (fromDateInput && document.activeElement === fromDateInput) fromDateInput.blur();
if (toDateInput && document.activeElement === toDateInput) toDateInput.blur();
}
});
});
</script></body></html>
