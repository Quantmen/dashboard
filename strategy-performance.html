<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate">
    <meta http-equiv="Pragma" content="no-cache">
    <meta http-equiv="Expires" content="0">
    <title>Strategy Performance</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        html, body { width: 100%; height: 100%; overflow: hidden; }
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            background: #f8fafc;
            color: #1e293b;
        }
        .main-content {
            overflow-y: auto;
            overflow-x: hidden;
            padding: 16px 32px 32px 32px;
            background: #f8fafc;
            height: 100vh;
            width: 100%;
        }
        .page-header { margin-bottom: 16px; }
        .page-title { font-size: 20px; font-weight: 700; color: #111827; margin-bottom: 4px; letter-spacing: -0.5px; }
        .page-subtitle { font-size: 12px; color: #6b7280; font-weight: 400; }
        .controls-section {
            display: flex;
            gap: 8px;
            margin-bottom: 20px;
            flex-wrap: wrap;
            align-items: center;
            justify-content: space-between;
        }
        .controls-section > * {
            flex: 1 1 auto;
            min-width: 0;
        }
        .control-group { display: flex; align-items: center; gap: 8px; }
        .control-label { font-size: 12px; color: #374151; font-weight: 600; }
        .strategy-filter-container { position: relative; flex: 1 1 auto; min-width: 0; }
        .strategy-filter-button {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            padding: 7px 12px;
            border: 1px solid #d1d5db;
            border-radius: 8px;
            font-size: 11px;
            font-weight: 500;
            background: white;
            color: #374151;
            cursor: pointer;
            transition: all 0.15s ease;
            width: 100%;
            white-space: nowrap;
        }
        .strategy-filter-button:hover { border-color: #9ca3af; background: #f9fafb; }
        .strategy-filter-dropdown {
            position: absolute;
            top: 100%;
            left: 0;
            margin-top: 6px;
            background: white;
            border: 1px solid #d1d5db;
            border-radius: 10px;
            box-shadow: 0 10px 15px rgba(0,0,0,0.1), 0 4px 6px rgba(0,0,0,0.05);
            min-width: 180px;
            max-height: 400px;
            overflow-y: auto;
            z-index: 1000;
            display: none;
        }
        .strategy-filter-dropdown.active { display: block; }
        #monthFilterDropdown {
            min-width: 160px;
            max-width: 160px;
            max-height: 500px;
        }
        #monthFilterDropdown .strategy-filter-label {
            font-size: 12px;
        }
        #monthFilterDropdown .strategy-filter-item {
            padding: 6px 14px;
        }
        .strategy-filter-header {
            padding: 10px 12px;
            border-bottom: 1px solid #e2e8f0;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        .strategy-filter-title { font-size: 13px; font-weight: 600; color: #1e293b; }
        .strategy-filter-actions { display: flex; gap: 4px; }
        .filter-action-btn {
            font-size: 11px;
            color: #1e40af;
            cursor: pointer;
            padding: 4px 6px;
            border-radius: 4px;
            transition: background 0.2s ease;
        }
        .filter-action-btn:hover { background: #eff6ff; }
        .filter-action-btn[style*="color: #dc2626"]:hover { background: #fee2e2; }
        .strategy-filter-list { padding: 8px 0; }
        .strategy-filter-item {
            display: flex;
            align-items: center;
            padding: 8px 14px;
            cursor: pointer;
            transition: background 0.2s ease;
        }
        .strategy-filter-item:hover { background: #f8fafc; }
        .strategy-filter-checkbox { margin-right: 10px; width: 16px; height: 16px; cursor: pointer; }
        .strategy-filter-label { font-size: 13px; color: #475569; cursor: pointer; user-select: none; }
        .filter-badge {
            display: inline-block;
            background: #1e40af;
            color: white;
            font-size: 9px;
            padding: 2px 5px;
            border-radius: 10px;
            margin-left: 6px;
            font-weight: 600;
        }
        select, button {
            padding: 7px 12px;
            border: 1px solid #d1d5db;
            border-radius: 8px;
            font-size: 11px;
            font-weight: 500;
            background: white;
            color: #374151;
            cursor: pointer;
            transition: all 0.15s ease;
            font-family: inherit;
            white-space: nowrap;
            text-align: center;
            flex: 1 1 auto;
            min-width: 0;
        }
        select:hover, button:hover { border-color: #9ca3af; background: #f9fafb; }
        select:focus, button:focus {
            outline: none;
            border-color: #3b82f6;
            box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.1);
        }
        button.primary { background: #3b82f6; color: white; border-color: #3b82f6; }
        button.primary:hover { background: #2563eb; border-color: #2563eb; }
        .table-container {
            background: white;
            border-radius: 12px;
            box-shadow: 0 1px 3px rgba(0,0,0,0.08), 0 1px 2px rgba(0,0,0,0.06);
            border: 1px solid #e5e7eb;
            overflow: visible;
        }
        .table-wrapper { overflow-x: auto; overflow-y: visible; background: white; border-radius: 0; }
        .performance-table {
            width: 100%;
            border-collapse: separate;
            border-spacing: 0;
            font-size: 13px;
            min-width: 800px;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Segoe UI Web (West European)', 'Segoe UI', -apple-system, BlinkMacSystemFont, Roboto, 'Helvetica Neue', sans-serif;
        }
        .performance-table thead { position: sticky; top: 0; z-index: 10; background: white; }
        .performance-table thead tr { height: 0; border-spacing: 0; border-collapse: collapse; }
        .performance-table thead tr.header-row-1, .performance-table thead tr.header-row-2 { height: auto; }
        .performance-table thead tr.header-row-1 th {
            padding: 12px 8px 6px 8px;
            position: sticky;
            top: 0;
            background: #f3f4f6;
            z-index: 10;
            font-size: 11px;
            text-align: center;
            font-weight: 700;
            color: #1f2937;
            border-bottom: 1px solid #d1d5db;
            border-right: 1px solid #e5e7eb;
            white-space: nowrap;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            line-height: 1.2;
            vertical-align: middle;
            height: 32px;
        }
        .performance-table thead tr.header-row-1 th[rowspan="2"] {
            border-bottom: 2px solid #d1d5db;
            text-align: center;
            background: #f3f4f6;
            padding: 12px 8px;
            height: auto;
            vertical-align: middle;
        }
        .performance-table thead tr.header-row-2 th {
            padding: 6px 8px 12px 8px;
            font-size: 10px;
            position: sticky;
            top: 32px;
            background: #f3f4f6;
            z-index: 10;
            font-weight: 600;
            color: #6b7280;
            text-align: center;
            border-bottom: 2px solid #d1d5db;
            border-right: 1px solid #e5e7eb;
            white-space: nowrap;
            text-transform: uppercase;
            line-height: 1.2;
            vertical-align: middle;
            height: 32px;
        }
        .performance-table thead tr.header-row-1 th:first-child {
            position: sticky;
            left: 0;
            z-index: 11;
            background: #f9fafb;
            min-width: 100px;
            max-width: 100px;
            border-right: 2px solid #cbd5e1;
            padding: 12px 8px;
            vertical-align: middle;
        }
        .performance-table th {
            background: #f3f4f6;
            padding: 12px 8px;
            text-align: center;
            font-weight: 700;
            color: #6b7280;
            border-bottom: 2px solid #d1d5db;
            border-right: 1px solid #e5e7eb;
            white-space: nowrap;
            text-transform: uppercase;
            font-size: 11px;
            letter-spacing: 0.5px;
            min-width: 75px;
            max-width: 90px;
            vertical-align: middle;
        }
        .performance-table th.strategy-group-end { border-right: 1px solid #cbd5e1; }
        .performance-table td.strategy-group-end { border-right: 1px solid #cbd5e1; }
        .performance-table th.apro-boundary { border-right: 1px solid #cbd5e1 !important; }
        .performance-table td.apro-boundary { border-right: 1px solid #cbd5e1 !important; }
        .performance-table th.broker-boundary { border-right: 1px solid #cbd5e1 !important; }
        .performance-table td.broker-boundary { border-right: 1px solid #cbd5e1 !important; }
        .performance-table th.strategy-bg-0, .performance-table td.strategy-bg-0 { background: #f8fcf9; }
        .performance-table th.strategy-bg-1, .performance-table td.strategy-bg-1 { background: #f8fcf9; }
        .performance-table th.strategy-bg-2, .performance-table td.strategy-bg-2 { background: #f8fcf9; }
        .performance-table th.strategy-bg-3, .performance-table td.strategy-bg-3 { background: #fefafd; }
        .performance-table th.strategy-bg-4, .performance-table td.strategy-bg-4 { background: #fffaf5; }
        .performance-table td.lot-col.strategy-bg-0,
        .performance-table td.lot-col.strategy-bg-1,
        .performance-table td.lot-col.strategy-bg-2,
        .performance-table td.lot-col.strategy-bg-3,
        .performance-table td.lot-col.strategy-bg-4 {
            width: 65px;
            min-width: 65px;
            max-width: 65px;
            background: #eff8fe !important;
        }
        .performance-table tr:hover td.strategy-bg-0,
        .performance-table tr:hover td.strategy-bg-1,
        .performance-table tr:hover td.strategy-bg-2,
        .performance-table tr:hover td.strategy-bg-3,
        .performance-table tr:hover td.strategy-bg-4 { background: #fafbfc; }
        .performance-table tr:hover td.lot-col.strategy-bg-0,
        .performance-table tr:hover td.lot-col.strategy-bg-1,
        .performance-table tr:hover td.lot-col.strategy-bg-2,
        .performance-table tr:hover td.lot-col.strategy-bg-3,
        .performance-table tr:hover td.lot-col.strategy-bg-4 {
            background: #fafbfc;
            width: 65px;
            min-width: 65px;
            max-width: 65px;
        }
        .performance-table tr:hover td.apro-pnl-col {
            background: #fafbfc;
            width: 85px;
            min-width: 75px;
            max-width: 90px;
        }
        .performance-table tr:hover td.apro-pnl-col.strategy-bg-0,
        .performance-table tr:hover td.apro-pnl-col.strategy-bg-1,
        .performance-table tr:hover td.apro-pnl-col.strategy-bg-2,
        .performance-table tr:hover td.apro-pnl-col.strategy-bg-3,
        .performance-table tr:hover td.apro-pnl-col.strategy-bg-4 {
            background: #fafbfc;
            width: 85px;
            min-width: 75px;
            max-width: 90px;
        }
        .performance-table th:first-child {
            position: sticky;
            left: 0;
            z-index: 11;
            background: #f8fafc;
            min-width: 110px;
            max-width: 110px;
            border-right: 2px solid #cbd5e1;
            vertical-align: middle;
        }
        .performance-table th.number-col { text-align: center; max-width: 80px; }
        .performance-table th.apro-pnl-col, .performance-table td.apro-pnl-col {
            min-width: 75px;
            max-width: 90px;
            width: 85px;
        }
        .performance-table td.apro-pnl-col.strategy-bg-0 { background: #f8fcf9; width: 85px; min-width: 75px; max-width: 90px; }
        .performance-table td.apro-pnl-col.strategy-bg-1 { background: #f8fcf9; width: 85px; min-width: 75px; max-width: 90px; }
        .performance-table td.apro-pnl-col.strategy-bg-2 { background: #f8fcf9; width: 85px; min-width: 75px; max-width: 90px; }
        .performance-table td.apro-pnl-col.strategy-bg-3 { background: #f8fcf9; width: 85px; min-width: 75px; max-width: 90px; }
        .performance-table td.apro-pnl-col.strategy-bg-4 { background: #f8fcf9; width: 85px; min-width: 75px; max-width: 90px; }
        
        /* Section-based color overrides */
        .performance-table td.dpnl-section { background: #fefafd !important; }
        .performance-table td.pnl-section { background: #fffaf5 !important; }
        
        .performance-table td {
            padding: 11px 8px;
            border-bottom: 1px solid #f3f4f6;
            border-right: 1px solid #f3f4f6;
            color: #374151;
            text-align: right;
            white-space: nowrap;
            min-width: 75px;
            max-width: 90px;
            overflow: hidden;
            text-overflow: ellipsis;
            font-size: 13px;
            font-weight: 400;
        }
        .performance-table td.lot-col { min-width: 65px; max-width: 65px; width: 65px; }
        .performance-table th.lot-col { min-width: 65px; max-width: 65px; width: 65px; }
        .performance-table td:first-child {
            position: sticky;
            left: 0;
            background: white;
            font-weight: 500;
            z-index: 9;
            border-right: 2px solid #cbd5e1;
            min-width: 100px;
            max-width: 100px;
            padding: 11px 8px;
            text-align: left;
            color: #111827;
        }
        .performance-table td.number-col {
            text-align: right;
            font-weight: 400;
            font-size: 13px;
            min-width: 75px;
            max-width: 90px;
            padding: 11px 8px;
            font-variant-numeric: tabular-nums;
        }
        .performance-table th.number-col { text-align: center; max-width: 90px; }
        .performance-table td.number-col.total-net-col {
            min-width: 80px;
            max-width: none;
            font-weight: 600;
            background: #fefce8 !important;
        }
        .performance-table tbody tr.month-row td.number-col.total-net-col { background: #fef9c3 !important; }
        .performance-table tbody tr.total-row td.number-col.total-net-col { background: #fef9c3 !important; }
        .performance-table th.total-net-col { min-width: 80px; max-width: none; }
        .performance-table th.total-col-border,
        .performance-table td.total-col-border {
            border-right: 1px solid #cbd5e1 !important;
        }
        .performance-table td.number-col.net-pnl-percent-col {
            min-width: 60px;
            max-width: 60px;
            font-weight: 550;
            background: #fefce8 !important;
            font-size: 13px;
        }
        .performance-table tbody tr.month-row td.number-col.net-pnl-percent-col { background: #fef9c3 !important; }
        .performance-table tbody tr.total-row td.number-col.net-pnl-percent-col { background: #fef9c3 !important; }
        .performance-table th.net-pnl-percent-col { min-width: 60px; max-width: 80px; }
        .performance-table td.number-col.drawdown-col {
            min-width: 90px;
            max-width: none;
            background: #fef3f2 !important;
        }
        .performance-table tbody tr.month-row td.number-col.drawdown-col { background: #fee2e2 !important; }
        .performance-table tbody tr.total-row td.number-col.drawdown-col { background: #fee2e2 !important; }
        .performance-table th.drawdown-col { min-width: 90px; max-width: none; }
        .performance-table td.number-col.expenses-col {
            font-weight: 600;
            background: #fef2f2;
            border-left: 1px solid #cbd5e1;
        }
        .performance-table tbody tr.month-row td.number-col.expenses-col { background: #fef2f2 !important; }
        .performance-table tbody tr.total-row td.number-col.expenses-col { background: #fef2f2 !important; }
        .performance-table th.expenses-col { min-width: 80px; max-width: none; }
        .performance-table td.positive { color: #059669; }
        .performance-table td.negative { color: #b96060; }
        .performance-table tr:hover { background: #fafbfc; }
        .performance-table tr:hover td:first-child { background: #fafbfc; min-width: 100px; max-width: 100px; border-right: 2px solid #cbd5e1; }
        .performance-table tbody tr.total-row {
            background: #f9fafb;
            font-weight: 700;
            border-top: 2px solid #d1d5db;
        }
        .performance-table tbody tr.total-row:hover { background: #f3f4f6; }
        .performance-table tbody tr.total-row td {
            border-top: 2px solid #d1d5db;
            padding: 14px 8px;
            font-weight: 600;
            font-size: 13px;
        }
        .performance-table tbody tr.total-row td:first-child { background: #f9fafb; min-width: 100px; max-width: 100px; border-right: 2px solid #cbd5e1; }
        .performance-table tbody tr.total-row:hover td:first-child { background: #f3f4f6; min-width: 100px; max-width: 100px; border-right: 2px solid #cbd5e1; }
        .performance-table tbody tr.total-row:hover td.strategy-bg-0 { background: #ecf7f1; }
        .performance-table tbody tr.total-row:hover td.strategy-bg-1 { background: #ecf7f1; }
        .performance-table tbody tr.total-row:hover td.strategy-bg-2 { background: #ecf7f1; }
        .performance-table tbody tr.total-row:hover td.strategy-bg-3 { background: #fef0f6; }
        .performance-table tbody tr.total-row:hover td.strategy-bg-4 { background: #fff1e1; }
        .performance-table tbody tr.total-row:hover td.lot-col { width: 65px; min-width: 65px; max-width: 65px; background: #dff0fc !important; }
        .performance-table tbody tr.total-row:hover td.dpnl-section { background: #fef0f6 !important; }
        .performance-table tbody tr.total-row:hover td.pnl-section { background: #fff1e1 !important; }
        .performance-table tbody tr.total-row:hover td.apro-pnl-col { width: 85px; min-width: 75px; max-width: 90px; }
        .performance-table tbody tr.total-row:hover td.apro-pnl-col.strategy-bg-0 { background: #ecf7f1; }
        .performance-table tbody tr.total-row:hover td.apro-pnl-col.strategy-bg-1 { background: #ecf7f1; }
        .performance-table tbody tr.total-row:hover td.apro-pnl-col.strategy-bg-2 { background: #ecf7f1; }
        .performance-table tbody tr.total-row:hover td.apro-pnl-col.strategy-bg-3 { background: #ecf7f1; }
        .performance-table tbody tr.total-row:hover td.apro-pnl-col.strategy-bg-4 { background: #ecf7f1; }
        .performance-table tbody tr.total-row td.apro-pnl-col { width: 85px; min-width: 75px; max-width: 90px; }
        .performance-table tbody tr.month-row {
            background: #f9fafb;
            font-weight: 600 !important;
            cursor: pointer;
            user-select: none;
            border-left: 3px solid transparent;
            transition: all 0.15s ease;
        }
        .performance-table tbody tr.month-row:hover { background: #f3f4f6; border-left-color: #3b82f6; }
        .performance-table tbody tr.month-row td {
            font-weight: 600 !important;
            font-size: 12px !important;
        }
        .performance-table tbody tr.month-row td:first-child {
            background: #f9fafb;
            color: #111827;
            min-width: 100px;
            max-width: 100px;
            font-weight: 600 !important;
            font-size: 12px !important;
            border-right: 2px solid #cbd5e1;
        }
        .performance-table tbody tr.month-row:hover td:first-child { background: #f3f4f6; min-width: 100px; max-width: 100px; border-right: 2px solid #cbd5e1; }
        .performance-table tbody tr.month-row:hover td.strategy-bg-0 { background: #e3f3ea; }
        .performance-table tbody tr.month-row:hover td.strategy-bg-1 { background: #e3f3ea; }
        .performance-table tbody tr.month-row:hover td.strategy-bg-2 { background: #e3f3ea; }
        .performance-table tbody tr.month-row:hover td.strategy-bg-3 { background: #fde9f3; }
        .performance-table tbody tr.month-row:hover td.strategy-bg-4 { background: #ffecd6; }
        .performance-table tbody tr.month-row:hover td.lot-col { width: 65px; min-width: 65px; max-width: 65px; background: #d5ebfa !important; }
        .performance-table tbody tr.month-row:hover td.dpnl-section { background: #fde9f3 !important; }
        .performance-table tbody tr.month-row:hover td.pnl-section { background: #ffecd6 !important; }
        .performance-table tbody tr.month-row:hover td.apro-pnl-col { width: 85px; min-width: 75px; max-width: 90px; }
        .performance-table tbody tr.month-row:hover td.apro-pnl-col.strategy-bg-0 { background: #e3f3ea; }
        .performance-table tbody tr.month-row:hover td.apro-pnl-col.strategy-bg-1 { background: #e3f3ea; }
        .performance-table tbody tr.month-row:hover td.apro-pnl-col.strategy-bg-2 { background: #e3f3ea; }
        .performance-table tbody tr.month-row:hover td.apro-pnl-col.strategy-bg-3 { background: #e3f3ea; }
        .performance-table tbody tr.month-row:hover td.apro-pnl-col.strategy-bg-4 { background: #e3f3ea; }
        .performance-table tbody tr.month-row td.strategy-bg-0 { background: #f0f9f3; }
        .performance-table tbody tr.month-row td.strategy-bg-1 { background: #f0f9f3; }
        .performance-table tbody tr.month-row td.strategy-bg-2 { background: #f0f9f3; }
        .performance-table tbody tr.month-row td.strategy-bg-3 { background: #fef2f8; }
        .performance-table tbody tr.month-row td.strategy-bg-4 { background: #fff3e8; }
        .performance-table tbody tr.month-row td.lot-col { background: #e8f4fc !important; }
        .performance-table tbody tr.month-row td.dpnl-section { background: #fef2f8 !important; }
        .performance-table tbody tr.month-row td.pnl-section { background: #fff3e8 !important; }
        .performance-table tbody tr.month-row td.apro-pnl-col.strategy-bg-0 { background: #f0f9f3; width: 85px; min-width: 75px; max-width: 90px; }
        .performance-table tbody tr.month-row td.apro-pnl-col.strategy-bg-1 { background: #f0f9f3; width: 85px; min-width: 75px; max-width: 90px; }
        .performance-table tbody tr.month-row td.apro-pnl-col.strategy-bg-2 { background: #f0f9f3; width: 85px; min-width: 75px; max-width: 90px; }
        .performance-table tbody tr.month-row td.apro-pnl-col.strategy-bg-3 { background: #f0f9f3; width: 85px; min-width: 75px; max-width: 90px; }
        .performance-table tbody tr.month-row td.apro-pnl-col.strategy-bg-4 { background: #f0f9f3; width: 85px; min-width: 75px; max-width: 90px; }
        .performance-table tbody tr.day-row { display: none; }
        .performance-table tbody tr.day-row.expanded { display: table-row; }
        .performance-table tbody tr.day-row td { padding: 7px 8px; font-size: 12px; }
        .performance-table tbody tr.day-row td:first-child {
            padding-left: 40px;
            padding-top: 7px;
            padding-bottom: 7px;
            font-weight: 500;
            color: #6b7280;
            min-width: 100px;
            max-width: 100px;
            font-size: 12px;
            border-right: 2px solid #cbd5e1;
        }
        .performance-table tbody tr.day-row td.apro-pnl-col { width: 85px; min-width: 75px; max-width: 90px; }
        .expand-icon {
            display: inline-block;
            width: 18px;
            height: 18px;
            margin-right: 10px;
            text-align: center;
            font-weight: 600;
            color: #6b7280;
            transition: transform 0.2s ease;
            font-size: 12px;
            line-height: 18px;
        }
        .expand-icon.expanded { transform: rotate(90deg); }
        .no-data { text-align: center; color: #cbd5e1; padding: 40px; font-size: 14px; }
        .summary-cards {
            display: flex;
            gap: 12px;
            margin-bottom: 16px;
            flex-wrap: nowrap;
            overflow-x: auto;
            align-items: stretch;
        }
        .summary-card {
            background: white;
            border-radius: 8px;
            padding: 10px 12px;
            box-shadow: 0 1px 3px rgba(0,0,0,0.08), 0 1px 2px rgba(0,0,0,0.06);
            border: 1px solid #e5e7eb;
            flex: 1 1 0;
            min-width: 140px;
        }
        .summary-card-title {
            font-size: 10px;
            color: #6b7280;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            margin-bottom: 5px;
            font-weight: 700;
        }
        .summary-card-value {
            font-size: 18px;
            font-weight: 700;
            line-height: 1.2;
            font-variant-numeric: tabular-nums;
        }
        .summary-card-value.positive { color: #059669; }
        .summary-card-value.negative { color: #b96060; }
        .summary-card.net-profit-box {
            background: #f0fdf4;
        }
        .summary-card.total-expense-box {
            background: #fdf2f8;
        }
        .summary-card.running-margin-box {
            background: #fffbeb;
        }
        
        /* Tablet Layout - Dynamic columns based on card count */
        @media screen and (min-width: 769px) and (max-width: 1024px) {
            /* Default: 4 columns (changed to fix 4-box layout) */
            .summary-cards {
                display: grid;
                grid-template-columns: repeat(4, 1fr);
                gap: 12px;
                flex-wrap: wrap;
                overflow-x: visible;
            }
            
            /* 3 columns when 5+ boxes */
            .summary-cards.grid-3-cols {
                grid-template-columns: repeat(3, 1fr);
            }
            
            .summary-card {
                min-width: auto;
                flex: none;
            }
        }
        
        /* Comprehensive Mobile Responsive Styles */
        @media screen and (max-width: 768px) {
            .main-content {
                padding: 12px 16px 24px 16px;
            }
            
            .page-title {
                font-size: 18px;
            }
            
            .page-subtitle {
                font-size: 11px;
            }
            
            .controls-section {
                display: flex;
                flex-wrap: wrap;
                gap: 10px;
                margin-bottom: 16px;
            }
            
            /* Row 1: Month filter + Hide Strategy button */
            .controls-section .control-group:first-child {
                flex: 1 1 48%;
                display: flex;
                flex-direction: row;
                align-items: center;
                gap: 6px;
            }
            
            .controls-section .control-group:first-child select {
                flex: 1;
            }
            
            .controls-section .strategy-filter-container {
                flex: 1 1 48%;
            }
            
            /* Row 2: Checkboxes in same row */
            .controls-section .control-group:has(input[type="checkbox"]) {
                flex: 0 1 auto;
                display: flex;
                flex-direction: row;
                align-items: center;
                gap: 4px;
                white-space: nowrap;
            }
            
            .controls-section .control-group:has(input[type="checkbox"]) label {
                font-size: 11px;
                white-space: nowrap;
            }
            
            /* Row 3: Buttons in same row */
            .controls-section button {
                flex: 1 1 auto;
                min-width: 0;
            }
            
            .control-label {
                font-size: 11px;
                white-space: nowrap;
            }
            
            select, button, .strategy-filter-button {
                padding: 10px 12px;
                font-size: 12px;
            }
            
            .strategy-filter-button {
                width: 100%;
            }
            
            .strategy-filter-dropdown {
                left: 0;
                right: 0;
                min-width: auto;
                width: calc(100vw - 32px);
                max-height: 60vh;
            }
            
            .summary-cards {
                display: grid;
                grid-template-columns: repeat(2, 1fr);
                gap: 10px;
                flex-wrap: wrap;
                overflow-x: visible;
            }
            
            .summary-card {
                min-width: auto;
                flex: none;
            }
            
            .summary-card {
                padding: 14px 16px;
            }
            
            .summary-card-title {
                font-size: 11px;
            }
            
            .summary-card-value {
                font-size: 20px;
            }
            
            .summary-card-subtitle {
                font-size: 11px;
            }
            
            .table-container {
                margin: 0 -16px;
                border-radius: 0;
                border-left: none;
                border-right: none;
            }
            
            .table-wrapper {
                overflow-x: auto;
                -webkit-overflow-scrolling: touch;
            }
            
            .performance-table {
                font-size: 11px;
            }
            
            .performance-table thead tr.header-row-1 th {
                font-size: 9px;
                padding: 10px 6px 5px 6px;
            }
            
            .performance-table thead tr.header-row-2 th {
                font-size: 9px;
                padding: 8px 6px;
            }
            
            .performance-table tbody td {
                padding: 10px 6px;
                font-size: 11px;
            }
            
            .performance-table tbody tr.month-row td,
            .performance-table tbody tr.total-row td {
                font-size: 11px !important;
            }
            
            .performance-table tbody tr.day-row td {
                font-size: 10px;
                padding: 6px 4px;
            }
            
            .performance-table tbody tr.day-row td:first-child {
                padding-left: 30px;
                font-size: 10px;
            }
            
            .expand-icon {
                width: 16px;
                height: 16px;
            }
        }
        
        @media screen and (max-width: 480px) {
            .main-content {
                padding: 10px 12px 20px 12px;
            }
            
            .page-title {
                font-size: 16px;
            }
            
            .page-subtitle {
                font-size: 10px;
            }
            
            .controls-section {
                gap: 8px;
                margin-bottom: 14px;
            }
            
            .controls-section .control-group:has(input[type="checkbox"]) label {
                font-size: 10px;
            }
            
            .control-label {
                font-size: 10px;
            }
            
            select, button, .strategy-filter-button {
                padding: 9px 10px;
                font-size: 11px;
            }
            
            .summary-card {
                padding: 12px 14px;
                min-width: auto;
            }
            
            .summary-cards {
                gap: 8px;
                display: grid;
                grid-template-columns: repeat(2, 1fr);
            }
            
            .summary-card-title {
                font-size: 10px;
            }
            
            .summary-card-value {
                font-size: 18px;
            }
            
            .summary-card-subtitle {
                font-size: 10px;
            }
            
            .table-container {
                margin: 0 -12px;
            }
            
            .performance-table {
                font-size: 10px;
            }
            
            .performance-table thead tr.header-row-1 th,
            .performance-table thead tr.header-row-2 th {
                font-size: 8px;
                padding: 8px 4px;
            }
            
            .performance-table tbody td {
                padding: 8px 4px;
                font-size: 10px;
            }
            
            .performance-table tbody tr.month-row td,
            .performance-table tbody tr.total-row td {
                font-size: 10px !important;
            }
            
            .performance-table tbody tr.day-row td {
                font-size: 9px;
                padding: 5px 3px;
            }
            
            .performance-table tbody tr.day-row td:first-child {
                padding-left: 25px;
                font-size: 9px;
            }
            
            .strategy-filter-dropdown {
                width: calc(100vw - 24px);
                max-height: 50vh;
            }
            
            .expand-icon {
                width: 14px;
                height: 14px;
            }
            
            .filter-badge {
                font-size: 8px;
                padding: 1px 4px;
            }
        }
        
        @media screen and (max-width: 360px) {
            .main-content {
                padding: 8px 10px 16px 10px;
            }
            
            .page-title {
                font-size: 15px;
            }
            
            .controls-section {
                gap: 6px;
            }
            
            .controls-section .control-group:has(input[type="checkbox"]) label {
                font-size: 9px;
            }
            
            .control-label {
                font-size: 9px;
            }
            
            select, button, .strategy-filter-button {
                padding: 8px 8px;
                font-size: 10px;
            }
            
            .summary-cards {
                gap: 6px;
                display: grid;
                grid-template-columns: repeat(2, 1fr);
            }
            
            .summary-card {
                padding: 10px 12px;
                min-width: auto;
            }
            
            .summary-card-title {
                font-size: 9px;
            }
            
            .summary-card-value {
                font-size: 15px;
            }
            
            .summary-card-subtitle {
                font-size: 9px;
            }
            
            .performance-table {
                font-size: 9px;
            }
            
            .performance-table thead tr.header-row-1 th,
            .performance-table thead tr.header-row-2 th {
                font-size: 7px;
                padding: 6px 3px;
            }
            
            .performance-table tbody td {
                padding: 6px 3px;
                font-size: 9px;
            }
            
            .performance-table tbody tr.month-row td,
            .performance-table tbody tr.total-row td {
                font-size: 9px !important;
            }
            
            .performance-table tbody tr.day-row td {
                font-size: 8px;
            }
        }
    </style>
</head>
<body>
    <div class="main-content">
        <div class="page-header">
            <h1 class="page-title">Strategy Performance</h1>
            <p class="page-subtitle">Detailed profit and loss analysis by strategy and time period</p>
        </div>

        <div class="summary-cards" id="summaryCards">
            <div class="summary-card running-margin-box">
                <div class="summary-card-title">Running Margin</div>
                <div class="summary-card-value" id="runningMargin">-</div>
            </div>
            <div class="summary-card">
                <div class="summary-card-title">Starting Capital</div>
                <div class="summary-card-value" id="startingCapital">₹0</div>
            </div>
            <div class="summary-card">
                <div class="summary-card-title">Net Broker Profit</div>
                <div class="summary-card-value" id="netBrProfit">₹0</div>
            </div>
            <div class="summary-card">
                <div class="summary-card-title">Net Broker Profit(%)</div>
                <div class="summary-card-value" id="runningProfit">0%</div>
            </div>
            <div class="summary-card">
                <div class="summary-card-title">BROKER CHARGES</div>
                <div class="summary-card-value negative" id="charges">₹0</div>
            </div>
            <div class="summary-card total-expense-box">
                <div class="summary-card-title">Total Expense/Withdrawn</div>
                <div class="summary-card-value" id="totalExpense">-</div>
            </div>
            <div class="summary-card net-profit-box">
                <div class="summary-card-title">Total Margin Addition</div>
                <div class="summary-card-value" id="netProfit">-</div>
            </div>
        </div>

        <div class="controls-section">
            <div class="strategy-filter-container">
                <button class="strategy-filter-button" onclick="toggleMonthFilter()">
                    <span>Select Months</span>
                    <span class="filter-badge" id="monthFilterBadge" style="display: none;">0</span>
                    <span>▼</span>
                </button>
                <div class="strategy-filter-dropdown" id="monthFilterDropdown">
                    <div class="strategy-filter-header">
                        <span class="strategy-filter-title">Select Months</span>
                        <div class="strategy-filter-actions">
                            <span class="filter-action-btn" onclick="selectAllMonths()">All</span>
                        </div>
                    </div>
                    <div class="strategy-filter-list" id="monthFilterList"></div>
                </div>
            </div>
            <div class="strategy-filter-container">
                <button class="strategy-filter-button" onclick="toggleStrategyFilter()">
                    <span>Select Strategies</span>
                    <span class="filter-badge" id="filterBadge" style="display: none;">0</span>
                    <span>▼</span>
                </button>
                <div class="strategy-filter-dropdown" id="strategyFilterDropdown">
                    <div class="strategy-filter-header">
                        <span class="strategy-filter-title">Select STG</span>
                        <div class="strategy-filter-actions">
                            <span class="filter-action-btn" onclick="selectAllStrategies()">All</span>
                            <span class="filter-action-btn" onclick="deselectAllStrategies()">None</span>
                        </div>
                    </div>
                    <div class="strategy-filter-list" id="strategyFilterList"></div>
                </div>
            </div>
            <div class="strategy-filter-container">
                <button class="strategy-filter-button" onclick="toggleBrokerFilter()">
                    <span>Select Brokers</span>
                    <span class="filter-badge" id="brokerFilterBadge" style="display: none;">0</span>
                    <span>▼</span>
                </button>
                <div class="strategy-filter-dropdown" id="brokerFilterDropdown">
                    <div class="strategy-filter-header">
                        <span class="strategy-filter-title">Select Brokers</span>
                        <div class="strategy-filter-actions">
                            <span class="filter-action-btn" onclick="selectAllBrokers()">All</span>
                            <span class="filter-action-btn" onclick="clearAllBrokers()" style="color: #dc2626;">Clear</span>
                        </div>
                    </div>
                    <div class="strategy-filter-list" id="brokerFilterList"></div>
                </div>
            </div>
            <button onclick="toggleFilteredTotalsButton()" id="filteredTotalsButton">Show Filtered Totals</button>
            <button onclick="toggleTradeCountButton()" id="tradeCountButton">Show Trade Count</button>
            <button onclick="toggleDrawdownButton()" id="drawdownButton">Show Drawdown</button>
            <button onclick="toggleLotButton()" id="lotButton">Show Lot</button>
            <button onclick="toggleLotPnlButton()" id="lotPnlButton">Show Lot PNL</button>
            <button onclick="togglePnlTaxModeButton()" id="pnlTaxButton">Show Tax PNL</button>
            <button onclick="expandAll()">Expand All</button>
            <button onclick="collapseAll()">Collapse All</button>
            <button onclick="exportToCSV()">Export to csv</button>
            <button class="primary" onclick="resetAllFilters()">Reset Filter</button>
        </div>

        <div class="table-container">
            <div class="table-wrapper">
                <table class="performance-table" id="performanceTable">
                    <thead id="tableHeaders"></thead>
                    <tbody id="tableBody">
                        <tr>
                            <td colspan="100" class="no-data">Upload Excel file to view performance data</td>
                        </tr>
                    </tbody>
                </table>
            </div>
        </div>
    </div>

    <script>
        const elements = {
            startingCapital: document.getElementById('startingCapital'),
            runningProfit: document.getElementById('runningProfit'),
            netBrProfit: document.getElementById('netBrProfit'),
            charges: document.getElementById('charges'),
            runningMargin: document.getElementById('runningMargin'),
            totalExpense: document.getElementById('totalExpense'),
            netProfit: document.getElementById('netProfit'),
            monthFilterDropdown: document.getElementById('monthFilterDropdown'),
            monthFilterList: document.getElementById('monthFilterList'),
            monthFilterBadge: document.getElementById('monthFilterBadge'),
            strategyFilterDropdown: document.getElementById('strategyFilterDropdown'),
            strategyFilterList: document.getElementById('strategyFilterList'),
            filterBadge: document.getElementById('filterBadge'),
            brokerFilterDropdown: document.getElementById('brokerFilterDropdown'),
            brokerFilterList: document.getElementById('brokerFilterList'),
            brokerFilterBadge: document.getElementById('brokerFilterBadge'),
            tableHeaders: document.getElementById('tableHeaders'),
            tableBody: document.getElementById('tableBody')
        };

        let allTrades = [];
        let hiddenStrategies = new Set();
        let selectedMonths = new Set();
        let selectedBrokers = new Set();
        let allStrategies = [];
        let allBrokers = [];
        let brokersInitialized = false; // Track if brokers have been initialized
        let globalTotalExpenses = 0;
        let globalLastTotalMargin = 0;
        let globalStartingCapital = 0;
        let updateTimeout;
        let showFilteredTotals = false;
        let showTradeCount = false;
        let showDrawdown = false;
        let showLot = false;
        let showPnlTax = false;
        let showLotPnl = false;
        const monthNames = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];

        window.addEventListener('DOMContentLoaded', () => {
            loadSavedFilters();
            initializeHeadersOnly(); // Initialize headers only on page load
            
            document.addEventListener('click', (event) => {
                // Close strategy filter dropdown if clicking outside
                if (!elements.strategyFilterDropdown.contains(event.target) && 
                    !event.target.closest('.strategy-filter-button')) {
                    elements.strategyFilterDropdown.classList.remove('active');
                }
                
                // Close broker filter dropdown if clicking outside
                if (!elements.brokerFilterDropdown.contains(event.target) && 
                    !event.target.closest('.strategy-filter-button')) {
                    elements.brokerFilterDropdown.classList.remove('active');
                }
                
                // Close month filter dropdown only if clicking outside (not on button or inside dropdown)
                const clickedButton = event.target.closest('.strategy-filter-button');
                const isMonthButton = clickedButton && clickedButton.querySelector('#monthFilterBadge');
                
                if (!elements.monthFilterDropdown.contains(event.target) && !isMonthButton) {
                    elements.monthFilterDropdown.classList.remove('active');
                }
            });
            
            // Close dropdowns when mouse leaves the entire container (button + dropdown)
            // with 500ms delay to prevent accidental closures
            const closeTimeouts = new Map();
            
            document.querySelectorAll('.strategy-filter-container').forEach(container => {
                container.addEventListener('mouseleave', () => {
                    const dropdown = container.querySelector('.strategy-filter-dropdown');
                    if (dropdown) {
                        // Set a timeout to close after 500ms
                        const timeoutId = setTimeout(() => {
                            dropdown.classList.remove('active');
                            closeTimeouts.delete(container);
                        }, 500);
                        closeTimeouts.set(container, timeoutId);
                    }
                });
                
                container.addEventListener('mouseenter', () => {
                    // Cancel the close timeout if mouse re-enters within 500ms
                    if (closeTimeouts.has(container)) {
                        clearTimeout(closeTimeouts.get(container));
                        closeTimeouts.delete(container);
                    }
                });
            });
        });

        window.addEventListener('message', (event) => {
            const { type, data } = event.data;
            if (type === 'TRADES_DATA') {
                allTrades = data;
                selectedBrokers.clear(); // Clear broker selections on new data load
                brokersInitialized = false; // Reset flag on new data load to allow auto-selection
                
                // Reload saved strategy filters from localStorage to restore original saved state
                try {
                    const savedFilters = localStorage.getItem('strategyFilters');
                    if (savedFilters) {
                        hiddenStrategies = new Set(JSON.parse(savedFilters));
                    } else {
                        hiddenStrategies.clear();
                    }
                } catch (e) {
                    hiddenStrategies.clear();
                }
                
                processAndDisplayData();
            } else if (type === 'LOAD_SAMPLE_DATA') {
                loadSampleData();
            }
        });

        function loadSavedFilters() {
            try {
                // Explicitly remove broker selection from localStorage (should not be saved)
                localStorage.removeItem('selectedBrokers');
                
                const savedFilters = localStorage.getItem('strategyFilters');
                if (savedFilters) {
                    hiddenStrategies = new Set(JSON.parse(savedFilters));
                }
                const savedMonths = localStorage.getItem('selectedMonths');
                if (savedMonths) {
                    selectedMonths = new Set(JSON.parse(savedMonths));
                }
                const savedTotalsMode = localStorage.getItem('showFilteredTotals');
                if (savedTotalsMode !== null) {
                    showFilteredTotals = savedTotalsMode === 'true';
                    const button = document.getElementById('filteredTotalsButton');
                    if (button) button.textContent = showFilteredTotals ? 'Hide Filtered Totals' : 'Show Filtered Totals';
                }
                const savedTradeMode = localStorage.getItem('showTradeCount');
                if (savedTradeMode !== null) {
                    showTradeCount = savedTradeMode === 'true';
                    const button = document.getElementById('tradeCountButton');
                    if (button) button.textContent = showTradeCount ? 'Hide Trade Count' : 'Show Trade Count';
                }
                const savedDrawdownMode = localStorage.getItem('showDrawdown');
                if (savedDrawdownMode !== null) {
                    showDrawdown = savedDrawdownMode === 'true';
                    const button = document.getElementById('drawdownButton');
                    if (button) button.textContent = showDrawdown ? 'Hide Drawdown' : 'Show Drawdown';
                }
                const savedLotMode = localStorage.getItem('showLot');
                if (savedLotMode !== null) {
                    showLot = savedLotMode === 'true';
                    const button = document.getElementById('lotButton');
                    if (button) button.textContent = showLot ? 'Hide Lot' : 'Show Lot';
                }
                const savedPnlTaxMode = localStorage.getItem('showPnlTax');
                if (savedPnlTaxMode !== null) {
                    showPnlTax = savedPnlTaxMode === 'true';
                    const button = document.getElementById('pnlTaxButton');
                    if (button) button.textContent = showPnlTax ? 'Hide Tax PNL' : 'Show Tax PNL';
                }
                const savedLotPnlMode = localStorage.getItem('showLotPnl');
                if (savedLotPnlMode !== null) {
                    showLotPnl = savedLotPnlMode === 'true';
                    const button = document.getElementById('lotPnlButton');
                    if (button) button.textContent = showLotPnl ? 'Hide Lot PNL' : 'Show Lot PNL';
                }
            } catch (e) {
                hiddenStrategies = new Set();
            }
        }

        function toggleTotalsMode() {
            const checkbox = document.getElementById('showFilteredTotals');
            showFilteredTotals = checkbox.checked;
            try {
                localStorage.setItem('showFilteredTotals', showFilteredTotals);
            } catch (e) {}
            processAndDisplayData();
        }

        function toggleDrawdownMode() {
            const checkbox = document.getElementById('showDrawdown');
            showDrawdown = checkbox.checked;
            try {
                localStorage.setItem('showDrawdown', showDrawdown);
            } catch (e) {}
            processAndDisplayData();
        }

        function toggleLotMode() {
            const checkbox = document.getElementById('showLot');
            showLot = checkbox.checked;
            try {
                localStorage.setItem('showLot', showLot);
            } catch (e) {}
            processAndDisplayData();
        }

        function togglePnlTaxMode() {
            const checkbox = document.getElementById('showPnlTax');
            showPnlTax = checkbox.checked;
            try {
                localStorage.setItem('showPnlTax', showPnlTax);
            } catch (e) {}
            processAndDisplayData();
        }

        function togglePnlTaxModeButton() {
            showPnlTax = !showPnlTax;
            const button = document.getElementById('pnlTaxButton');
            if (button) {
                button.textContent = showPnlTax ? 'Hide Tax PNL' : 'Show Tax PNL';
            }
            try {
                localStorage.setItem('showPnlTax', showPnlTax);
            } catch (e) {}
            processAndDisplayData();
        }

        function toggleFilteredTotalsButton() {
            showFilteredTotals = !showFilteredTotals;
            const button = document.getElementById('filteredTotalsButton');
            if (button) {
                button.textContent = showFilteredTotals ? 'Hide Filtered Totals' : 'Show Filtered Totals';
            }
            try {
                localStorage.setItem('showFilteredTotals', showFilteredTotals);
            } catch (e) {}
            processAndDisplayData();
        }

        function toggleTradeCountButton() {
            showTradeCount = !showTradeCount;
            const button = document.getElementById('tradeCountButton');
            if (button) {
                button.textContent = showTradeCount ? 'Hide Trade Count' : 'Show Trade Count';
            }
            if (showTradeCount && !showLot) {
                showLot = true;
                const lotButton = document.getElementById('lotButton');
                if (lotButton) lotButton.textContent = 'Hide Lot';
                try { localStorage.setItem('showLot', showLot); } catch (e) {}
            }
            if (!showTradeCount && showLot) {
                showLot = false;
                const lotButton = document.getElementById('lotButton');
                if (lotButton) lotButton.textContent = 'Show Lot';
                try { localStorage.setItem('showLot', showLot); } catch (e) {}
            }
            try { localStorage.setItem('showTradeCount', showTradeCount); } catch (e) {}
            processAndDisplayData();
        }

        function toggleDrawdownButton() {
            showDrawdown = !showDrawdown;
            const button = document.getElementById('drawdownButton');
            if (button) {
                button.textContent = showDrawdown ? 'Hide Drawdown' : 'Show Drawdown';
            }
            try {
                localStorage.setItem('showDrawdown', showDrawdown);
            } catch (e) {}
            processAndDisplayData();
        }

        function toggleLotButton() {
            showLot = !showLot;
            const button = document.getElementById('lotButton');
            if (button) {
                button.textContent = showLot ? 'Hide Lot' : 'Show Lot';
            }
            try {
                localStorage.setItem('showLot', showLot);
            } catch (e) {}
            processAndDisplayData();
        }

        function toggleLotPnlButton() {
            showLotPnl = !showLotPnl;
            const button = document.getElementById('lotPnlButton');
            if (button) {
                button.textContent = showLotPnl ? 'Hide Lot PNL' : 'Show Lot PNL';
            }
            try {
                localStorage.setItem('showLotPnl', showLotPnl);
            } catch (e) {}
            processAndDisplayData();
        }

        function toggleLotPnlMode() {
            const checkbox = document.getElementById('showLotPnl');
            showLotPnl = checkbox.checked;
            try {
                localStorage.setItem('showLotPnl', showLotPnl);
            } catch (e) {}
            processAndDisplayData();
        }

        function toggleLotTradeMode() {
            const checkbox = document.getElementById('showTradeCount');
            showTradeCount = checkbox.checked;
            if (showTradeCount && !showLot) {
                showLot = true;
                const lotCheckbox = document.getElementById('showLot');
                if (lotCheckbox) lotCheckbox.checked = true;
                try { localStorage.setItem('showLot', showLot); } catch (e) {}
            }
            if (!showTradeCount && showLot) {
                showLot = false;
                const lotCheckbox = document.getElementById('showLot');
                if (lotCheckbox) lotCheckbox.checked = false;
                try { localStorage.setItem('showLot', showLot); } catch (e) {}
            }
            try { localStorage.setItem('showTradeCount', showTradeCount); } catch (e) {}
            processAndDisplayData();
        }

        function saveFilters() {
            try {
                localStorage.setItem('strategyFilters', JSON.stringify(Array.from(hiddenStrategies)));
            } catch (e) {}
        }

        function cleanupSavedFilters() {
            if (hiddenStrategies.size > 0 && allStrategies.length > 0) {
                const validHiddenStrategies = new Set();
                hiddenStrategies.forEach(strategy => {
                    if (allStrategies.includes(strategy)) {
                        validHiddenStrategies.add(strategy);
                    }
                });
                hiddenStrategies = validHiddenStrategies;
                // Removed saveFilters() - don't save when broker changes update the strategy list
            }
        }

        function toggleStrategyFilter() {
            // Close month filter dropdown if open
            elements.monthFilterDropdown.classList.remove('active');
            // Toggle strategy filter dropdown
            elements.strategyFilterDropdown.classList.toggle('active');
        }

        function updateStrategyFilterList() {
            if (allStrategies.length > 0) {
                const validHiddenStrategies = new Set();
                hiddenStrategies.forEach(strategy => {
                    if (allStrategies.includes(strategy)) {
                        validHiddenStrategies.add(strategy);
                    }
                });
                hiddenStrategies = validHiddenStrategies;
            }
            
            const html = allStrategies.map(strategy => {
                const isChecked = !hiddenStrategies.has(strategy);
                const displayName = formatStrategyName(strategy);
                return `<div class="strategy-filter-item" onclick="toggleStrategyRow('${strategy}')">
                    <input type="checkbox" class="strategy-filter-checkbox" id="check_${strategy}" 
                           ${isChecked ? 'checked' : ''}>
                    <label class="strategy-filter-label" for="check_${strategy}">${displayName}</label>
                </div>`;
            }).join('');
            
            elements.strategyFilterList.innerHTML = html;
            updateFilterBadge();
        }

        function toggleStrategyRow(strategyName) {
            const checkbox = document.getElementById(`check_${strategyName}`);
            if (!checkbox) return;
            
            checkbox.checked = !checkbox.checked;
            
            if (checkbox.checked) {
                hiddenStrategies.delete(strategyName);
            } else {
                hiddenStrategies.add(strategyName);
            }
            
            saveFilters();
            updateFilterBadge();
            clearTimeout(updateTimeout);
            updateTimeout = setTimeout(() => processAndDisplayData(), 250);
        }

        function selectAllStrategies() {
            hiddenStrategies.clear();
            saveFilters();
            allStrategies.forEach(strategy => {
                const checkbox = document.getElementById(`check_${strategy}`);
                if (checkbox) checkbox.checked = true;
            });
            updateFilterBadge();
            processAndDisplayData();
        }

        function deselectAllStrategies() {
            allStrategies.forEach(strategy => hiddenStrategies.add(strategy));
            saveFilters();
            allStrategies.forEach(strategy => {
                const checkbox = document.getElementById(`check_${strategy}`);
                if (checkbox) checkbox.checked = false;
            });
            updateFilterBadge();
            processAndDisplayData();
        }

        function clearSavedFilters() {
            try {
                localStorage.removeItem('strategyFilters');
                localStorage.removeItem('selectedMonths');
                localStorage.removeItem('showFilteredTotals');
                localStorage.removeItem('showTradeCount');
                localStorage.removeItem('showDrawdown');
            } catch (e) {}
            hiddenStrategies.clear();
            selectedMonths.clear();
            selectedBrokers.clear();
            showFilteredTotals = false;
            showTradeCount = false;
            showDrawdown = false;
            const filteredButton = document.getElementById('filteredTotalsButton');
            if (filteredButton) filteredButton.textContent = 'Show Filtered Totals';
            const tradeButton = document.getElementById('tradeCountButton');
            if (tradeButton) tradeButton.textContent = 'Show Trade Count';
            const drawdownButton = document.getElementById('drawdownButton');
            if (drawdownButton) drawdownButton.textContent = 'Show Drawdown';
            updateStrategyFilterList();
            updateMonthFilterList();
            updateBrokerFilterList();
            processAndDisplayData();
        }

        function resetAllFilters() {
            try {
                localStorage.removeItem('strategyFilters');
                localStorage.removeItem('selectedMonths');
                localStorage.removeItem('showFilteredTotals');
                localStorage.removeItem('showTradeCount');
                localStorage.removeItem('showDrawdown');
                localStorage.removeItem('showLot');
                localStorage.removeItem('showPnlTax');
                localStorage.removeItem('showLotPnl');
            } catch (e) {}
            
            hiddenStrategies.clear();
            selectedMonths.clear();
            selectedBrokers.clear();
            showFilteredTotals = false;
            showTradeCount = false;
            showDrawdown = false;
            showLot = false;
            showPnlTax = false;
            showLotPnl = false;
            
            const filteredButton = document.getElementById('filteredTotalsButton');
            if (filteredButton) filteredButton.textContent = 'Show Filtered Totals';
            const tradeButton = document.getElementById('tradeCountButton');
            if (tradeButton) tradeButton.textContent = 'Show Trade Count';
            const drawdownButton = document.getElementById('drawdownButton');
            if (drawdownButton) drawdownButton.textContent = 'Show Drawdown';
            const lotButton = document.getElementById('lotButton');
            if (lotButton) lotButton.textContent = 'Show Lot';
            const pnlTaxButton = document.getElementById('pnlTaxButton');
            if (pnlTaxButton) pnlTaxButton.textContent = 'Show Tax PNL';
            const lotPnlButton = document.getElementById('lotPnlButton');
            if (lotPnlButton) lotPnlButton.textContent = 'Show Lot PNL';
            
            updateStrategyFilterList();
            updateMonthFilterList();
            updateBrokerFilterList();
            processAndDisplayData();
        }

        function toggleMonthFilter() {
            // Close strategy filter dropdown if open
            elements.strategyFilterDropdown.classList.remove('active');
            // Toggle month filter dropdown
            elements.monthFilterDropdown.classList.toggle('active');
        }

        function updateMonthFilterList() {
            const monthsSet = new Set();
            allTrades.forEach(trade => {
                const parts = trade.date.split('/');
                if (parts.length >= 2) monthsSet.add(parts[1]);
            });

            const availableMonths = Array.from(monthsSet).sort();
            
            // If no months selected, select all by default
            if (selectedMonths.size === 0) {
                availableMonths.forEach(month => selectedMonths.add(month));
            }

            const html = availableMonths.map(month => {
                const isChecked = selectedMonths.has(month);
                const displayName = monthNames[parseInt(month) - 1];
                return `<div class="strategy-filter-item" onclick="event.stopPropagation(); toggleMonthRow('${month}')">
                    <input type="checkbox" class="strategy-filter-checkbox" id="month_check_${month}" 
                           ${isChecked ? 'checked' : ''}>
                    <label class="strategy-filter-label" for="month_check_${month}">${displayName}</label>
                </div>`;
            }).join('');
            
            elements.monthFilterList.innerHTML = html;
            updateMonthFilterBadge();
        }

        function toggleMonthRow(month) {
            const checkbox = document.getElementById(`month_check_${month}`);
            if (!checkbox) return;
            
            checkbox.checked = !checkbox.checked;
            
            if (checkbox.checked) {
                selectedMonths.add(month);
            } else {
                selectedMonths.delete(month);
            }
            
            saveMonthFilters();
            updateMonthFilterBadge();
            processAndDisplayData();
        }

        function saveMonthFilters() {
            try {
                localStorage.setItem('selectedMonths', JSON.stringify(Array.from(selectedMonths)));
            } catch (e) {}
        }

        function updateMonthFilterBadge() {
            const monthsSet = new Set();
            allTrades.forEach(trade => {
                const parts = trade.date.split('/');
                if (parts.length >= 2) monthsSet.add(parts[1]);
            });
            const totalMonths = monthsSet.size;
            const selectedCount = selectedMonths.size;
            
            if (selectedCount > 0 && selectedCount < totalMonths) {
                elements.monthFilterBadge.textContent = selectedCount;
                elements.monthFilterBadge.style.display = 'inline-block';
            } else {
                elements.monthFilterBadge.style.display = 'none';
            }
        }

        function selectAllMonths() {
            const monthsSet = new Set();
            allTrades.forEach(trade => {
                const parts = trade.date.split('/');
                if (parts.length >= 2) monthsSet.add(parts[1]);
            });
            
            monthsSet.forEach(month => selectedMonths.add(month));
            saveMonthFilters();
            
            monthsSet.forEach(month => {
                const checkbox = document.getElementById(`month_check_${month}`);
                if (checkbox) checkbox.checked = true;
            });
            updateMonthFilterBadge();
            processAndDisplayData();
        }

        function toggleBrokerFilter() {
            // Close strategy and month filter dropdowns if open
            elements.strategyFilterDropdown.classList.remove('active');
            elements.monthFilterDropdown.classList.remove('active');
            // Toggle broker filter dropdown
            elements.brokerFilterDropdown.classList.toggle('active');
        }

        function updateBrokerFilterList() {
            const brokersSet = new Set();
            
            // Extract broker codes from strategy names in brokerCodes mapping
            allTrades.forEach(trade => {
                if (trade.brokerCodes) {
                    Object.values(trade.brokerCodes).forEach(code => {
                        if (code) brokersSet.add(code);
                    });
                }
            });

            allBrokers = Array.from(brokersSet).sort();

            const html = allBrokers.map(broker => {
                const isChecked = selectedBrokers.has(broker);
                const displayName = broker === 'A' ? 'Amibroker' : broker;
                return `<div class="strategy-filter-item" onclick="event.stopPropagation(); toggleBrokerRow('${broker}')">
                    <input type="checkbox" class="strategy-filter-checkbox" id="broker_check_${broker}" 
                           ${isChecked ? 'checked' : ''}>
                    <label class="strategy-filter-label" for="broker_check_${broker}">${displayName}</label>
                </div>`;
            }).join('');
            
            elements.brokerFilterList.innerHTML = html;
            updateBrokerFilterBadge();
        }

        function toggleBrokerRow(broker) {
            const checkbox = document.getElementById(`broker_check_${broker}`);
            if (!checkbox) return;
            
            checkbox.checked = !checkbox.checked;
            
            if (checkbox.checked) {
                selectedBrokers.add(broker);
            } else {
                selectedBrokers.delete(broker);
            }
            
            saveBrokerFilters();
            updateBrokerFilterBadge();
            processAndDisplayData();
        }

        function saveBrokerFilters() {
            // Removed localStorage for broker filters
        }

        function updateBrokerFilterBadge() {
            const totalBrokers = allBrokers.length;
            const selectedCount = selectedBrokers.size;
            
            if (selectedCount > 0 && selectedCount < totalBrokers) {
                elements.brokerFilterBadge.textContent = selectedCount;
                elements.brokerFilterBadge.style.display = 'inline-block';
            } else {
                elements.brokerFilterBadge.style.display = 'none';
            }
        }

        function selectAllBrokers() {
            allBrokers.forEach(broker => selectedBrokers.add(broker));
            
            // Directly check all checkboxes
            allBrokers.forEach(broker => {
                const checkbox = document.getElementById(`broker_check_${broker}`);
                if (checkbox) checkbox.checked = true;
            });
            
            saveBrokerFilters();
            updateBrokerFilterBadge();
            processAndDisplayData();
        }

        function clearAllBrokers() {
            selectedBrokers.clear();
            
            // Directly uncheck all checkboxes
            allBrokers.forEach(broker => {
                const checkbox = document.getElementById(`broker_check_${broker}`);
                if (checkbox) checkbox.checked = false;
            });
            
            saveBrokerFilters();
            updateBrokerFilterBadge();
            processAndDisplayData();
        }


        function updateFilterBadge() {
            const hiddenCount = hiddenStrategies.size;
            if (hiddenCount > 0 && allStrategies.length > 0) {
                elements.filterBadge.textContent = hiddenCount;
                elements.filterBadge.style.display = 'inline-block';
            } else {
                elements.filterBadge.style.display = 'none';
            }
        }

        function formatStrategyName(strategyName) {
            if (!strategyName) return strategyName;
            if (strategyName.startsWith('A.PRO')) return strategyName;
            
            return strategyName.replace(/_/g, ' ').replace(/(\d)(PRO)/g, '$1 $2');
        }

        function formatNumber(num) {
            if (num === 0) return '';
            const formatted = Math.abs(num).toLocaleString('en-IN', { maximumFractionDigits: 0 });
            return num >= 0 ? formatted : `-${formatted}`;
        }

        function initializeHeadersOnly() {
            // Don't modify global allStrategies or allTrades - just display headers
            
            // Define temporary strategies just for header display
            const tempAProStrategies = ['A.PRO 2', 'A.PRO 3'];
            const tempBrokerStrategies = ['B1PRO2', 'B1PRO3', 'B2PRO2', 'B2PRO3'];
            const tempStrategies = [...tempAProStrategies, ...tempBrokerStrategies];
            
            // Build headers manually without modifying global state
            const aproStrategies = tempAProStrategies;
            const brokerStrategies = tempBrokerStrategies;
            
            // Group broker strategies by broker code
            const brokerGroups = {};
            brokerStrategies.forEach(strat => {
                const brokerMatch = strat.match(/^(B\d+)/);
                if (brokerMatch) {
                    const brokerCode = brokerMatch[1];
                    if (!brokerGroups[brokerCode]) {
                        brokerGroups[brokerCode] = [];
                    }
                    brokerGroups[brokerCode].push(strat);
                }
            });
            const sortedBrokers = Object.keys(brokerGroups).sort();

            let headerRow1 = '<tr class="header-row-1">';
            headerRow1 += '<th rowspan="2">Period</th>';
            
            // A.PRO section
            if (aproStrategies.length > 0) {
                headerRow1 += `<th colspan="${aproStrategies.length}" class="number-col apro-boundary">Amibroker PNL</th>`;
            }
            
            // DPNL section by broker
            sortedBrokers.forEach(brokerCode => {
                const count = brokerGroups[brokerCode].length;
                headerRow1 += `<th colspan="${count}" class="number-col broker-boundary">${brokerCode} DPNL</th>`;
            });
            
            // PNL section by broker
            let brokerPnlHeaderText;
            if (showLotPnl) {
                brokerPnlHeaderText = showPnlTax ? 'LOT PNL TAX' : 'LOT PNL';
            } else {
                brokerPnlHeaderText = showPnlTax ? 'PNL TAX' : 'PNL';
            }
            sortedBrokers.forEach(brokerCode => {
                const count = brokerGroups[brokerCode].length;
                headerRow1 += `<th colspan="${count}" class="number-col broker-boundary">${brokerCode} ${brokerPnlHeaderText}</th>`;
            });
            
            headerRow1 += '<th class="number-col total-net-col" rowspan="2">AMI PNL</th>';
            const netPnlHeaderText = showPnlTax ? 'NET PNL TAX' : 'NET PNL';
            headerRow1 += `<th class="number-col total-net-col" rowspan="2">${netPnlHeaderText}</th>`;
            headerRow1 += '<th class="number-col net-pnl-percent-col" rowspan="2">NET PNL%</th>';
            headerRow1 += '<th class="number-col expenses-col" rowspan="2">Expenses</th>';
            headerRow1 += '<th class="number-col total-net-col" rowspan="2">TOTAL MARGIN</th>';
            headerRow1 += '</tr>';

            let headerRow2 = '<tr class="header-row-2">';
            
            // A.PRO strategy names
            aproStrategies.forEach((strategy, idx) => {
                const displayName = formatStrategyName(strategy);
                const stratIndex = tempStrategies.indexOf(strategy);
                const bgClass = `strategy-bg-${stratIndex % 5}`;
                const boundaryClass = idx === aproStrategies.length - 1 ? ' apro-boundary' : '';
                headerRow2 += `<th class="number-col apro-pnl-col ${bgClass}${boundaryClass}">${displayName}</th>`;
            });
            
            // DPNL column strategy names
            sortedBrokers.forEach((brokerCode, brokerIdx) => {
                brokerGroups[brokerCode].forEach((strategy, idx) => {
                    const displayName = formatStrategyName(strategy).replace(/^B\d+\s*/, '');
                    const stratIndex = tempStrategies.indexOf(strategy);
                    const bgClass = `strategy-bg-${stratIndex % 5}`;
                    const isLastInBroker = idx === brokerGroups[brokerCode].length - 1;
                    const isLastBroker = brokerIdx === sortedBrokers.length - 1;
                    const boundaryClass = (isLastInBroker && isLastBroker) ? ' broker-boundary' : '';
                    headerRow2 += `<th class="number-col ${bgClass}${boundaryClass}">${displayName}</th>`;
                });
            });
            
            // PNL column strategy names
            sortedBrokers.forEach((brokerCode, brokerIdx) => {
                brokerGroups[brokerCode].forEach((strategy, idx) => {
                    const displayName = formatStrategyName(strategy).replace(/^B\d+\s*/, '');
                    const stratIndex = tempStrategies.indexOf(strategy);
                    const bgClass = `strategy-bg-${stratIndex % 5}`;
                    const isLastInBroker = idx === brokerGroups[brokerCode].length - 1;
                    const isLastBroker = brokerIdx === sortedBrokers.length - 1;
                    const boundaryClass = (isLastInBroker && isLastBroker) ? ' broker-boundary' : '';
                    headerRow2 += `<th class="number-col ${bgClass}${boundaryClass}">${displayName}</th>`;
                });
            });
            
            headerRow2 += '</tr>';
            elements.tableHeaders.innerHTML = headerRow1 + headerRow2;
            
            // Clear the table body to show no data
            elements.tableBody.innerHTML = '<tr><td colspan="100%" class="no-data">No data loaded yet.</td></tr>';
        }

        function loadSampleData() {
            allTrades = [];
            selectedBrokers.clear(); // Clear broker selections when loading sample data
            brokersInitialized = false; // Reset flag when loading sample data
            
            // Reload saved strategy filters from localStorage to restore original saved state
            try {
                const savedFilters = localStorage.getItem('strategyFilters');
                if (savedFilters) {
                    hiddenStrategies = new Set(JSON.parse(savedFilters));
                } else {
                    hiddenStrategies.clear();
                }
            } catch (e) {
                hiddenStrategies.clear();
            }
            
            const strategies = ['PRO 2', 'PRO 3', 'PRO 4', 'PRO 5', 'PRO 7'];
            const aProStrategies = ['A.PRO 1', 'A.PRO 2', 'A.PRO 3', 'A.PRO 4', 'A.PRO 5', 'A.PRO 7'];
            const brokerCodes = ['B1', 'B2'];
            const months = ['01', '02', '03', '04', '05', '06', '07', '08', '09', '10'];
            let cumPnl = 0;
            
            for (let monthIdx = 0; monthIdx < months.length; monthIdx++) {
                const daysInMonth = 20 + Math.floor(Math.random() * 10);
                
                for (let day = 1; day <= daysInMonth; day++) {
                    const strategy = strategies[Math.floor(Math.random() * strategies.length)];
                    const profit = (Math.random() - 0.45) * 5000;
                    cumPnl += profit;
                    
                    const strategyDetails = {};
                    const pnlStrategies = {};
                    const pnlTaxStrategies = {};
                    const brokerCodesMap = {};
                    
                    aProStrategies.forEach((aProStrat) => {
                        const aProProfit = (Math.random() - 0.5) * 2000;
                        pnlStrategies[aProStrat] = aProProfit;
                        pnlTaxStrategies[aProStrat] = aProProfit;
                        brokerCodesMap[aProStrat] = 'A';
                        strategyDetails[aProStrat] = {
                            lot: aProProfit !== 0 ? 1 : 0,
                            pnl: aProProfit,
                            dpnl: aProProfit,
                            buy: 0, qty: 0, sell: 0, unpnl: 0, margin: 0
                        };
                    });
                    
                    strategies.forEach((strat, idx) => {
                        const brokerCode = idx < 2 ? 'B1' : 'B2';
                        const stratName = `${brokerCode}${strat.replace(' ', '')}`;
                        const isActive = strat === strategy;
                        
                        pnlStrategies[stratName] = isActive ? profit : 0;
                        pnlTaxStrategies[stratName] = isActive ? profit * 0.95 : 0;
                        brokerCodesMap[stratName] = brokerCode;
                        strategyDetails[stratName] = {
                            lot: isActive ? (Math.random() > 0.5 ? 2 : 4) : 0,
                            pnl: isActive ? profit : 0,
                            dpnl: isActive ? profit * 0.95 : 0,
                            buy: 0, qty: 0, sell: 0, unpnl: 0, margin: 0
                        };
                    });
                    
                    allTrades.push({
                        date: `${String(day).padStart(2, '0')}/${months[monthIdx]}/2025`,
                        strategy: strategy,
                        profit: profit,
                        cumPnl: cumPnl,
                        strategyPnls: pnlStrategies,
                        strategyPnlTax: pnlTaxStrategies,
                        strategyDetails: strategyDetails,
                        brokerCodes: brokerCodesMap
                    });
                }
            }
            
            processAndDisplayData();
            window.parent.postMessage({ type: 'TRADES_DATA', data: allTrades }, '*');
        }

        function processAndDisplayData() {
            if (allTrades.length === 0) return;

            // Initialize broker selection FIRST - before any data processing
            // This must happen before filtering so data isn't filtered out
            const brokersSet = new Set();
            allTrades.forEach(trade => {
                if (trade.brokerCodes) {
                    Object.values(trade.brokerCodes).forEach(code => {
                        if (code) brokersSet.add(code);
                    });
                }
            });
            const tempAllBrokers = Array.from(brokersSet).sort();
            
            // On first load or when explicitly reset, select all brokers
            if (!brokersInitialized && selectedBrokers.size === 0 && tempAllBrokers.length > 0) {
                tempAllBrokers.forEach(broker => selectedBrokers.add(broker));
                brokersInitialized = true;
            }

            // Filter trades by selected months
            let filteredTrades = allTrades.filter(trade => {
                const month = trade.date?.split('/')[1];
                return selectedMonths.size === 0 || selectedMonths.has(month);
            });

            // If broker filter is active, filter the strategies within each trade
            if (selectedBrokers.size < tempAllBrokers.length) {
                filteredTrades = filteredTrades.map(trade => {
                    // Create a filtered version of the trade
                    const filteredTrade = { ...trade };
                    
                    // Filter strategy-related data based on broker codes
                    if (trade.brokerCodes) {
                        const filteredStrategyPnls = {};
                        const filteredStrategyPnlTax = {};
                        const filteredStrategyDetails = {};
                        const filteredBrokerCodes = {};
                        
                        // Only include strategies if brokers are selected
                        if (selectedBrokers.size > 0) {
                            Object.keys(trade.brokerCodes).forEach(strategyName => {
                                const brokerCode = trade.brokerCodes[strategyName];
                                if (selectedBrokers.has(brokerCode)) {
                                    if (trade.strategyPnls && trade.strategyPnls[strategyName] !== undefined) {
                                        filteredStrategyPnls[strategyName] = trade.strategyPnls[strategyName];
                                    }
                                    if (trade.strategyPnlTax && trade.strategyPnlTax[strategyName] !== undefined) {
                                        filteredStrategyPnlTax[strategyName] = trade.strategyPnlTax[strategyName];
                                    }
                                    if (trade.strategyDetails && trade.strategyDetails[strategyName]) {
                                        filteredStrategyDetails[strategyName] = trade.strategyDetails[strategyName];
                                    }
                                    filteredBrokerCodes[strategyName] = brokerCode;
                                }
                            });
                        }
                        // If selectedBrokers.size === 0, all objects remain empty (show nothing)
                        
                        filteredTrade.strategyPnls = filteredStrategyPnls;
                        filteredTrade.strategyPnlTax = filteredStrategyPnlTax;
                        filteredTrade.strategyDetails = filteredStrategyDetails;
                        filteredTrade.brokerCodes = filteredBrokerCodes;
                    }
                    
                    return filteredTrade;
                });
            }

            displayPivotData(filteredTrades);
            updateMonthFilterList();
            updateBrokerFilterList();
            updateSummaryCards(filteredTrades);
            updateStrategyFilterList();
            cleanupSavedFilters();
        }

        function displayPivotData(trades) {
            const monthlyData = {};
            const dailyData = {};
            const strategies = new Set();
            
            const monthlyTotals = {};
            const dailyTotals = {};
            const monthlyFilteredTotals = {};
            const dailyFilteredTotals = {};
            const cumulativeData = {};
            let runningTotal = 0;
            let peakTotal = 0;

            const sortedTrades = [...trades].sort((a, b) => {
                const dateA = a.date.split('/').reverse().join('');
                const dateB = b.date.split('/').reverse().join('');
                return dateA.localeCompare(dateB);
            });

            sortedTrades.forEach(trade => {
                const dateParts = trade.date.split('/');
                const monthKey = dateParts[1];
                const dateKey = trade.date;
                
                if (!monthlyData[monthKey]) monthlyData[monthKey] = {};
                if (!dailyData[monthKey]) dailyData[monthKey] = {};
                if (!dailyData[monthKey][dateKey]) dailyData[monthKey][dateKey] = {};
                if (!monthlyTotals[monthKey]) monthlyTotals[monthKey] = { total: 0, net: 0, amiPnl: 0, margin: 0, pnlTax: 0 };
                if (!dailyTotals[monthKey]) dailyTotals[monthKey] = {};
                if (!dailyTotals[monthKey][dateKey]) dailyTotals[monthKey][dateKey] = { total: 0, net: 0, amiPnl: 0, margin: 0, pnlTax: 0 };
                if (!monthlyFilteredTotals[monthKey]) monthlyFilteredTotals[monthKey] = { total: 0, net: 0, amiPnl: 0, margin: 0, pnlTax: 0 };
                if (!dailyFilteredTotals[monthKey]) dailyFilteredTotals[monthKey] = {};
                if (!dailyFilteredTotals[monthKey][dateKey]) dailyFilteredTotals[monthKey][dateKey] = { total: 0, net: 0, amiPnl: 0, margin: 0, pnlTax: 0 };

                Object.entries(trade.strategyDetails).forEach(([stratName, details]) => {
                    strategies.add(stratName);
                    
                    if (!monthlyData[monthKey][stratName]) {
                        monthlyData[monthKey][stratName] = { lot: 0, pnl: 0, dpnl: 0, net: 0, tradeCount: 0, lotSum: 0, lotCount: 0 };
                    }
                    if (!dailyData[monthKey][dateKey][stratName]) {
                        dailyData[monthKey][dateKey][stratName] = { lot: 0, pnl: 0, dpnl: 0, net: 0, tradeCount: 0, lotSum: 0, lotCount: 0 };
                    }
                    
                    if (details.lot > 0) {
                        monthlyData[monthKey][stratName].lotSum += details.lot;
                        monthlyData[monthKey][stratName].lotCount += 1;
                        monthlyData[monthKey][stratName].tradeCount += 1;
                    }
                    monthlyData[monthKey][stratName].pnl += details.pnl;
                    monthlyData[monthKey][stratName].dpnl += details.dpnl;
                    monthlyData[monthKey][stratName].net += (trade.strategyPnlTax[stratName] || 0);
                    
                    if (details.lot > 0) {
                        dailyData[monthKey][dateKey][stratName].lotSum += details.lot;
                        dailyData[monthKey][dateKey][stratName].lotCount += 1;
                        dailyData[monthKey][dateKey][stratName].tradeCount += 1;
                    }
                    dailyData[monthKey][dateKey][stratName].pnl += details.pnl;
                    dailyData[monthKey][dateKey][stratName].dpnl += details.dpnl;
                    dailyData[monthKey][dateKey][stratName].net += (trade.strategyPnlTax[stratName] || 0);
                    
                    const isAPro = stratName.startsWith('A.PRO');
                    if (!isAPro) {
                        const netPnl = trade.strategyPnlTax[stratName] || 0;
                        runningTotal += netPnl;
                        if (runningTotal > peakTotal) peakTotal = runningTotal;
                        
                        monthlyTotals[monthKey].total += details.pnl;
                        monthlyTotals[monthKey].net += netPnl;
                        monthlyTotals[monthKey].margin += (trade.strategyMargins?.[stratName] || 0);
                        monthlyTotals[monthKey].pnlTax += netPnl;
                        
                        dailyTotals[monthKey][dateKey].total += details.pnl;
                        dailyTotals[monthKey][dateKey].net += netPnl;
                        dailyTotals[monthKey][dateKey].margin += (trade.strategyMargins?.[stratName] || 0);
                        dailyTotals[monthKey][dateKey].pnlTax += netPnl;
                        
                        if (!hiddenStrategies.has(stratName)) {
                            monthlyFilteredTotals[monthKey].total += details.pnl;
                            monthlyFilteredTotals[monthKey].net += netPnl;
                            monthlyFilteredTotals[monthKey].margin += (trade.strategyMargins?.[stratName] || 0);
                            monthlyFilteredTotals[monthKey].pnlTax += netPnl;
                            
                            dailyFilteredTotals[monthKey][dateKey].total += details.pnl;
                            dailyFilteredTotals[monthKey][dateKey].net += netPnl;
                            dailyFilteredTotals[monthKey][dateKey].margin += (trade.strategyMargins?.[stratName] || 0);
                            dailyFilteredTotals[monthKey][dateKey].pnlTax += netPnl;
                        }
                    }
                    
                    if (!cumulativeData[monthKey]) cumulativeData[monthKey] = {};
                    cumulativeData[monthKey][dateKey] = {
                        cumTotal: runningTotal,
                        peak: peakTotal,
                        drawdown: peakTotal - runningTotal
                    };
                });
            });

            Object.keys(monthlyData).forEach(monthKey => {
                const datesInMonth = Object.keys(dailyData[monthKey] || {}).sort((a, b) => {
                    const dateA = a.split('/').reverse().join('');
                    const dateB = b.split('/').reverse().join('');
                    return dateA.localeCompare(dateB);
                });
                if (datesInMonth.length > 0) {
                    const lastDate = datesInMonth[datesInMonth.length - 1];
                    if (cumulativeData[monthKey] && cumulativeData[monthKey][lastDate]) {
                        monthlyTotals[monthKey].cumTotal = cumulativeData[monthKey][lastDate].cumTotal;
                        monthlyTotals[monthKey].peak = cumulativeData[monthKey][lastDate].peak;
                        monthlyTotals[monthKey].drawdown = cumulativeData[monthKey][lastDate].drawdown;
                        monthlyFilteredTotals[monthKey].cumTotal = cumulativeData[monthKey][lastDate].cumTotal;
                        monthlyFilteredTotals[monthKey].peak = cumulativeData[monthKey][lastDate].peak;
                        monthlyFilteredTotals[monthKey].drawdown = cumulativeData[monthKey][lastDate].drawdown;
                    }
                }
            });

            // Calculate AMI PNL (A.PRO PNL * Broker Lot Size)
            const aproStrategies = Array.from(strategies).filter(s => s.startsWith('A.PRO'));
            
            Object.keys(monthlyTotals).forEach(monthKey => {
                let amiPnlTotal = 0;
                let amiPnlFiltered = 0;
                
                const monthTrades = trades.filter(trade => {
                    const tradeParts = trade.date.split('/');
                    return tradeParts[1] === monthKey;
                });
                
                // Build daily max lots
                const dailyMaxLots = {};
                monthTrades.forEach(trade => {
                    const dateKey = trade.date;
                    if (!dailyMaxLots[dateKey]) {
                        dailyMaxLots[dateKey] = {};
                    }
                    
                    if (trade.strategyDetails) {
                        const allBrokerStrategies = Array.from(strategies).filter(s => !s.startsWith('A.PRO'));
                        allBrokerStrategies.forEach(brokerStrat => {
                            const lotSize = trade.strategyDetails[brokerStrat]?.lot || 0;
                            if (lotSize > 0) {
                                if (!dailyMaxLots[dateKey][brokerStrat] || lotSize > dailyMaxLots[dateKey][brokerStrat]) {
                                    dailyMaxLots[dateKey][brokerStrat] = lotSize;
                                }
                            }
                        });
                    }
                });
                
                // Calculate AMI PNL contribution
                monthTrades.forEach(trade => {
                    if (trade.strategyDetails) {
                        aproStrategies.forEach(aproStrat => {
                            const aproPnl = trade.strategyDetails[aproStrat]?.pnl || 0;
                            
                            if (aproPnl !== 0) {
                                const proMatch = aproStrat.match(/PRO\s*(\d+)/i);
                                if (proMatch) {
                                    const proNum = proMatch[1];
                                    
                                    const allBrokerStrategies = Array.from(strategies).filter(s => !s.startsWith('A.PRO'));
                                    allBrokerStrategies.forEach(brokerStrat => {
                                        const brokerProMatch = brokerStrat.match(/PRO\s*(\d+)/i);
                                        if (brokerProMatch && brokerProMatch[1] === proNum) {
                                            let lotSize = trade.strategyDetails[brokerStrat]?.lot || 0;
                                            
                                            if (lotSize === 0 && dailyMaxLots[trade.date]?.[brokerStrat]) {
                                                lotSize = dailyMaxLots[trade.date][brokerStrat];
                                            }
                                            
                                            const contribution = aproPnl * lotSize;
                                            amiPnlTotal += contribution;
                                            
                                            if (!hiddenStrategies.has(brokerStrat)) {
                                                amiPnlFiltered += contribution;
                                            }
                                        }
                                    });
                                }
                            }
                        });
                    }
                });
                
                monthlyTotals[monthKey].amiPnl = amiPnlTotal;
                monthlyFilteredTotals[monthKey].amiPnl = amiPnlFiltered;
                
                // Also calculate daily AMI PNL
                Object.keys(dailyData[monthKey] || {}).forEach(dateKey => {
                    let dailyAmiPnl = 0;
                    let dailyAmiPnlFiltered = 0;
                    
                    const dayTrades = monthTrades.filter(t => t.date === dateKey);
                    
                    dayTrades.forEach(trade => {
                        if (trade.strategyDetails) {
                            aproStrategies.forEach(aproStrat => {
                                const aproPnl = trade.strategyDetails[aproStrat]?.pnl || 0;
                                
                                if (aproPnl !== 0) {
                                    const proMatch = aproStrat.match(/PRO\s*(\d+)/i);
                                    if (proMatch) {
                                        const proNum = proMatch[1];
                                        
                                        const allBrokerStrategies = Array.from(strategies).filter(s => !s.startsWith('A.PRO'));
                                        allBrokerStrategies.forEach(brokerStrat => {
                                            const brokerProMatch = brokerStrat.match(/PRO\s*(\d+)/i);
                                            if (brokerProMatch && brokerProMatch[1] === proNum) {
                                                let lotSize = trade.strategyDetails[brokerStrat]?.lot || 0;
                                                
                                                if (lotSize === 0 && dailyMaxLots[dateKey]?.[brokerStrat]) {
                                                    lotSize = dailyMaxLots[dateKey][brokerStrat];
                                                }
                                                
                                                const contribution = aproPnl * lotSize;
                                                dailyAmiPnl += contribution;
                                                
                                                if (!hiddenStrategies.has(brokerStrat)) {
                                                    dailyAmiPnlFiltered += contribution;
                                                }
                                            }
                                        });
                                    }
                                }
                            });
                        }
                    });
                    
                    dailyTotals[monthKey][dateKey].amiPnl = dailyAmiPnl;
                    dailyFilteredTotals[monthKey][dateKey].amiPnl = dailyAmiPnlFiltered;
                });
            });

            allStrategies = Array.from(strategies).sort((a, b) => {
                const aIsAPro = a.startsWith('A.PRO');
                const bIsAPro = b.startsWith('A.PRO');
                
                if (aIsAPro && !bIsAPro) return -1;
                if (!aIsAPro && bIsAPro) return 1;
                
                if (aIsAPro && bIsAPro) {
                    const aNum = parseInt(a.match(/\d+/)?.[0] || '0');
                    const bNum = parseInt(b.match(/\d+/)?.[0] || '0');
                    return aNum - bNum;
                }
                
                return a.localeCompare(b);
            });
            
            const visibleStrategies = allStrategies.filter(s => !hiddenStrategies.has(s));
            
            // Calculate daily values first as they are needed for monthly calculations
            // Use the filtered trades (not allTrades) so broker filter affects expenses
            const sortedFilteredTrades = [...trades].sort((a, b) => {
                const dateA = a.date.split('/').reverse().join('');
                const dateB = b.date.split('/').reverse().join('');
                return dateA.localeCompare(dateB);
            });
            
            // Calculate daily total margins
            const dailyTotalMargins = calculateDailyTotalMargins(sortedFilteredTrades, Array.from(strategies));
            
            // Calculate daily expenses
            const dailyExpenses = calculateDailyExpenses(sortedFilteredTrades, Array.from(strategies), dailyTotalMargins);
            
            // Calculate Expenses and TOTAL MARGIN using filtered trades (affected by broker filter)
            // Pass dailyTotalMargins and dailyExpenses to aggregate them monthly
            const monthlyExpensesAndMargins = calculateExpensesAndMargins(sortedFilteredTrades, hiddenStrategies, Array.from(strategies), showFilteredTotals, dailyTotalMargins, dailyExpenses);
            
            renderPivotTable(monthlyData, dailyData, visibleStrategies, monthlyTotals, dailyTotals, monthlyFilteredTotals, dailyFilteredTotals, cumulativeData, monthlyExpensesAndMargins, dailyTotalMargins, dailyExpenses);
        }
        
        function calculateExpensesAndMargins(sortedTrades, hiddenStrategies, allStrategiesParam, useFilteredTotals, dailyTotalMargins, dailyExpenses) {
            const result = {};
            
            // Group trades by month
            const tradesByMonth = {};
            sortedTrades.forEach(trade => {
                const monthKey = trade.date.split('/')[1];
                if (!tradesByMonth[monthKey]) {
                    tradesByMonth[monthKey] = [];
                }
                tradesByMonth[monthKey].push(trade);
            });
            
            // Use provided strategies
            const allStrategies = allStrategiesParam;
            
            const sortedMonths = Object.keys(tradesByMonth).sort();
            
            sortedMonths.forEach((monthKey, monthIdx) => {
                const monthTrades = tradesByMonth[monthKey];
                
                // Get all dates in this month
                const tradesByDate = {};
                monthTrades.forEach(trade => {
                    const dateKey = trade.date;
                    if (!tradesByDate[dateKey]) {
                        tradesByDate[dateKey] = [];
                    }
                    tradesByDate[dateKey].push(trade);
                });
                
                const sortedDatesInMonth = Object.keys(tradesByDate).sort((a, b) => {
                    const dayA = parseInt(a.split('/')[0]);
                    const dayB = parseInt(b.split('/')[0]);
                    return dayA - dayB;
                });
                
                // Sum daily expenses for this month
                let monthExpenses = 0;
                sortedDatesInMonth.forEach(dateKey => {
                    monthExpenses += (dailyExpenses[dateKey] || 0);
                });
                
                // Get the last day's total margin for this month
                let monthTotalMargin = 0;
                if (sortedDatesInMonth.length > 0) {
                    const lastDate = sortedDatesInMonth[sortedDatesInMonth.length - 1];
                    monthTotalMargin = dailyTotalMargins[lastDate] || 0;
                }
                
                result[monthKey] = {
                    totalMargin: monthTotalMargin,
                    expenses: monthExpenses
                };
            });
            
            return result;
        }

        function calculateDailyExpenses(sortedTrades, allStrategiesParam, dailyTotalMargins) {
            const result = {};
            
            // Group trades by date
            const tradesByDate = {};
            sortedTrades.forEach(trade => {
                const dateKey = trade.date;
                if (!tradesByDate[dateKey]) {
                    tradesByDate[dateKey] = [];
                }
                tradesByDate[dateKey].push(trade);
            });
            
            // Sort dates chronologically
            const sortedDates = Object.keys(tradesByDate).sort((a, b) => {
                const dateA = a.split('/').reverse().join('');
                const dateB = b.split('/').reverse().join('');
                return dateA.localeCompare(dateB);
            });
            
            // Calculate starting capital from first date
            let startingCapital = 0;
            if (sortedDates.length > 0) {
                const firstDate = sortedDates[0];
                const firstDateTrades = tradesByDate[firstDate];
                const firstDateBrokerMargins = {};
                const allBrokerStrategies = allStrategiesParam.filter(s => !s.startsWith('A.PRO'));
                
                firstDateTrades.forEach(trade => {
                    if (trade.strategyDetails) {
                        allBrokerStrategies.forEach(brokerStrat => {
                            const margin = trade.strategyDetails[brokerStrat]?.margin || 0;
                            const brokerMatch = brokerStrat.match(/^(B\d+)/);
                            if (brokerMatch && margin > 0) {
                                const brokerCode = brokerMatch[1];
                                if (!firstDateBrokerMargins[brokerCode]) {
                                    firstDateBrokerMargins[brokerCode] = {};
                                }
                                firstDateBrokerMargins[brokerCode][brokerStrat] = margin;
                            }
                        });
                    }
                });
                
                Object.keys(firstDateBrokerMargins).forEach(brokerCode => {
                    const margins = Object.values(firstDateBrokerMargins[brokerCode]);
                    if (margins.length > 0) {
                        startingCapital += Math.max(...margins);
                    }
                });
            }
            
            let cumulativeNetPnl = 0;
            let cumulativeCharges = 0;
            
            // Calculate expenses for each day
            sortedDates.forEach(dateKey => {
                const dayTrades = tradesByDate[dateKey];
                
                // Calculate day net PnL
                let dayNet = 0;
                dayTrades.forEach(trade => {
                    if (trade && trade.strategyPnlTax) {
                        Object.entries(trade.strategyPnlTax).forEach(([stratName, pnlTax]) => {
                            if (!stratName.startsWith('A.PRO')) {
                                dayNet += pnlTax;
                            }
                        });
                    }
                });
                
                cumulativeNetPnl += dayNet;
                const runningCapital = startingCapital + cumulativeNetPnl;
                const totalMargin = dailyTotalMargins[dateKey] || 0;
                const chargesWithdrawn = totalMargin - runningCapital - cumulativeCharges;
                
                cumulativeCharges += chargesWithdrawn;
                
                result[dateKey] = chargesWithdrawn;
            });
            
            return result;
        }

        function calculateDailyTotalMargins(sortedTrades, allStrategiesParam) {
            const result = {};
            
            // Group trades by date
            const tradesByDate = {};
            sortedTrades.forEach(trade => {
                const dateKey = trade.date;
                if (!tradesByDate[dateKey]) {
                    tradesByDate[dateKey] = [];
                }
                tradesByDate[dateKey].push(trade);
            });
            
            // Sort dates chronologically
            const sortedDates = Object.keys(tradesByDate).sort((a, b) => {
                const dateA = a.split('/').reverse().join('');
                const dateB = b.split('/').reverse().join('');
                return dateA.localeCompare(dateB);
            });
            
            // Build PnL Tax by date and broker
            const brokerPnlTaxByDate = {};
            sortedTrades.forEach(trade => {
                const tradeDate = trade.date;
                if (!brokerPnlTaxByDate[tradeDate]) {
                    brokerPnlTaxByDate[tradeDate] = {};
                }
                
                if (trade && trade.strategyPnlTax) {
                    Object.entries(trade.strategyPnlTax).forEach(([stratName, pnlTax]) => {
                        if (!stratName.startsWith('A.PRO')) {
                            const brokerMatch = stratName.match(/^(B\d+)/);
                            if (brokerMatch) {
                                const brokerCode = brokerMatch[1];
                                if (!brokerPnlTaxByDate[tradeDate][brokerCode]) {
                                    brokerPnlTaxByDate[tradeDate][brokerCode] = {};
                                }
                                if (!brokerPnlTaxByDate[tradeDate][brokerCode][stratName]) {
                                    brokerPnlTaxByDate[tradeDate][brokerCode][stratName] = 0;
                                }
                                brokerPnlTaxByDate[tradeDate][brokerCode][stratName] += pnlTax;
                            }
                        }
                    });
                }
            });
            
            // Track previous day's broker-wise max margins and margin dates
            let previousDayBrokerMaxMargins = {};
            let brokerMarginDates = {}; // Track which date each broker's margin comes from
            
            // Calculate margin for each date
            sortedDates.forEach((dateKey, dateIndex) => {
                const dayTrades = tradesByDate[dateKey];
                const dayBrokerMargins = {};
                
                dayTrades.forEach(trade => {
                    if (trade.strategyDetails) {
                        Object.entries(trade.strategyDetails).forEach(([stratName, details]) => {
                            if (!stratName.startsWith('A.PRO')) {
                                const margin = details.margin || 0;
                                const brokerMatch = stratName.match(/^(B\d+)/);
                                if (brokerMatch) {
                                    const brokerCode = brokerMatch[1];
                                    if (!dayBrokerMargins[brokerCode]) {
                                        dayBrokerMargins[brokerCode] = {};
                                    }
                                    // Store max margin for each strategy
                                    if (!dayBrokerMargins[brokerCode][stratName] || margin > dayBrokerMargins[brokerCode][stratName]) {
                                        dayBrokerMargins[brokerCode][stratName] = margin;
                                    }
                                }
                            }
                        });
                    }
                });
                
                // Calculate max margin per broker and track margin date
                const currentDayBrokerMaxMargins = {};
                let dayTotalMargin = 0;
                
                // Get all brokers (from today and yesterday)
                const allBrokers = new Set([...Object.keys(dayBrokerMargins), ...Object.keys(previousDayBrokerMaxMargins)]);
                
                allBrokers.forEach(brokerCode => {
                    let brokerMaxMargin = 0;
                    let marginDate = dateKey;
                    
                    // Calculate today's max margin for this broker
                    if (dayBrokerMargins[brokerCode]) {
                        const margins = Object.values(dayBrokerMargins[brokerCode]);
                        if (margins.length > 0) {
                            brokerMaxMargin = Math.max(...margins);
                        }
                    }
                    
                    // If broker's margin is 0 and we have yesterday's data, use yesterday's margin and date
                    if (brokerMaxMargin === 0 && previousDayBrokerMaxMargins[brokerCode]) {
                        brokerMaxMargin = previousDayBrokerMaxMargins[brokerCode];
                        marginDate = brokerMarginDates[brokerCode] || dateKey;
                    }
                    
                    currentDayBrokerMaxMargins[brokerCode] = brokerMaxMargin;
                    brokerMarginDates[brokerCode] = marginDate;
                    dayTotalMargin += brokerMaxMargin;
                });
                
                // Calculate PnL Tax from margin date forward to current date
                let dayPnlTax = 0;
                
                allBrokers.forEach(brokerCode => {
                    const marginDate = brokerMarginDates[brokerCode];
                    const marginDateIndex = sortedDates.indexOf(marginDate);
                    
                    // Accumulate PnL Tax from margin date forward to current date
                    for (let i = marginDateIndex; i <= dateIndex; i++) {
                        const checkDate = sortedDates[i];
                        if (brokerPnlTaxByDate[checkDate] && brokerPnlTaxByDate[checkDate][brokerCode]) {
                            Object.values(brokerPnlTaxByDate[checkDate][brokerCode]).forEach(pnlTax => {
                                dayPnlTax += pnlTax;
                            });
                        }
                    }
                });
                
                // Total Margin = Margin + PnL Tax from margin date forward
                result[dateKey] = dayTotalMargin + dayPnlTax;
                
                // Store today's broker max margins for next iteration
                previousDayBrokerMaxMargins = { ...currentDayBrokerMaxMargins };
            });
            
            return result;
        }

        function renderPivotTable(monthlyData, dailyData, strategies, monthlyTotals, dailyTotals, monthlyFilteredTotals, dailyFilteredTotals, cumulativeData, monthlyExpensesAndMargins, dailyTotalMargins, dailyExpenses) {
            if (strategies.length === 0) {
                const drawdownHeader = showDrawdown ? '<th class="number-col">DRAWDOWN</th>' : '';
                const colspan = showDrawdown ? '3' : '2';
                const netPnlHeaderText = showPnlTax ? 'NET PNL TAX' : 'NET PNL';
                elements.tableHeaders.innerHTML = `<tr><th>Period</th><th class="number-col">${netPnlHeaderText}</th>${drawdownHeader}</tr>`;
                elements.tableBody.innerHTML = `<tr><td colspan="${colspan}" class="no-data">No strategies selected. Use "Hide Strategies" filter to show strategies.</td></tr>`;
                return;
            }

            // Separate A.PRO and broker strategies
            const aproStrategies = strategies.filter(s => s.startsWith('A.PRO'));
            const brokerStrategies = strategies.filter(s => !s.startsWith('A.PRO'));
            
            // Group broker strategies by broker code
            const brokerGroups = {};
            brokerStrategies.forEach(strat => {
                const brokerMatch = strat.match(/^(B\d+)/);
                if (brokerMatch) {
                    const brokerCode = brokerMatch[1];
                    if (!brokerGroups[brokerCode]) {
                        brokerGroups[brokerCode] = [];
                    }
                    brokerGroups[brokerCode].push(strat);
                }
            });
            const sortedBrokers = Object.keys(brokerGroups).sort();

            let headerRow1 = '<tr class="header-row-1">';
            headerRow1 += '<th rowspan="2">Period</th>';
            
            // A.PRO section
            if (aproStrategies.length > 0) {
                headerRow1 += `<th colspan="${aproStrategies.length}" class="number-col apro-boundary">Amibroker PNL</th>`;
            }
            
            // LOT section by broker
            if (showLot) {
                const columnLabel = showTradeCount ? 'TRADE COUNT' : 'LOT';
                sortedBrokers.forEach(brokerCode => {
                    const count = brokerGroups[brokerCode].length;
                    headerRow1 += `<th colspan="${count}" class="number-col broker-boundary">${brokerCode} ${columnLabel}</th>`;
                });
            }
            
            // DPNL section by broker
            sortedBrokers.forEach(brokerCode => {
                const count = brokerGroups[brokerCode].length;
                headerRow1 += `<th colspan="${count}" class="number-col broker-boundary">${brokerCode} DPNL</th>`;
            });
            
            // PNL section by broker
            let brokerPnlHeaderText;
            if (showLotPnl) {
                brokerPnlHeaderText = showPnlTax ? 'LOT PNL TAX' : 'LOT PNL';
            } else {
                brokerPnlHeaderText = showPnlTax ? 'PNL TAX' : 'PNL';
            }
            sortedBrokers.forEach(brokerCode => {
                const count = brokerGroups[brokerCode].length;
                headerRow1 += `<th colspan="${count}" class="number-col broker-boundary">${brokerCode} ${brokerPnlHeaderText}</th>`;
            });
            
            headerRow1 += '<th class="number-col total-net-col" rowspan="2">AMI PNL</th>';
            const netPnlHeaderText = showPnlTax ? 'NET PNL TAX' : 'NET PNL';
            headerRow1 += `<th class="number-col total-net-col" rowspan="2">${netPnlHeaderText}</th>`;
            headerRow1 += '<th class="number-col net-pnl-percent-col" rowspan="2">NET PNL%</th>';
            headerRow1 += '<th class="number-col expenses-col" rowspan="2">Expenses</th>';
            headerRow1 += '<th class="number-col total-net-col" rowspan="2">TOTAL MARGIN</th>';
            if (showDrawdown) {
                headerRow1 += '<th class="number-col drawdown-col" rowspan="2">DRAWDOWN</th>';
            }
            headerRow1 += '</tr>';

            let headerRow2 = '<tr class="header-row-2">';
            
            // A.PRO strategy names
            aproStrategies.forEach((strategy, idx) => {
                const displayName = formatStrategyName(strategy);
                const stratIndex = allStrategies.indexOf(strategy);
                const bgClass = `strategy-bg-${stratIndex % 5}`;
                const boundaryClass = idx === aproStrategies.length - 1 ? ' apro-boundary' : '';
                headerRow2 += `<th class="number-col apro-pnl-col ${bgClass}${boundaryClass}">${displayName}</th>`;
            });
            
            // LOT column strategy names
            if (showLot) {
                sortedBrokers.forEach((brokerCode, brokerIdx) => {
                    brokerGroups[brokerCode].forEach((strategy, idx) => {
                        const displayName = formatStrategyName(strategy).replace(/^B\d+\s*/, '');
                        const stratIndex = allStrategies.indexOf(strategy);
                        const bgClass = `strategy-bg-${stratIndex % 5}`;
                        const isLastInBroker = idx === brokerGroups[brokerCode].length - 1;
                        const isLastBroker = brokerIdx === sortedBrokers.length - 1;
                        const boundaryClass = (isLastInBroker && isLastBroker) ? ' broker-boundary' : '';
                        headerRow2 += `<th class="number-col lot-col ${bgClass}${boundaryClass}">${displayName}</th>`;
                    });
                });
            }
            
            // DPNL column strategy names
            sortedBrokers.forEach((brokerCode, brokerIdx) => {
                brokerGroups[brokerCode].forEach((strategy, idx) => {
                    const displayName = formatStrategyName(strategy).replace(/^B\d+\s*/, '');
                    const stratIndex = allStrategies.indexOf(strategy);
                    const bgClass = `strategy-bg-${stratIndex % 5}`;
                    const isLastInBroker = idx === brokerGroups[brokerCode].length - 1;
                    const isLastBroker = brokerIdx === sortedBrokers.length - 1;
                    const boundaryClass = (isLastInBroker && isLastBroker) ? ' broker-boundary' : '';
                    headerRow2 += `<th class="number-col ${bgClass}${boundaryClass}">${displayName}</th>`;
                });
            });
            
            // PNL column strategy names
            sortedBrokers.forEach((brokerCode, brokerIdx) => {
                brokerGroups[brokerCode].forEach((strategy, idx) => {
                    const displayName = formatStrategyName(strategy).replace(/^B\d+\s*/, '');
                    const stratIndex = allStrategies.indexOf(strategy);
                    const bgClass = `strategy-bg-${stratIndex % 5}`;
                    const isLastInBroker = idx === brokerGroups[brokerCode].length - 1;
                    const isLastBroker = brokerIdx === sortedBrokers.length - 1;
                    const boundaryClass = (isLastInBroker && isLastBroker) ? ' broker-boundary' : '';
                    headerRow2 += `<th class="number-col ${bgClass}${boundaryClass}">${displayName}</th>`;
                });
            });
            
            headerRow2 += '</tr>';
            elements.tableHeaders.innerHTML = headerRow1 + headerRow2;

            const sortedMonths = Object.keys(monthlyData).sort();
            const totals = { strategies: {}, totalProfits: 0, netBrProfits: 0, totalAmiPnl: 0, totalExpenses: 0, totalMarginSum: 0 };
            strategies.forEach(strat => {
                totals.strategies[strat] = { lot: 0, pnl: 0, dpnl: 0, net: 0, tradeCount: 0, lotSum: 0, lotCount: 0 };
            });
            
            const totalsToUse = showFilteredTotals ? monthlyFilteredTotals : monthlyTotals;
            Object.values(totalsToUse).forEach(monthTotal => {
                totals.totalProfits += monthTotal.total;
                totals.netBrProfits += monthTotal.net;
                totals.totalAmiPnl += (monthTotal.amiPnl || 0);
            });

            let bodyHtml = '';
            let previousMonthTotalMargin = 0;
            let monthIdx = 0;
            sortedMonths.forEach(month => {
                const displayMonth = monthNames[parseInt(month) - 1];
                bodyHtml += `<tr class="month-row" onclick="toggleMonth('${month}')">`;
                bodyHtml += `<td><span class="expand-icon" id="icon-${month}">▶</span>${displayMonth}</td>`;

                const totalsToUse = showFilteredTotals ? monthlyFilteredTotals : monthlyTotals;
                const monthTotal = totalsToUse[month]?.total || 0;
                const monthNetTotal = totalsToUse[month]?.net || 0;

                // First accumulate strategy data
                strategies.forEach((strategy) => {
                    const stratData = monthlyData[month][strategy] || { lot: 0, pnl: 0, dpnl: 0, net: 0, tradeCount: 0, lotSum: 0, lotCount: 0 };
                    const { pnl, dpnl, net, tradeCount, lotSum, lotCount } = stratData;

                    totals.strategies[strategy].lotSum += lotSum;
                    totals.strategies[strategy].lotCount += lotCount;
                    totals.strategies[strategy].pnl += pnl;
                    totals.strategies[strategy].dpnl += dpnl;
                    totals.strategies[strategy].net += net;
                    totals.strategies[strategy].tradeCount += tradeCount;
                });

                // Output A.PRO PNL columns
                aproStrategies.forEach((strategy, idx) => {
                    const stratData = monthlyData[month][strategy] || { lot: 0, pnl: 0, dpnl: 0, net: 0, tradeCount: 0, lotSum: 0, lotCount: 0 };
                    const pnl = stratData.pnl;
                    const stratIndex = allStrategies.indexOf(strategy);
                    const bgClass = `strategy-bg-${stratIndex % 5}`;
                    const boundaryClass = idx === aproStrategies.length - 1 ? ' apro-boundary' : '';
                    bodyHtml += `<td class="number-col apro-pnl-col ${bgClass} ${pnl >= 0 ? 'positive' : 'negative'}${boundaryClass}">${formatNumber(pnl)}</td>`;
                });
                
                // Output LOT columns grouped by broker
                if (showLot) {
                    sortedBrokers.forEach((brokerCode, brokerIdx) => {
                        brokerGroups[brokerCode].forEach((strategy, idx) => {
                            const stratData = monthlyData[month][strategy] || { lot: 0, pnl: 0, dpnl: 0, net: 0, tradeCount: 0, lotSum: 0, lotCount: 0 };
                            const { tradeCount, lotSum, lotCount } = stratData;
                            const lot = lotCount > 0 ? lotSum / lotCount : 0;
                            const stratIndex = allStrategies.indexOf(strategy);
                            const bgClass = `strategy-bg-${stratIndex % 5}`;
                            const isLastInBroker = idx === brokerGroups[brokerCode].length - 1;
                            const isLastBroker = brokerIdx === sortedBrokers.length - 1;
                            const boundaryClass = (isLastInBroker && isLastBroker) ? ' broker-boundary' : '';
                            const displayValue = showTradeCount ? (tradeCount > 0 ? tradeCount : '') : (lot > 0 ? lot.toFixed(2) : '');
                            bodyHtml += `<td class="number-col lot-col ${bgClass}${boundaryClass}">${displayValue}</td>`;
                        });
                    });
                }
                
                // Output DPNL columns grouped by broker
                sortedBrokers.forEach((brokerCode, brokerIdx) => {
                    brokerGroups[brokerCode].forEach((strategy, idx) => {
                        const stratData = monthlyData[month][strategy] || { lot: 0, pnl: 0, dpnl: 0, net: 0, tradeCount: 0, lotSum: 0, lotCount: 0 };
                        const dpnl = stratData.dpnl;
                        const stratIndex = allStrategies.indexOf(strategy);
                        const bgClass = `strategy-bg-${stratIndex % 5}`;
                        const isLastInBroker = idx === brokerGroups[brokerCode].length - 1;
                        const isLastBroker = brokerIdx === sortedBrokers.length - 1;
                        const boundaryClass = (isLastInBroker && isLastBroker) ? ' broker-boundary' : '';
                        bodyHtml += `<td class="number-col dpnl-section ${bgClass} ${dpnl >= 0 ? 'positive' : 'negative'}${boundaryClass}">${formatNumber(dpnl)}</td>`;
                    });
                });
                
                // Output PNL columns grouped by broker
                sortedBrokers.forEach((brokerCode, brokerIdx) => {
                    brokerGroups[brokerCode].forEach((strategy, idx) => {
                        const stratData = monthlyData[month][strategy] || { lot: 0, pnl: 0, dpnl: 0, net: 0, tradeCount: 0, lotSum: 0, lotCount: 0 };
                        let pnl;
                        if (showLotPnl) {
                            // Show LOT PNL = PNL / lot size (average lot)
                            const avgLot = stratData.lotCount > 0 ? (stratData.lotSum / stratData.lotCount) : 0;
                            pnl = avgLot > 0 ? (showPnlTax ? (stratData.net / avgLot) : (stratData.pnl / avgLot)) : 0;
                        } else {
                            pnl = showPnlTax ? stratData.net : stratData.pnl;
                        }
                        const stratIndex = allStrategies.indexOf(strategy);
                        const bgClass = `strategy-bg-${stratIndex % 5}`;
                        const isLastInBroker = idx === brokerGroups[brokerCode].length - 1;
                        const isLastBroker = brokerIdx === sortedBrokers.length - 1;
                        const boundaryClass = (isLastInBroker && isLastBroker) ? ' broker-boundary' : '';
                        bodyHtml += `<td class="number-col pnl-section ${bgClass} ${pnl >= 0 ? 'positive' : 'negative'}${boundaryClass}">${formatNumber(pnl)}</td>`;
                    });
                });

                // AMI PNL
                const monthAmiPnl = totalsToUse[month]?.amiPnl || 0;
                bodyHtml += `<td class="number-col total-net-col ${monthAmiPnl >= 0 ? 'positive' : 'negative'}">${formatNumber(monthAmiPnl)}</td>`;

                // NET PNL column - shows monthNetTotal when showPnlTax is true, otherwise shows monthTotal
                const netPnlValue = showPnlTax ? monthNetTotal : monthTotal;
                bodyHtml += `<td class="number-col total-net-col ${netPnlValue >= 0 ? 'positive' : 'negative'}">${formatNumber(netPnlValue)}</td>`;
                
                // NET PNL % calculation
                let netPnlPercent = 0;
                if (monthIdx === 0) {
                    // For first month, use first day's margin + PnL as base
                    const monthTrades = allTrades.filter(trade => {
                        const tradeParts = trade.date.split('/');
                        return tradeParts[1] === month;
                    });
                    
                    if (monthTrades.length > 0) {
                        const tradesByDate = {};
                        monthTrades.forEach(trade => {
                            const dateKey = trade.date;
                            if (!tradesByDate[dateKey]) {
                                tradesByDate[dateKey] = [];
                            }
                            tradesByDate[dateKey].push(trade);
                        });
                        
                        const sortedDates = Object.keys(tradesByDate).sort((a, b) => {
                            const dayA = parseInt(a.split('/')[0]);
                            const dayB = parseInt(b.split('/')[0]);
                            return dayA - dayB;
                        });
                        
                        if (sortedDates.length > 0) {
                            const firstDate = sortedDates[0];
                            const firstDateTrades = tradesByDate[firstDate];
                            
                            const firstDateBrokerMargins = {};
                            const allBrokerStrategies = allStrategies.filter(s => !s.startsWith('A.PRO'));
                            
                            firstDateTrades.forEach(trade => {
                                if (trade.strategyDetails) {
                                    allBrokerStrategies.forEach(brokerStrat => {
                                        const margin = trade.strategyDetails[brokerStrat]?.margin || 0;
                                        const brokerMatch = brokerStrat.match(/^(B\d+)/);
                                        if (brokerMatch && margin > 0) {
                                            const brokerCode = brokerMatch[1];
                                            if (!firstDateBrokerMargins[brokerCode]) {
                                                firstDateBrokerMargins[brokerCode] = {};
                                            }
                                            firstDateBrokerMargins[brokerCode][brokerStrat] = margin;
                                        }
                                    });
                                }
                            });
                            
                            let firstDateMargin = 0;
                            Object.keys(firstDateBrokerMargins).forEach(brokerCode => {
                                const margins = Object.values(firstDateBrokerMargins[brokerCode]);
                                if (margins.length > 0) {
                                    firstDateMargin += Math.max(...margins);
                                }
                            });
                            
                            let firstDatePnlTax = 0;
                            const firstDatePnlTaxMap = {};
                            firstDateTrades.forEach(trade => {
                                if (trade && trade.strategyPnlTax) {
                                    Object.entries(trade.strategyPnlTax).forEach(([stratName, pnlTax]) => {
                                        if (!stratName.startsWith('A.PRO')) {
                                            if (!firstDatePnlTaxMap[stratName]) {
                                                firstDatePnlTaxMap[stratName] = 0;
                                            }
                                            firstDatePnlTaxMap[stratName] += pnlTax;
                                        }
                                    });
                                }
                            });
                            firstDatePnlTax = Object.values(firstDatePnlTaxMap).reduce((sum, val) => sum + val, 0);
                            
                            const firstDateTotalMargin = firstDateMargin + firstDatePnlTax;
                            
                            if (firstDateTotalMargin !== 0) {
                                netPnlPercent = (monthNetTotal / firstDateTotalMargin) * 100;
                            }
                        }
                    }
                } else if (previousMonthTotalMargin === 0) {
                    netPnlPercent = 0;
                } else {
                    netPnlPercent = (monthNetTotal / previousMonthTotalMargin) * 100;
                }
                bodyHtml += `<td class="number-col net-pnl-percent-col ${netPnlPercent >= 0 ? 'positive' : 'negative'}">${netPnlPercent !== 0 ? netPnlPercent.toFixed(2) + '%' : ''}</td>`;
                
                // Expenses and TOTAL MARGIN - use calculated values
                const monthExpensesData = monthlyExpensesAndMargins[month] || { expenses: 0, totalMargin: 0 };
                const expenses = monthExpensesData.expenses;
                const totalMargin = monthExpensesData.totalMargin;
                
                // Accumulate total expenses
                totals.totalExpenses += expenses;
                
                // Accumulate total margin sum
                totals.totalMarginSum += totalMargin;
                
                // Store the last total margin globally
                globalLastTotalMargin = totalMargin;
                
                bodyHtml += `<td class="number-col expenses-col ${expenses >= 0 ? 'positive' : 'negative'}">${formatNumber(expenses)}</td>`;
                bodyHtml += `<td class="number-col total-net-col ${totalMargin >= 0 ? 'positive' : 'negative'}">${formatNumber(totalMargin)}</td>`;
                
                if (showDrawdown) {
                    const monthDrawdown = totalsToUse[month]?.drawdown || 0;
                    bodyHtml += `<td class="number-col drawdown-col negative">${formatNumber(monthDrawdown)}</td>`;
                }
                bodyHtml += '</tr>';
                
                // Update previous month total margin for next iteration
                previousMonthTotalMargin = totalMargin;

                if (dailyData[month]) {
                    const sortedDays = Object.keys(dailyData[month]).sort((a, b) => {
                        const dateA = a.split('/').reverse().join('');
                        const dateB = b.split('/').reverse().join('');
                        return dateA.localeCompare(dateB);
                    });

                    sortedDays.forEach(date => {
                        const dateParts = date.split('/');
                        const displayDate = `${dateParts[0]}-${monthNames[parseInt(dateParts[1]) - 1]}`;
                        bodyHtml += `<tr class="day-row" data-month="${month}"><td>${displayDate}</td>`;

                        const totalsToUse = showFilteredTotals ? dailyFilteredTotals : dailyTotals;
                        const dayTotal = totalsToUse[month][date]?.total || 0;
                        const dayNetTotal = totalsToUse[month][date]?.net || 0;

                        // Output A.PRO PNL columns
                        aproStrategies.forEach((strategy, idx) => {
                            const stratData = dailyData[month][date][strategy] || { lot: 0, pnl: 0, dpnl: 0, net: 0, tradeCount: 0, lotSum: 0, lotCount: 0 };
                            const pnl = stratData.pnl;
                            const stratIndex = allStrategies.indexOf(strategy);
                            const bgClass = `strategy-bg-${stratIndex % 5}`;
                            const boundaryClass = idx === aproStrategies.length - 1 ? ' apro-boundary' : '';
                            bodyHtml += `<td class="number-col apro-pnl-col ${bgClass} ${pnl >= 0 ? 'positive' : 'negative'}${boundaryClass}">${formatNumber(pnl)}</td>`;
                        });
                        
                        // Output LOT columns grouped by broker
                        if (showLot) {
                            sortedBrokers.forEach((brokerCode, brokerIdx) => {
                                brokerGroups[brokerCode].forEach((strategy, idx) => {
                                    const stratData = dailyData[month][date][strategy] || { lot: 0, pnl: 0, dpnl: 0, net: 0, tradeCount: 0, lotSum: 0, lotCount: 0 };
                                    const { tradeCount, lotSum, lotCount } = stratData;
                                    const lot = lotCount > 0 ? lotSum / lotCount : 0;
                                    const stratIndex = allStrategies.indexOf(strategy);
                                    const bgClass = `strategy-bg-${stratIndex % 5}`;
                                    const isLastInBroker = idx === brokerGroups[brokerCode].length - 1;
                                    const isLastBroker = brokerIdx === sortedBrokers.length - 1;
                                    const boundaryClass = (isLastInBroker && isLastBroker) ? ' broker-boundary' : '';
                                    const displayValue = showTradeCount ? (tradeCount > 0 ? tradeCount : '') : (lot > 0 ? lot.toFixed(2) : '');
                                    bodyHtml += `<td class="number-col lot-col ${bgClass}${boundaryClass}">${displayValue}</td>`;
                                });
                            });
                        }
                        
                        // Output DPNL columns grouped by broker
                        sortedBrokers.forEach((brokerCode, brokerIdx) => {
                            brokerGroups[brokerCode].forEach((strategy, idx) => {
                                const stratData = dailyData[month][date][strategy] || { lot: 0, pnl: 0, dpnl: 0, net: 0, tradeCount: 0, lotSum: 0, lotCount: 0 };
                                const dpnl = stratData.dpnl;
                                const stratIndex = allStrategies.indexOf(strategy);
                                const bgClass = `strategy-bg-${stratIndex % 5}`;
                                const isLastInBroker = idx === brokerGroups[brokerCode].length - 1;
                                const isLastBroker = brokerIdx === sortedBrokers.length - 1;
                                const boundaryClass = (isLastInBroker && isLastBroker) ? ' broker-boundary' : '';
                                bodyHtml += `<td class="number-col dpnl-section ${bgClass} ${dpnl >= 0 ? 'positive' : 'negative'}${boundaryClass}">${formatNumber(dpnl)}</td>`;
                            });
                        });
                        
                        // Output PNL columns grouped by broker
                        sortedBrokers.forEach((brokerCode, brokerIdx) => {
                            brokerGroups[brokerCode].forEach((strategy, idx) => {
                                const stratData = dailyData[month][date][strategy] || { lot: 0, pnl: 0, dpnl: 0, net: 0, tradeCount: 0, lotSum: 0, lotCount: 0 };
                                let pnl;
                                if (showLotPnl) {
                                    // Show LOT PNL = PNL / lot size (average lot)
                                    const avgLot = stratData.lotCount > 0 ? (stratData.lotSum / stratData.lotCount) : 0;
                                    pnl = avgLot > 0 ? (showPnlTax ? (stratData.net / avgLot) : (stratData.pnl / avgLot)) : 0;
                                } else {
                                    pnl = showPnlTax ? stratData.net : stratData.pnl;
                                }
                                const stratIndex = allStrategies.indexOf(strategy);
                                const bgClass = `strategy-bg-${stratIndex % 5}`;
                                const isLastInBroker = idx === brokerGroups[brokerCode].length - 1;
                                const isLastBroker = brokerIdx === sortedBrokers.length - 1;
                                const boundaryClass = (isLastInBroker && isLastBroker) ? ' broker-boundary' : '';
                                bodyHtml += `<td class="number-col pnl-section ${bgClass} ${pnl >= 0 ? 'positive' : 'negative'}${boundaryClass}">${formatNumber(pnl)}</td>`;
                            });
                        });

                        // AMI PNL
                        const dayAmiPnl = totalsToUse[month][date]?.amiPnl || 0;
                        bodyHtml += `<td class="number-col total-net-col ${dayAmiPnl >= 0 ? 'positive' : 'negative'}">${formatNumber(dayAmiPnl)}</td>`;

                        // NET PNL column - shows dayNetTotal when showPnlTax is true, otherwise shows dayTotal
                        const dayNetPnlValue = showPnlTax ? dayNetTotal : dayTotal;
                        bodyHtml += `<td class="number-col total-net-col ${dayNetPnlValue >= 0 ? 'positive' : 'negative'}">${formatNumber(dayNetPnlValue)}</td>`;
                        
                        // NET PNL % calculation for day rows
                        let dayNetPnlPercent = 0;
                        if (previousMonthTotalMargin !== 0) {
                            dayNetPnlPercent = (dayNetTotal / previousMonthTotalMargin) * 100;
                        }
                        bodyHtml += `<td class="number-col net-pnl-percent-col ${dayNetPnlPercent >= 0 ? 'positive' : 'negative'}">${dayNetPnlPercent !== 0 ? dayNetPnlPercent.toFixed(2) + '%' : ''}</td>`;
                        
                        // Expenses and TOTAL MARGIN (from pre-calculated data)
                        const dayExpense = dailyExpenses[date] || 0;
                        const dayTotalMargin = dailyTotalMargins[date] || 0;
                        bodyHtml += `<td class="number-col expenses-col ${dayExpense >= 0 ? 'positive' : 'negative'}">${formatNumber(dayExpense)}</td>`;
                        bodyHtml += `<td class="number-col total-net-col ${dayTotalMargin >= 0 ? 'positive' : 'negative'}">${dayTotalMargin > 0 ? formatNumber(dayTotalMargin) : ''}</td>`;
                        
                        if (showDrawdown) {
                            const dayDrawdown = (cumulativeData[month] && cumulativeData[month][date]) ? cumulativeData[month][date].drawdown : 0;
                            bodyHtml += `<td class="number-col drawdown-col negative">${formatNumber(dayDrawdown)}</td>`;
                        }
                        bodyHtml += '</tr>';
                    });
                }
                
                monthIdx++;
            });

            bodyHtml += '<tr class="total-row"><td>Grand Total</td>';
            
            // Output A.PRO PNL totals
            aproStrategies.forEach((strategy, idx) => {
                const stratTotal = totals.strategies[strategy];
                const stratIndex = allStrategies.indexOf(strategy);
                const bgClass = `strategy-bg-${stratIndex % 5}`;
                const boundaryClass = idx === aproStrategies.length - 1 ? ' apro-boundary' : '';
                bodyHtml += `<td class="number-col apro-pnl-col ${bgClass} ${stratTotal.pnl >= 0 ? 'positive' : 'negative'}${boundaryClass}">${formatNumber(stratTotal.pnl)}</td>`;
            });
            
            // Output LOT totals grouped by broker
            if (showLot) {
                sortedBrokers.forEach((brokerCode, brokerIdx) => {
                    brokerGroups[brokerCode].forEach((strategy, idx) => {
                        const stratTotal = totals.strategies[strategy];
                        const lot = stratTotal.lotCount > 0 ? stratTotal.lotSum / stratTotal.lotCount : 0;
                        const stratIndex = allStrategies.indexOf(strategy);
                        const bgClass = `strategy-bg-${stratIndex % 5}`;
                        const isLastInBroker = idx === brokerGroups[brokerCode].length - 1;
                        const isLastBroker = brokerIdx === sortedBrokers.length - 1;
                        const boundaryClass = (isLastInBroker && isLastBroker) ? ' broker-boundary' : '';
                        const displayValue = showTradeCount ? (stratTotal.tradeCount > 0 ? stratTotal.tradeCount : '') : (lot > 0 ? lot.toFixed(2) : '');
                        bodyHtml += `<td class="number-col lot-col ${bgClass}${boundaryClass}">${displayValue}</td>`;
                    });
                });
            }
            
            // Output DPNL totals grouped by broker
            sortedBrokers.forEach((brokerCode, brokerIdx) => {
                brokerGroups[brokerCode].forEach((strategy, idx) => {
                    const stratTotal = totals.strategies[strategy];
                    const stratIndex = allStrategies.indexOf(strategy);
                    const bgClass = `strategy-bg-${stratIndex % 5}`;
                    const isLastInBroker = idx === brokerGroups[brokerCode].length - 1;
                    const isLastBroker = brokerIdx === sortedBrokers.length - 1;
                    const boundaryClass = (isLastInBroker && isLastBroker) ? ' broker-boundary' : '';
                    bodyHtml += `<td class="number-col dpnl-section ${bgClass} ${stratTotal.dpnl >= 0 ? 'positive' : 'negative'}${boundaryClass}">${formatNumber(stratTotal.dpnl)}</td>`;
                });
            });
            
            // Output PNL totals grouped by broker
            sortedBrokers.forEach((brokerCode, brokerIdx) => {
                brokerGroups[brokerCode].forEach((strategy, idx) => {
                    const stratTotal = totals.strategies[strategy];
                    let pnlValue;
                    if (showLotPnl) {
                        // Show LOT PNL = PNL / lot size (average lot)
                        const avgLot = stratTotal.lotCount > 0 ? (stratTotal.lotSum / stratTotal.lotCount) : 0;
                        pnlValue = avgLot > 0 ? (showPnlTax ? (stratTotal.net / avgLot) : (stratTotal.pnl / avgLot)) : 0;
                    } else {
                        pnlValue = showPnlTax ? stratTotal.net : stratTotal.pnl;
                    }
                    const stratIndex = allStrategies.indexOf(strategy);
                    const bgClass = `strategy-bg-${stratIndex % 5}`;
                    const isLastInBroker = idx === brokerGroups[brokerCode].length - 1;
                    const isLastBroker = brokerIdx === sortedBrokers.length - 1;
                    const boundaryClass = (isLastInBroker && isLastBroker) ? ' broker-boundary' : '';
                    bodyHtml += `<td class="number-col pnl-section ${bgClass} ${pnlValue >= 0 ? 'positive' : 'negative'}${boundaryClass}">${formatNumber(pnlValue)}</td>`;
                });
            });
            
            // AMI PNL total
            bodyHtml += `<td class="number-col total-net-col ${totals.totalAmiPnl >= 0 ? 'positive' : 'negative'}">${formatNumber(totals.totalAmiPnl)}</td>`;
            
            // NET PNL column - shows totals.netBrProfits when showPnlTax is true, otherwise shows totals.totalProfits
            const totalNetPnlValue = showPnlTax ? totals.netBrProfits : totals.totalProfits;
            bodyHtml += `<td class="number-col total-net-col ${totalNetPnlValue >= 0 ? 'positive' : 'negative'}">${formatNumber(totalNetPnlValue)}</td>`;
            
            // NET PNL % total
            const totalNetPnlPercent = totals.totalMarginSum !== 0 ? (totals.netBrProfits / totals.totalMarginSum) * 100 : 0;
            bodyHtml += `<td class="number-col net-pnl-percent-col ${totalNetPnlPercent >= 0 ? 'positive' : 'negative'}">${totalNetPnlPercent !== 0 ? totalNetPnlPercent.toFixed(2) + '%' : ''}</td>`;
            
            // Expenses total and TOTAL MARGIN (empty)
            bodyHtml += `<td class="number-col expenses-col ${totals.totalExpenses >= 0 ? 'positive' : 'negative'}">${formatNumber(totals.totalExpenses)}</td>`;
            bodyHtml += `<td class="number-col total-net-col"></td>`;
            
            if (showDrawdown) {
                let maxDrawdown = 0;
                Object.values(cumulativeData).forEach(monthData => {
                    Object.values(monthData).forEach(dayData => {
                        if (dayData.drawdown > maxDrawdown) maxDrawdown = dayData.drawdown;
                    });
                });
                bodyHtml += `<td class="number-col drawdown-col negative">${formatNumber(maxDrawdown)}</td>`;
            }
            bodyHtml += '</tr>';

            elements.tableBody.innerHTML = bodyHtml;
            
            // Store total expenses globally for summary cards
            globalTotalExpenses = totals.totalExpenses;
        }

        function toggleMonth(month) {
            const dayRows = document.querySelectorAll(`.day-row[data-month="${month}"]`);
            const icon = document.getElementById(`icon-${month}`);
            dayRows.forEach(row => row.classList.toggle('expanded'));
            if (icon) icon.classList.toggle('expanded');
        }

        function expandAll() {
            document.querySelectorAll('.day-row').forEach(row => row.classList.add('expanded'));
            document.querySelectorAll('.expand-icon').forEach(icon => icon.classList.add('expanded'));
        }

        function collapseAll() {
            document.querySelectorAll('.day-row').forEach(row => row.classList.remove('expanded'));
            document.querySelectorAll('.expand-icon').forEach(icon => icon.classList.remove('expanded'));
        }

        function updateSummaryCards(trades) {
            const allMonthlyProfits = {};
            const allMonthlyNetProfits = {};
            let runningCumTotal = 0;
            let peakCumTotal = 0;
            let currentDrawdown = 0;
            const strategyTracking = {};
            
            const sortedAllTrades = [...allTrades].sort((a, b) => {
                const dateA = a.date.split('/').reverse().join('');
                const dateB = b.date.split('/').reverse().join('');
                return dateA.localeCompare(dateB);
            });
            
            // Calculate starting capital from first date of FIRST MONTH only
            globalStartingCapital = 0;
            if (sortedAllTrades.length > 0) {
                // Group trades by month
                const tradesByMonth = {};
                sortedAllTrades.forEach(trade => {
                    const monthKey = trade.date.split('/')[1];
                    if (!tradesByMonth[monthKey]) {
                        tradesByMonth[monthKey] = [];
                    }
                    tradesByMonth[monthKey].push(trade);
                });
                
                const sortedMonths = Object.keys(tradesByMonth).sort();
                if (sortedMonths.length > 0) {
                    const firstMonth = sortedMonths[0];
                    const firstMonthTrades = tradesByMonth[firstMonth];
                    
                    // Get first date in first month
                    const tradesByDate = {};
                    firstMonthTrades.forEach(trade => {
                        const dateKey = trade.date;
                        if (!tradesByDate[dateKey]) {
                            tradesByDate[dateKey] = [];
                        }
                        tradesByDate[dateKey].push(trade);
                    });
                    
                    const sortedDatesInMonth = Object.keys(tradesByDate).sort((a, b) => {
                        const dayA = parseInt(a.split('/')[0]);
                        const dayB = parseInt(b.split('/')[0]);
                        return dayA - dayB;
                    });
                    
                    if (sortedDatesInMonth.length > 0) {
                        const firstDate = sortedDatesInMonth[0];
                        const firstDateTrades = tradesByDate[firstDate];
                        
                        const firstDateBrokerMargins = {};
                        const allBrokerStrategies = allStrategies.filter(s => !s.startsWith('A.PRO'));
                        
                        firstDateTrades.forEach(trade => {
                            if (trade.strategyDetails) {
                                allBrokerStrategies.forEach(brokerStrat => {
                                    const margin = trade.strategyDetails[brokerStrat]?.margin || 0;
                                    const brokerMatch = brokerStrat.match(/^(B\d+)/);
                                    if (brokerMatch && margin > 0) {
                                        const brokerCode = brokerMatch[1];
                                        if (!firstDateBrokerMargins[brokerCode]) {
                                            firstDateBrokerMargins[brokerCode] = {};
                                        }
                                        firstDateBrokerMargins[brokerCode][brokerStrat] = margin;
                                    }
                                });
                            }
                        });
                        
                        Object.keys(firstDateBrokerMargins).forEach(brokerCode => {
                            const margins = Object.values(firstDateBrokerMargins[brokerCode]);
                            if (margins.length > 0) {
                                globalStartingCapital += Math.max(...margins);
                            }
                        });
                    }
                }
            }
            
            sortedAllTrades.forEach(trade => {
                const monthKey = trade.date.split('/')[1];
                if (!allMonthlyProfits[monthKey]) allMonthlyProfits[monthKey] = 0;
                if (!allMonthlyNetProfits[monthKey]) allMonthlyNetProfits[monthKey] = 0;
                
                Object.entries(trade.strategyDetails).forEach(([stratName, details]) => {
                    if (!stratName.startsWith('A.PRO')) {
                        const netPnl = trade.strategyPnlTax[stratName] || 0;
                        allMonthlyProfits[monthKey] += (trade.strategyPnls[stratName] || 0);
                        allMonthlyNetProfits[monthKey] += netPnl;
                        
                        runningCumTotal += netPnl;
                        if (runningCumTotal > peakCumTotal) peakCumTotal = runningCumTotal;
                        
                        if (!strategyTracking[stratName]) {
                            strategyTracking[stratName] = { cumTotal: 0, peak: 0, drawdown: 0 };
                        }
                        strategyTracking[stratName].cumTotal += netPnl;
                        if (strategyTracking[stratName].cumTotal > strategyTracking[stratName].peak) {
                            strategyTracking[stratName].peak = strategyTracking[stratName].cumTotal;
                        }
                        strategyTracking[stratName].drawdown = strategyTracking[stratName].peak - strategyTracking[stratName].cumTotal;
                    }
                });
            });
            
            currentDrawdown = peakCumTotal - runningCumTotal;

            const totalProfitAll = Object.values(allMonthlyProfits).reduce((sum, val) => sum + val, 0);
            const netBrProfitAll = Object.values(allMonthlyNetProfits).reduce((sum, val) => sum + val, 0);

            // Update Starting Capital
            if (elements.startingCapital) {
                elements.startingCapital.textContent = globalStartingCapital > 0 ? '₹' + globalStartingCapital.toLocaleString('en-IN', {maximumFractionDigits: 0}) : '-';
                elements.startingCapital.className = 'summary-card-value';
            }

            // Update Running Profit as PERCENTAGE
            if (elements.runningProfit) {
                if (globalStartingCapital > 0 && netBrProfitAll !== 0) {
                    const profitPercent = (netBrProfitAll / globalStartingCapital) * 100;
                    elements.runningProfit.textContent = profitPercent.toFixed(2) + '%';
                    elements.runningProfit.className = `summary-card-value ${profitPercent >= 0 ? 'positive' : 'negative'}`;
                } else {
                    elements.runningProfit.textContent = '-';
                    elements.runningProfit.className = 'summary-card-value';
                }
            }

            // Update Net Broker Profit without percentage
            elements.netBrProfit.textContent = `₹${netBrProfitAll >= 0 ? '' : '-'}${Math.abs(netBrProfitAll).toLocaleString('en-IN', {maximumFractionDigits: 0})}`;
            elements.netBrProfit.className = `summary-card-value ${netBrProfitAll >= 0 ? 'positive' : 'negative'}`;


            const chargesAll = totalProfitAll - netBrProfitAll;
            elements.charges.textContent = `₹-${Math.abs(chargesAll).toLocaleString('en-IN', {maximumFractionDigits: 0})}`;

            // Update Running Margin stat - use the last month's total margin
            if (elements.runningMargin) {
                if (globalLastTotalMargin > 0) {
                    elements.runningMargin.textContent = `₹${globalLastTotalMargin.toLocaleString('en-IN', {maximumFractionDigits: 0})}`;
                    elements.runningMargin.className = 'summary-card-value ' + (globalLastTotalMargin >= 0 ? 'positive' : 'negative');
                } else {
                    elements.runningMargin.textContent = '-';
                    elements.runningMargin.className = 'summary-card-value';
                }
            }
            
            // Update Total Expense stat - use accumulated expenses from table
            if (elements.totalExpense) {
                elements.totalExpense.textContent = `₹${globalTotalExpenses >= 0 ? '' : '-'}${Math.abs(globalTotalExpenses).toLocaleString('en-IN', {maximumFractionDigits: 0})}`;
                elements.totalExpense.className = 'summary-card-value ' + (globalTotalExpenses >= 0 ? 'positive' : 'negative');
            }
            
            // Update Total Net Profit stat (Net Broker Profit + Total Expense)
            const netProfitValue = netBrProfitAll + globalTotalExpenses;
            if (elements.netProfit) {
                elements.netProfit.textContent = `₹${netProfitValue >= 0 ? '' : '-'}${Math.abs(netProfitValue).toLocaleString('en-IN', {maximumFractionDigits: 0})}`;
                elements.netProfit.className = 'summary-card-value ' + (netProfitValue >= 0 ? 'positive' : 'negative');
            }
        }

        function exportToCSV() {
            const table = document.getElementById('performanceTable');
            const rows = [];
            
            // Process header rows specially
            const headerRow1 = table.querySelector('thead tr.header-row-1');
            const headerRow2 = table.querySelector('thead tr.header-row-2');
            
            if (headerRow1 && headerRow2) {
                const headers1 = [];
                const headers2 = [];
                
                // Process first header row
                headerRow1.querySelectorAll('th').forEach(th => {
                    const text = th.textContent.trim();
                    const colspan = parseInt(th.getAttribute('colspan')) || 1;
                    const rowspan = parseInt(th.getAttribute('rowspan')) || 1;
                    
                    // Add header text for colspan times
                    for (let i = 0; i < colspan; i++) {
                        headers1.push(rowspan === 2 ? text : text);
                    }
                });
                
                // Process second header row
                headerRow2.querySelectorAll('th').forEach(th => {
                    const text = th.textContent.trim();
                    headers2.push(text);
                });
                
                // Merge headers - for rowspan=2 columns, use only row1, otherwise combine row1 and row2
                const finalHeaders = [];
                let row2Index = 0;
                
                headerRow1.querySelectorAll('th').forEach(th => {
                    const text = th.textContent.trim();
                    const colspan = parseInt(th.getAttribute('colspan')) || 1;
                    const rowspan = parseInt(th.getAttribute('rowspan')) || 1;
                    
                    if (rowspan === 2) {
                        // Single column header (spans both rows)
                        finalHeaders.push(text);
                    } else {
                        // Multi-column header (has sub-headers in row 2)
                        for (let i = 0; i < colspan; i++) {
                            const subHeader = headers2[row2Index] || '';
                            if (text && subHeader) {
                                finalHeaders.push(`${text} ${subHeader}`);
                            } else {
                                finalHeaders.push(text || subHeader);
                            }
                            row2Index++;
                        }
                    }
                });
                
                // Add header row to CSV
                rows.push(finalHeaders.map(h => {
                    if (h.includes(',') || h.includes('"') || h.includes('\n')) {
                        return '"' + h.replace(/"/g, '""') + '"';
                    }
                    return h;
                }).join(','));
            }
            
            // Process data rows
            const bodyRows = table.querySelectorAll('tbody tr');
            
            bodyRows.forEach(row => {
                // Skip rows that are hidden (day rows that aren't expanded)
                if (row.classList.contains('day-row') && !row.classList.contains('expanded')) {
                    return;
                }
                
                const cells = row.querySelectorAll('td');
                const rowData = [];
                
                cells.forEach(cell => {
                    // Get text content and clean it
                    let text = cell.textContent.trim();
                    
                    // Remove expand icons
                    text = text.replace(/[►▼]/g, '').trim();
                    
                    // Escape quotes and wrap in quotes if contains comma
                    if (text.includes(',') || text.includes('"') || text.includes('\n')) {
                        text = '"' + text.replace(/"/g, '""') + '"';
                    }
                    
                    rowData.push(text);
                });
                
                if (rowData.length > 0) {
                    rows.push(rowData.join(','));
                }
            });
            
            // Create CSV content
            const csvContent = rows.join('\n');
            
            // Create blob and download
            const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
            const link = document.createElement('a');
            
            // Generate filename with current date
            const today = new Date();
            const dateStr = today.toISOString().split('T')[0];
            const filename = `Strategy_Performance_${dateStr}.csv`;
            
            if (navigator.msSaveBlob) {
                // IE 10+
                navigator.msSaveBlob(blob, filename);
            } else {
                link.href = URL.createObjectURL(blob);
                link.download = filename;
                link.style.display = 'none';
                document.body.appendChild(link);
                link.click();
                document.body.removeChild(link);
            }
        }

    </script>
</body>
</html>
