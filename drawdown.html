<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Drawdown Analysis</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <style> *{margin:0;padding:0;box-sizing:border-box;}html,body{width:100%;height:100%;overflow:hidden;}body{font-family:'Inter', -apple-system,BlinkMacSystemFont,'Segoe UI',Roboto,sans-serif;background:#f8fafc;color:#1e293b;}.container{overflow-y:auto;padding:16px 32px 32px;height:100vh;}.header{margin-bottom:16px;}.header h1{font-size:20px;font-weight:700;color:#111827;margin-bottom:4px;letter-spacing:-0.5px;}.header p{font-size:11px;color:#6b7280;}.summary-cards{display:flex;gap:12px;margin-bottom:16px;overflow-x:auto;}.summary-card{background:white;border-radius:8px;padding:10px 12px;box-shadow:0 1px 3px rgba(0,0,0,0.08);border:1px solid #e5e7eb;flex:1 1 0;min-width:140px;}.summary-card-label{font-size:10px;color:#6b7280;text-transform:uppercase;letter-spacing:0.5px;margin-bottom:5px;font-weight:700;}.summary-card-value{font-size:18px;font-weight:700;line-height:1.2;}.summary-card-value.positive{color:#059669;}.summary-card-value.negative{color:#92400e;}.summary-card.broker-margin-box{background:#f0fdf4;}.summary-card.stg-margin-box{background:#fffbeb;}.summary-card.drawdown-box{background:#fdf2f8;}.controls{display:flex;gap:16px;margin-bottom:16px;flex-wrap:wrap;align-items:center;width:100%;}.control-group{display:flex;align-items:center;gap:8px;flex:1 1 0;min-width:fit-content;}.control-label{font-size:11px;color:#374151;font-weight:600;}select,input[type="number"],input[type="text"],.btn{padding:7px 12px;border:1px solid #d1d5db;border-radius:8px;font-size:11px;font-weight:500;background:white;color:#374151;cursor:pointer;transition:all 0.15s;font-family:inherit;white-space:nowrap;min-width:fit-content;}select:hover,input:hover,.btn:hover{border-color:#9ca3af;background:#f9fafb;}select:focus,input:focus{outline:none;border-color:#3b82f6;box-shadow:0 0 0 3px rgba(59,130,246,0.1);}.custom-date-range{display:flex;gap:4px;align-items:center;padding:4px 8px;background:transparent;border-radius:6px;}.custom-date-range label{font-size:10px;font-weight:600;color:#64748b;text-transform:uppercase;letter-spacing:0.5px;}.custom-date-range input[type="date"]{padding:4px 6px;font-size:10px;border:1px solid #e5e7eb;border-radius:4px;font-family:inherit;color:#475569;cursor:pointer;background:transparent;}.date-nav-arrows{display:flex;flex-direction:column;gap:1px;margin-left:2px;}.date-nav-arrows button{padding:0;width:16px;height:11px;font-size:8px;line-height:1;border:1px solid #e5e7eb;background:transparent;color:#64748b;border-radius:2px;cursor:pointer;display:flex;align-items:center;justify-content:center;transition:all 0.15s ease;}.date-nav-arrows button:hover{background:transparent;color:#475569;border-color:#cbd5e1;}.date-range-buttons{display:flex;gap:4px;}.date-range-buttons .btn{padding:6px 12px;font-size:10px;font-weight:600;color:#64748b;background:transparent;border:none;border-radius:6px;cursor:pointer;transition:all 0.2s ease;text-transform:uppercase;letter-spacing:0.5px;}.date-range-buttons .btn:hover{background:#e2e8f0;color:#475569;}.date-range-buttons .btn.active{background:white;color:#3b82f6;border:1px solid #3b82f6;}.strategy-selector{position:relative;width:100%;}.strategy-dropdown-btn{display:flex;align-items:center;justify-content:center;gap:8px;padding:7px 12px;border:1px solid #d1d5db;border-radius:8px;background:white;cursor:pointer;font-size:11px;font-weight:500;font-family:inherit;color:#374151;white-space:nowrap;transition:all 0.15s;width:100%;}.strategy-dropdown-btn:hover{border-color:#9ca3af;background:#f9fafb;}.dropdown-badge{background:#3b82f6;color:white;padding:2px 6px;border-radius:10px;font-size:10px;font-weight:600;}.strategy-dropdown-menu{display:none;position:absolute;top:100%;left:0;margin-top:6px;background:white;border:1px solid #d1d5db;border-radius:10px;box-shadow:0 10px 15px rgba(0,0,0,0.1);min-width:200px;max-height:400px;overflow-y:auto;z-index:1000;}.strategy-dropdown-menu.show{display:block;}.broker-dropdown-menu{min-width:150px;max-width:180px;}.broker-dropdown-menu .dropdown-header{padding:10px 12px;}.broker-dropdown-menu .dropdown-option{padding:7px 12px;}.broker-dropdown-menu .dropdown-option label{font-size:12px;}.dropdown-header{padding:12px 14px;border-bottom:1px solid #e2e8f0;display:flex;justify-content:space-between;}.dropdown-action-btn{font-size:11px;color:#1e40af;cursor:pointer;padding:4px 8px;border-radius:4px;background:none;border:none;}.dropdown-action-btn:hover{background:#eff6ff;}.dropdown-options{padding:8px 0;}.dropdown-option{display:flex;align-items:center;padding:8px 14px;cursor:pointer;}.dropdown-option:hover{background:#f8fafc;}.dropdown-option input{margin-right:10px;cursor:pointer;}.dropdown-option label{font-size:13px;color:#475569;cursor:pointer;flex:1;}.table-container{background:white;border-radius:12px;box-shadow:0 1px 3px rgba(0,0,0,0.08);border:1px solid #e5e7eb;}table{width:100%;border-collapse:separate;border-spacing:0;table-layout:fixed;font-size:11.5px;font-family:'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;font-variant-numeric:tabular-nums;}thead{background:#f3f4f6;position:sticky;top:0;z-index:10;}th{padding:12px;text-align:left;font-size:11px;font-weight:700;color:#1f2937;text-transform:uppercase;letter-spacing:0.5px;border-bottom:2px solid #d1d5db;border-right:1px solid #e5e7eb;cursor:pointer;white-space:nowrap;font-variant-numeric:tabular-nums;}th:nth-child(n+2){text-align:right;}th:last-child{border-right:none;}th:nth-child(1),td:nth-child(1){min-width:160px;width:160px;}th:nth-child(2),td:nth-child(2){width:85px;min-width:85px;max-width:85px;}th:nth-child(3),td:nth-child(3),th:nth-child(4),td:nth-child(4),th:nth-child(5),td:nth-child(5){width:105px;min-width:105px;max-width:105px;}th:nth-child(6),td:nth-child(6){width:95px;min-width:95px;max-width:95px;}th:nth-child(7),td:nth-child(7),th:nth-child(8),td:nth-child(8),th:nth-child(9),td:nth-child(9),th:nth-child(10),td:nth-child(10){width:95px;min-width:95px;max-width:95px;}th:nth-child(11),td:nth-child(11){width:85px;min-width:85px;max-width:85px;}th:nth-child(12),td:nth-child(12),th:nth-child(13),td:nth-child(13){width:90px;min-width:90px;max-width:90px;}th:nth-child(14),td:nth-child(14),th:nth-child(15),td:nth-child(15){width:95px;min-width:95px;max-width:95px;}td{padding:12px;border-right:1px solid #f3f4f6;color:#374151;font-size:11px;vertical-align:middle;}td:nth-child(n+2){text-align:right;}td:last-child{border-right:none;}tbody tr{background:white;border-bottom:1px solid #f3f4f6;transition:opacity 0.15s;}tbody tr:hover{opacity:0.9;}.empty-state{text-align:left !important;padding:12px !important;color:#6b7280;font-size:11px;font-weight:400;}.negative{color:#92400e;}.positive{color:#059669;}.neutral{color:#6b7280;}body[data-view="broker"] .group-row,body[data-view="broker"] .child-row{display:none;}body[data-view="account"] .broker-row,body[data-view="account"] .child-row{display:none;}body[data-view="strategy"] .broker-row,body[data-view="strategy"] .group-row{display:none;}body[data-view="broker"] .group-b1,body[data-view="broker"] .group-b2,body[data-view="broker"] .child-row-b1,body[data-view="broker"] .child-row-b2{display:none;}body[data-view="account"] .child-row-b1,body[data-view="account"] .child-row-b2{display:none;}body[data-view="strategy"] .group-b1,body[data-view="strategy"] .group-b2{display:none;}.broker-row{background:#f3f4f6 !important;font-weight:600;}.broker-row:hover{background:#e5e7eb !important;}.broker-row td{border-right:1px solid #d1d5db;color:#000000;font-size:12px;}.broker-name{font-size:12px !important;font-weight:600 !important;color:#000000 !important;}#brokerLevelTableBody td{font-size:12px;padding:10px 12px;border-right:1px solid #fed7aa;}#brokerLevelTableBody td:last-child{border-right:none;}#brokerLevelTableBody tr{background:#fffbf5;}#brokerLevelTableBody tr:hover{background:#fff7ed;}.group-b1{background:#fce7f3 !important;font-weight:600;}.group-b1:hover{background:#fbcfe8 !important;}.group-b1 td{border-right:1px solid #f9a8d4;color:#831843;font-size:11.5px;}.group-b1 .group-name{font-size:11.5px !important;font-weight:600 !important;color:#9f1239 !important;padding-left:20px !important;}.child-row-b1{background:#fff9fb !important;}.child-row-b1:hover{background:#fce7f3 !important;}.child-row-b1 td{border-right:1px solid #fecdd3;color:#7f1d1d;font-size:11.5px;}.group-b1 .rowspan-cell{background:#fff9fb !important;}.group-b2{background:#ffedd5 !important;font-weight:600;}.group-b2:hover{background:#fed7aa !important;}.group-b2 td{border-right:1px solid #fdba74;color:#7c2d12;font-size:11.5px;}.group-b2 .group-name{font-size:11.5px !important;font-weight:600 !important;color:#9a3412 !important;padding-left:20px !important;}.child-row-b2{background:#fffbf5 !important;}.child-row-b2:hover{background:#ffedd5 !important;}.child-row-b2 td{border-right:1px solid #fed7aa;color:#7c2d12;font-size:11.5px;}.group-b2 .rowspan-cell{background:#fffbf5 !important;}.group-row{background:#f8fafc;font-weight:600;}.group-row td{font-size:11.5px;}.group-name{font-weight:600;font-size:11.5px;color:#475569;padding-left:20px;}.child-row{background:white;}.child-row td{font-size:11.5px;}@media screen and (min-width:769px) and (max-width:1024px){.summary-cards{display:grid;grid-template-columns:repeat(4,1fr);gap:12px;flex-wrap:wrap;overflow-x:visible;}.summary-card{min-width:auto;flex:none;}}@media screen and (max-width:768px){.container{padding:12px 16px 24px 16px;}.header h1{font-size:18px;}.header p{font-size:11px;}.controls{display:flex;flex-wrap:wrap;gap:10px;margin-bottom:16px;}.control-group{flex:1 1 48%;min-width:0;}.control-label{font-size:11px;white-space:nowrap;}select,input[type="number"],input[type="text"],.btn{padding:10px 12px;font-size:11px;width:100%;}.strategy-selector{width:100%;}.strategy-dropdown-btn{width:100%;padding:10px 12px;font-size:11px;}.strategy-dropdown-menu{left:0;right:0;min-width:auto;width:calc(100vw - 32px);max-height:60vh;}.summary-cards{display:grid;grid-template-columns:repeat(2,1fr);gap:10px;flex-wrap:wrap;overflow-x:visible;margin-bottom:16px;}.summary-card{min-width:auto;flex:none;padding:14px 16px;}.summary-card-label{font-size:11px;}.summary-card-value{font-size:20px;}.table-container{margin:0 -16px;border-radius:0;border-left:none;border-right:none;}table{font-size:11px;}th,td{padding:10px 6px;font-size:11px;}th{font-size:9px;}.broker-row td,.group-row td,.child-row td{font-size:10px;padding:8px 6px;}}@media screen and (max-width:480px){.container{padding:10px 12px 20px 12px;}.header h1{font-size:16px;}.header p{font-size:10px;}.controls{gap:8px;margin-bottom:14px;}.control-label{font-size:10px;}select,input[type="number"],input[type="text"],.btn{padding:9px 10px;font-size:11px;}.strategy-dropdown-btn{padding:9px 10px;font-size:11px;}.summary-card{padding:12px 14px;min-width:auto;}.summary-cards{gap:8px;display:grid;grid-template-columns:repeat(2,1fr);}.summary-card-label{font-size:10px;}.summary-card-value{font-size:18px;}.table-container{margin:0 -12px;}table{font-size:10px;}th,td{padding:8px 4px;font-size:10px;}th{font-size:8px;}.broker-row td,.group-row td,.child-row td{font-size:9px;padding:6px 4px;}.strategy-dropdown-menu{width:calc(100vw - 24px);max-height:50vh;}.dropdown-badge{font-size:8px;padding:1px 4px;}}@media screen and (max-width:360px){.container{padding:8px 10px 16px 10px;}.header h1{font-size:15px;}.controls{gap:6px;}.control-label{font-size:9px;}select,input[type="number"],input[type="text"],.btn{padding:8px 8px;font-size:10px;}.strategy-dropdown-btn{padding:8px 8px;font-size:10px;}.summary-cards{gap:6px;display:grid;grid-template-columns:repeat(2,1fr);}.summary-card{padding:10px 12px;min-width:auto;}.summary-card-label{font-size:9px;}.summary-card-value{font-size:15px;}table{font-size:9px;}th{font-size:7px;padding:6px 3px;}td{padding:6px 3px;font-size:9px;}.broker-row td,.group-row td,.child-row td{font-size:8px;}}
</style>
</head>
<body data-view="all">
    <div class="container">
        <div class="header" style="display: flex; justify-content: space-between; align-items: flex-start; margin-bottom: 16px;">
            <div>
                <h1>Drawdown Analysis</h1>
                <p>Detailed drawdown analysis with broker, account, and strategy hierarchy</p>
            </div>
            <!-- Date Range Controls aligned to right -->
            <div style="display: flex; gap: 3px; align-items: center; padding: 5px 6px; background: #f1f5f9; border-radius: 8px; white-space: nowrap;">
                <div class="custom-date-range" style="padding: 0px 2px;">
                    <label style="font-size: 10px;">FROM:</label>
                    <input type="date" id="fromDate" style="width: 95px; padding: 5px 4px; font-size: 10px;">
                    <div class="date-nav-arrows">
                        <button onclick="navigateFromDate('prev')" title="Previous month start">▲</button>
                        <button onclick="navigateFromDate('next')" title="Next month start">▼</button>
                    </div>
                </div>
                <div class="custom-date-range" style="padding: 0px 2px;">
                    <label style="font-size: 10px;">TO:</label>
                    <input type="date" id="toDate" style="width: 95px; padding: 5px 4px; font-size: 10px;">
                    <div class="date-nav-arrows">
                        <button onclick="navigateToDate('prev')" title="Previous month end">▲</button>
                        <button onclick="navigateToDate('next')" title="Next month end">▼</button>
                    </div>
                </div>
                <div class="date-range-buttons" style="gap: 2px;">
                    <button class="btn" onclick="setDateRange('3M')" style="padding: 5px 8px; font-size: 10px;">LAST 3M</button>
                    <button class="btn" onclick="setDateRange('YTD')" style="padding: 5px 8px; font-size: 10px;">YTD</button>
                    <button class="btn" onclick="setDateRange('ALL')" style="padding: 5px 8px; font-size: 10px;">ALL TIME</button>
                </div>
            </div>
        </div>
        
        <div class="summary-cards">
            <div class="summary-card broker-margin-box">
                <div class="summary-card-label">Total Broker Margin</div>
                <div class="summary-card-value" id="totalBrokerMargin">-</div>
            </div>
            <div class="summary-card stg-margin-box">
                <div class="summary-card-label">Total Stg Margin</div>
                <div class="summary-card-value" id="totalStgMargin">-</div>
            </div>
            <div class="summary-card drawdown-box">
                <div class="summary-card-label">Total Current DD (₹)</div>
                <div class="summary-card-value negative" id="totalCurrentDDRupees">-</div>
            </div>
            <div class="summary-card">
                <div class="summary-card-label">Total Current DD (%)</div>
                <div class="summary-card-value negative" id="totalCurrentDDPercent">-</div>
            </div>
            <div class="summary-card drawdown-box">
                <div class="summary-card-label">ALL ACCOUNT DD(₹)</div>
                <div class="summary-card-value negative" id="stgDDFromB">-</div>
            </div>
            <!-- Broker-wise DD cards will be dynamically added here -->
        </div>
        <div class="controls">
            <div class="control-group">
                <div class="strategy-selector">
                    <button class="strategy-dropdown-btn" onclick="toggleStrategyDropdown(event)">
                        <span>Select Strategies</span>
                        <span class="dropdown-badge" id="selectedCount" style="display: none;">0</span>
                        <span>▼</span>
                    </button>
                    <div class="strategy-dropdown-menu" id="strategyDropdownMenu">
                        <div class="dropdown-header">
                            <button class="dropdown-action-btn" onclick="selectAllStrategies()">All</button>
                            <button class="dropdown-action-btn" onclick="selectNoneStrategies()">None</button>
                        </div>
                        <div class="dropdown-options" id="strategyOptions"></div>
                    </div>
                </div>
            </div>
            <div class="control-group">
                <div class="strategy-selector">
                    <button class="strategy-dropdown-btn" onclick="toggleBrokerDropdown(event)">
                        <span>Select Brokers</span>
                        <span class="dropdown-badge" id="brokerSelectedCount" style="display: none;">0</span>
                        <span>▼</span>
                    </button>
                    <div class="strategy-dropdown-menu broker-dropdown-menu" id="brokerDropdownMenu">
                        <div class="dropdown-header">
                            <button class="dropdown-action-btn" onclick="selectAllBrokers()">All</button>
                            <button class="dropdown-action-btn" onclick="selectNoneBrokers()">None</button>
                        </div>
                        <div class="dropdown-options" id="brokerOptions"></div>
                    </div>
                </div>
            </div>
            <div class="control-group">
                <label class="control-label">Lot Margin:</label>
                <input type="text" id="lotMarginInput" value="4,00,000" onfocus="removeFormatting(this)" onblur="formatLotMarginInput(this)" oninput="updateLotMarginValue(this)">
            </div>
            <div class="control-group">
                <label class="control-label">Min DD % Filter:</label>
                <input type="number" id="minDrawdownFilter" placeholder="e.g., -10" step="0.1" oninput="applyFilters()">
            </div>
            <div class="control-group">
                <label class="control-label">View Type:</label>
                <select id="viewTypeFilter" onchange="applyFilters()">
                    <option value="all">All Levels</option>
                    <option value="broker">Broker Only</option>
                    <option value="account">Account Only</option>
                    <option value="strategy">Strategy Only</option>
                </select>
            </div>
            <div class="control-group">
                <label class="control-label">Sort By:</label>
                <select id="sortSelect" onchange="handleSortSelect()">
                    <option value="strategy" selected>Strategy</option>
                    <option value="maxDDPercent">Max DD %</option>
                    <option value="currentDDPercent">Current DD %</option>
                    <option value="currentDDDuration">DD Duration</option>
                    <option value="extraMargin">Add Fund</option>
                </select>
            </div>
            <button class="btn btn-action" onclick="expandAll()" style="flex: 1 1 0; min-width: 100px;">Expand All</button>
            <button class="btn btn-action" onclick="collapseAll()" style="flex: 1 1 0; min-width: 100px;">Collapse All</button>
            <button class="btn btn-action" onclick="resetFilters()" style="flex: 1 1 0; min-width: 100px;">Reset Filters</button>
            <button class="btn btn-action" onclick="exportToCSV()" style="flex: 1 1 0; min-width: 100px;">Export CSV</button>
        </div>
        <!-- Broker Level Summary Table -->
        <div class="table-container" style="margin-bottom: 20px;">
            <div style="padding: 12px 16px; background: #f8fafc; border-bottom: 1px solid #e5e7eb;">
                <h3 style="font-size: 14px; font-weight: 600; color: #374151; margin: 0;">Broker Level Metrics</h3>
                <p style="font-size: 11px; color: #6b7280; margin: 4px 0 0 0;">Pre-calculated broker-level drawdown values (not aggregated from strategies)</p>
            </div>
            <table>
                <thead>
                    <tr>
                        <th>Strategy</th>
                        <th>STG COUNT</th>
                        <th>STG Margin</th>
                        <th>A/C Margin</th>
                        <th>Add Fund</th>
                        <th>Add Fund(%)</th>
                        <th>A/C DD (₹)</th>
                        <th>A/C DD %</th>
                        <th>DD Expense (₹)</th>
                        <th>DD Expense(%)</th>
                        <th>DD Duration</th>
                        <th>A/C DD Start</th>
                        <th>A/C DD End</th>
                        <th>Expense (₹)</th>
                        <th>Max DD %</th>
                    </tr>
                </thead>
                <tbody id="brokerLevelTableBody">
                    <tr><td colspan="15" class="empty-state">No broker data loaded yet.</td></tr>
                </tbody>
            </table>
        </div>
        <div class="table-container">
            <div style="padding: 12px 16px; background: #f8fafc; border-bottom: 1px solid #e5e7eb;">
                <h3 style="font-size: 14px; font-weight: 600; color: #374151; margin: 0;">Strategy Level Metrics</h3>
                <p style="font-size: 11px; color: #6b7280; margin: 4px 0 0 0;">Detailed drawdown analysis with broker, account, and strategy hierarchy. Drawdown calculated based on daily PNL, not individual trades.</p>
            </div>
            <table>
                <thead>
                    <tr>
                        <th onclick="sortTable('strategy')">Strategy</th>
                        <th onclick="sortTable('lotSize')">Lot Size</th>
                        <th onclick="sortTable('stgMargin')">STG Margin</th>
                        <th onclick="sortTable('brokerMargin')">Broker Margin</th>
                        <th onclick="sortTable('extraMargin')">Add Fund</th>
                        <th onclick="sortTable('extraMarginPercent')">Add Fund(%)</th>
                        <th onclick="sortTable('currentDD')">Current DD (₹)</th>
                        <th onclick="sortTable('currentDDPercent')">Current DD %</th>
                        <th onclick="sortTable('aproDD')">A.PRO DD (₹)</th>
                        <th onclick="sortTable('aproDDPercent')">A.PRO DD(%)</th>
                        <th onclick="sortTable('currentDDDuration')">DD Duration</th>
                        <th onclick="sortTable('ddStartDate')">STG DD Start</th>
                        <th onclick="sortTable('ddEndDate')">STG DD End</th>
                        <th onclick="sortTable('maxDD')">Max DD (₹)</th>
                        <th onclick="sortTable('maxDDPercent')">Max DD %</th>
                    </tr>
                </thead>
                <tbody id="drawdownTableBody">
                    <tr><td class="empty-state">No data loaded yet.</td></tr>
                </tbody>
            </table>
        </div>
    </div>
    <script>
        let drawdownData = [];
        let filteredData = [];
        let hiddenStrategies = new Set();
        let allStrategyNames = [];
        let sortColumn = 'strategy';
        let sortDirection = 'asc';
        let globalStrategyMap = {};
        let globalAccountMap = {};
        let selectedBrokers = new Set(); // Track selected brokers for filtering
        let allBrokerCodes = []; // All available broker codes
        let lotMargin = 400000; // Default lot margin value, can be changed by user
        // Sample data structure
        const sampleData = [
            {strategy: "ACA", isGroup: true, isChild: false, lotSize: 10.40, maxDD: -584670, maxDDPercent: -9.86, currentDD: -588021, currentDDPercent: -14.14, ddDuration: 14, recoveryTime: 8, ddStartDate: "24-Nov", ddEndDate: "31-Dec", ddCount: 67, recoveryFactor: 7.96, underwaterPeriod: 538, stgMargin: 4160000, currentDDDuration: 37},
            {strategy: "ACAPRO 4", parentAccount: "ACA", isGroup: false, isChild: true, lotSize: 6.20, maxDD: -584670, maxDDPercent: -7.34, currentDD: -267757, currentDDPercent: -3.18, ddDuration: 14, recoveryTime: 3, ddStartDate: "08-Sep", ddEndDate: "22-Sep", ddCount: 54, recoveryFactor: 5.97, underwaterPeriod: 192, stgMargin: 2480000},
            {strategy: "CEA", isGroup: true, isChild: false, lotSize: 4.30, maxDD: -553090, maxDDPercent: -24.15, currentDD: -338008, currentDDPercent: -19.65, ddDuration: 10, recoveryTime: 5, ddStartDate: "23-Oct", ddEndDate: "31-Dec", ddCount: 45, recoveryFactor: 6.50, underwaterPeriod: 400, stgMargin: 1720000, currentDDDuration: 69},
            {strategy: "CEAPRO 1", parentAccount: "CEA", isGroup: false, isChild: true, lotSize: 2.10, maxDD: -450000, maxDDPercent: -6.50, currentDD: -125000, currentDDPercent: -1.50, ddDuration: 10, recoveryTime: 5, ddStartDate: "15-Sep", ddEndDate: "25-Sep", ddCount: 45, recoveryFactor: 6.50, underwaterPeriod: 400, stgMargin: 840000}
        ];
        // Listen for data from parent
        window.addEventListener('message', (event) => {
            const { type, data } = event.data;
            if (type === 'TRADES_DATA') {                
                // Store full trades data for broker margin calculation
                originalTradesData = event.data.data || data;
                
                // Reset to ALL TIME and update date inputs based on available data
                resetToAllTimeWithDataRange();
                
                // Apply date filtering and process
                applyDateFilterAndProcess();
                
                loadSavedFilters();
                populateStrategyOptions();
                populateBrokerOptions();
                applyFilters();
            } else if (type === 'LOAD_SAMPLE_DATA') {                drawdownData = sampleData;
                loadSavedFilters();
                populateStrategyOptions();
                populateBrokerOptions();
                applyFilters();
            }
        });
        
        // Reset date range to ALL TIME and set inputs based on available data
        function resetToAllTimeWithDataRange() {
            const fromDateInput = document.getElementById('fromDate');
            const toDateInput = document.getElementById('toDate');
            
            if (originalTradesData && originalTradesData.length > 0) {
                // Find min and max dates from the data
                let minDate = null;
                let maxDate = null;
                
                originalTradesData.forEach(trade => {
                    const dateParts = trade.date.split('/');
                    if (dateParts.length === 3) {
                        // Handle 2-digit years
                        let year = parseInt(dateParts[2]);
                        if (year < 100) {
                            year += 2000;
                        }
                        
                        const tradeDate = new Date(
                            year, // year
                            parseInt(dateParts[1]) - 1, // month (0-indexed)
                            parseInt(dateParts[0]) // day
                        );
                        
                        if (!minDate || tradeDate < minDate) {
                            minDate = tradeDate;
                        }
                        if (!maxDate || tradeDate > maxDate) {
                            maxDate = tradeDate;
                        }
                    }
                });
                
                // Set FROM date to earliest date in data using string format (YYYY-MM-DD)
                if (fromDateInput && minDate) {
                    const year = minDate.getFullYear();
                    const month = String(minDate.getMonth() + 1).padStart(2, '0');
                    const day = String(minDate.getDate()).padStart(2, '0');
                    fromDateInput.value = `${year}-${month}-${day}`;
                    
                    // Set min/max attributes for validation
                    fromDateInput.min = `${year}-${month}-${day}`;
                    if (maxDate) {
                        const maxYear = maxDate.getFullYear();
                        const maxMonth = String(maxDate.getMonth() + 1).padStart(2, '0');
                        const maxDay = String(maxDate.getDate()).padStart(2, '0');
                        fromDateInput.max = `${maxYear}-${maxMonth}-${maxDay}`;
                    }
                }
                
                // Set TO date to latest date in data using string format (YYYY-MM-DD)
                if (toDateInput && maxDate) {
                    const year = maxDate.getFullYear();
                    const month = String(maxDate.getMonth() + 1).padStart(2, '0');
                    const day = String(maxDate.getDate()).padStart(2, '0');
                    toDateInput.value = `${year}-${month}-${day}`;
                    
                    // Set min/max attributes for validation
                    if (minDate) {
                        const minYear = minDate.getFullYear();
                        const minMonth = String(minDate.getMonth() + 1).padStart(2, '0');
                        const minDay = String(minDate.getDate()).padStart(2, '0');
                        toDateInput.min = `${minYear}-${minMonth}-${minDay}`;
                    }
                    toDateInput.max = `${year}-${month}-${day}`;
                }
            } else {
                // No data, set to today
                const today = new Date();
                const year = today.getFullYear();
                const month = String(today.getMonth() + 1).padStart(2, '0');
                const day = String(today.getDate()).padStart(2, '0');
                
                if (fromDateInput) {
                    fromDateInput.value = '';
                }
                if (toDateInput) {
                    toDateInput.value = `${year}-${month}-${day}`;
                }
            }
            
            // Set ALL TIME button as active
            document.querySelectorAll('.date-range-buttons .btn').forEach(btn => {
                btn.classList.remove('active');
                if (btn.textContent.trim() === 'ALL TIME') {
                    btn.classList.add('active');
                }
            });
        }
        function processTradesForDrawdown(trades) {            
                        const accountMap = {};
            const strategyMap = {};
            const sortedTrades = [...trades].sort((a, b) => {
                const dateA = a.date.split('/').reverse().join('');
                const dateB = b.date.split('/').reverse().join('');
                return dateA.localeCompare(dateB);
            });
            sortedTrades.forEach(trade => {
                if (trade.strategyPnlTax) {
                    Object.entries(trade.strategyPnlTax).forEach(([stratName, pnlTax]) => {
                        // Skip if pnlTax is null, undefined, empty string, or zero
                        if (pnlTax === null || pnlTax === undefined || pnlTax === '' || pnlTax === 0) {
                            return;
                        }
                        
                        // Process A.PRO strategies separately - store them but don't add to broker/account hierarchy
                        if (stratName.startsWith('A.PRO')) {
                            if (!strategyMap[stratName]) {
                                strategyMap[stratName] = {
                                    name: stratName,
                                    pnls: [],
                                    dates: [],
                                    broker: 'A',
                                    account: 'A.PRO',
                                    lotSize: '-',
                                    isAPro: true
                                };
                            }
                            if (trade.strategyDetails && trade.strategyDetails[stratName]) {
                                const details = trade.strategyDetails[stratName];
                                if (details.lot && details.lot > 0) {
                                    strategyMap[stratName].lotSize = details.lot;
                                }
                            }
                            // Convert pnlTax to number and validate
                            const pnlValue = Number(pnlTax);
                            if (isNaN(pnlValue)) {
                                console.warn(`Invalid PNL value for ${stratName} on ${trade.date}:`, pnlTax);
                                return;
                            }
                            strategyMap[stratName].pnls.push(pnlValue);
                            strategyMap[stratName].dates.push(trade.date);
                            return; // Don't process A.PRO as broker strategies
                        }
                        // Extract broker code from strategy name (e.g., ACAPRO 1 -> ACA)
                        const brokerCode = extractBrokerCode(stratName);
                        if (!brokerCode || brokerCode === 'A') return; // Skip if no broker code or A.PRO
                        const accountCode = brokerCode; // Account code is the broker code (ACA, CEA, ZEA)
                        if (!strategyMap[stratName]) {
                            strategyMap[stratName] = {
                                name: stratName,
                                pnls: [],
                                dates: [],
                                broker: brokerCode,
                                account: accountCode,
                                lotSize: '-'
                            };
                        }
                        if (trade.strategyDetails && trade.strategyDetails[stratName]) {
                            const details = trade.strategyDetails[stratName];
                            if (details.lot && details.lot > 0) {
                                strategyMap[stratName].lotSize = details.lot;
                            }
                        }
                        // Convert pnlTax to number and validate
                        const pnlValue = Number(pnlTax);
                        if (isNaN(pnlValue)) {
                            console.warn(`Invalid PNL value for ${stratName} on ${trade.date}:`, pnlTax);
                            return;
                        }
                        strategyMap[stratName].pnls.push(pnlValue);
                        strategyMap[stratName].dates.push(trade.date);
                        if (!accountMap[accountCode]) {
                            accountMap[accountCode] = {
                                name: accountCode,
                                pnls: [],
                                dates: [],
                                broker: brokerCode
                            };
                        }
                        accountMap[accountCode].pnls.push(pnlValue);
                        accountMap[accountCode].dates.push(trade.date);
                    });
                }
            });
            function calculateDrawdown(pnls, dates) {
                // If no PNLs or dates, return zero values
                if (!pnls || !dates || pnls.length === 0 || dates.length === 0) {
                    return {
                        maxDD: 0,
                        maxDDPercent: 0,
                        currentDD: 0,
                        currentDDPercent: 0,
                        currentDDDuration: 0,
                        ddCount: 0,
                        ddDuration: 0,
                        recoveryTime: 0,
                        ddStartDate: '-',
                        ddEndDate: '-',
                        finalPnl: 0,
                        finalEquity: 0,
                        peak: 0,
                        underwaterPeriod: 0
                    };
                }
                
                // Start from 0, not from startingCapital - to match strategy-performance.html
                let cumPnl = 0;
                let equity = 0;
                let peak = 0;
                let maxDD = 0;
                let maxDDPercent = 0;
                let maxDDStartDate = '-';
                let maxDDEndDate = '-';
                let currentDD = 0;
                let currentDDPercent = 0;
                let currentDDDuration = 0;
                let currentDDStartDate = null;
                let ddCount = 0;
                let inDrawdown = false;
                let ddStartDate = null;
                let ddDays = 0;
                let maxDDDays = 0;
                let totalRecoveryDays = 0;
                let recoveryCount = 0;
                let totalUnderwaterDays = 0;
                let underwaterStartDate = null;
                
                pnls.forEach((pnl, index) => {
                    // Accumulate PNL (each pnl is the daily PNL tax)
                    cumPnl += pnl;
                    equity = cumPnl;  // Just use cumulative PNL, no starting capital
                    
                    if (equity > peak) {
                        if (inDrawdown && ddStartDate) {
                            const recoveryDays = calculateDateDiff(ddStartDate, dates[index]);
                            totalRecoveryDays += recoveryDays;
                            recoveryCount++;
                        }
                        if (underwaterStartDate) {
                            totalUnderwaterDays += calculateDateDiff(underwaterStartDate, dates[index]);
                            underwaterStartDate = null;
                        }
                        peak = equity;
                        inDrawdown = false;
                        ddStartDate = null;
                        ddDays = 0;
                        currentDDStartDate = null; // Reset current DD tracking
                    } else if (equity < peak) {
                        if (!inDrawdown) {
                            ddCount++;
                            inDrawdown = true;
                            ddStartDate = dates[index];
                            underwaterStartDate = dates[index];
                            if (!currentDDStartDate) {
                                currentDDStartDate = dates[index]; // Track current DD start
                            }
                        }
                        if (ddStartDate) {
                            ddDays = calculateDateDiff(ddStartDate, dates[index]);
                        }
                        const dd = equity - peak;
                        if (dd < maxDD) {
                            maxDD = dd;
                            maxDDPercent = peak > 0 ? (dd / peak) * 100 : 0;
                            maxDDStartDate = ddStartDate || dates[index];
                            maxDDEndDate = dates[index];
                            maxDDDays = ddDays;
                        }
                    }
                });
                
                if (underwaterStartDate && dates.length > 0) {
                    totalUnderwaterDays += calculateDateDiff(underwaterStartDate, dates[dates.length - 1]);
                }
                
                // Final current DD calculation: equity at last date minus peak achieved
                currentDD = equity - peak;
                currentDDPercent = peak > 0 ? (currentDD / peak) * 100 : 0;
                
                // Calculate current DD duration and end date (if currently in drawdown)
                let currentDDEndDate = '-';
                if (currentDD < 0 && currentDDStartDate && dates.length > 0) {
                    currentDDDuration = calculateDateDiff(currentDDStartDate, dates[dates.length - 1]);
                    currentDDEndDate = dates[dates.length - 1]; // Latest date is the current DD end
                } else {
                    currentDDDuration = 0;
                    currentDDStartDate = null;
                }
                
                const avgRecoveryTime = recoveryCount > 0 ? Math.round(totalRecoveryDays / recoveryCount) : 0;
                
                return {
                    maxDD,
                    maxDDPercent,
                    currentDD,
                    currentDDPercent,
                    currentDDDuration,
                    ddCount,
                    ddDuration: maxDDDays,
                    recoveryTime: avgRecoveryTime,
                    ddStartDate: currentDDStartDate || '-',  // Keep full DD/MM/YYYY format
                    ddEndDate: currentDDEndDate,  // Keep full DD/MM/YYYY format
                    finalPnl: cumPnl,
                    finalEquity: equity,
                    peak,
                    underwaterPeriod: totalUnderwaterDays
                };
            }
            function calculateDateDiff(date1Str, date2Str) {
                if (!date1Str || !date2Str || date1Str === '-' || date2Str === '-') return 0;
                try {
                    const [d1, m1, y1] = date1Str.split('/').map(Number);
                    const [d2, m2, y2] = date2Str.split('/').map(Number);
                    const date1 = new Date(y1, m1 - 1, d1);
                    const date2 = new Date(y2, m2 - 1, d2);
                    const diffTime = Math.abs(date2 - date1);
                    const diffDays = Math.ceil(diffTime / (1000 * 60 * 60 * 24));
                    return diffDays;
                } catch (e) {
                    return 0;
                }
            }
            function calculateTotalLotSize(strategies) {
                let totalLots = 0;
                let hasValidLots = false;
                strategies.forEach(strat => {
                    const lot = strat.lotSize;
                    if (lot && lot !== '-') {
                        const numLot = typeof lot === 'number' ? lot : parseFloat(lot);
                        if (!isNaN(numLot)) {
                            totalLots += numLot;
                            hasValidLots = true;
                        }
                    }
                });
                return hasValidLots ? totalLots : '-';
            }
            drawdownData = [];
            globalStrategyMap = strategyMap;
            globalAccountMap = accountMap;
            Object.entries(strategyMap).forEach(([stratName, stratData]) => {
                // Skip A.PRO strategies - they're only for lookup, not for display
                if (stratData.isAPro) return;
                
                // Aggregate PNL by date - sum all trades on the same date
                const dailyPnlMap = {};
                stratData.pnls.forEach((pnl, idx) => {
                    const date = stratData.dates[idx];
                    if (!dailyPnlMap[date]) {
                        dailyPnlMap[date] = 0;
                    }
                    dailyPnlMap[date] += pnl;
                });
                
                // Convert back to arrays, sorted by date
                const sortedDates = Object.keys(dailyPnlMap).sort((a, b) => {
                    const dateA = a.split('/').reverse().join('');
                    const dateB = b.split('/').reverse().join('');
                    return dateA.localeCompare(dateB);
                });
                
                const aggregatedPnls = sortedDates.map(date => dailyPnlMap[date]);
                
                const metrics = calculateDrawdown(aggregatedPnls, sortedDates);
                
                drawdownData.push({
                    strategy: stratName,
                    parentAccount: stratData.account,
                    parentBroker: stratData.broker,
                    isChild: true,
                    isBroker: false,
                    isGroup: false,
                    lotSize: stratData.lotSize,
                    stgMargin: stratData.lotSize * lotMargin,
                    maxDD: metrics.maxDD,
                    maxDDPercent: metrics.maxDDPercent,
                    currentDD: metrics.currentDD,
                    currentDDPercent: metrics.currentDDPercent,
                    currentDDDuration: metrics.currentDDDuration,
                    ddDuration: metrics.ddDuration,
                    recoveryTime: metrics.recoveryTime,
                    ddStartDate: metrics.ddStartDate,
                    ddEndDate: metrics.ddEndDate,
                    ddCount: metrics.ddCount,
                    recoveryFactor: metrics.maxDD !== 0 ? Math.abs(metrics.finalPnl / metrics.maxDD) : 1.0,
                    underwaterPeriod: metrics.underwaterPeriod
                });
            });
            // Process accounts with aggregated PnL data
            Object.entries(accountMap).forEach(([accountCode, accountData]) => {
                const metrics = calculateDrawdown(accountData.pnls, accountData.dates);
                const accountStrategies = Object.values(strategyMap).filter(s => s.account === accountCode && !s.isAPro);
                const totalLotSize = calculateTotalLotSize(accountStrategies);
                drawdownData.push({
                    strategy: accountCode,
                    isGroup: true,
                    isBroker: false,
                    isChild: false,
                    lotSize: totalLotSize,
                    stgMargin: totalLotSize * lotMargin,
                    maxDD: metrics.maxDD,
                    maxDDPercent: metrics.maxDDPercent,
                    currentDD: metrics.currentDD,
                    currentDDPercent: metrics.currentDDPercent,
                    currentDDDuration: metrics.currentDDDuration,
                    ddDuration: metrics.ddDuration,
                    recoveryTime: metrics.recoveryTime,
                    ddStartDate: metrics.ddStartDate,
                    ddEndDate: metrics.ddEndDate,
                    ddCount: metrics.ddCount,
                    recoveryFactor: metrics.maxDD !== 0 ? Math.abs(metrics.finalPnl / metrics.maxDD) : 1.0,
                    underwaterPeriod: metrics.underwaterPeriod
                });
            });
            // Recalculate Current DD % and Max DD % based on STG Margin instead of peak
            drawdownData.forEach(row => {
                const stgMargin = (row.lotSize && row.lotSize !== '-') ? row.lotSize * lotMargin : 0;
                if (stgMargin > 0) {
                    row.currentDDPercent = (row.currentDD / stgMargin) * 100;
                    row.maxDDPercent = (row.maxDD / stgMargin) * 100;
                } else {
                    row.currentDDPercent = 0;
                    row.maxDDPercent = 0;
                }
            });}
        
        function removeFormatting(input) {
            // When user clicks in the input, remove commas for easy editing
            let value = input.value.replace(/,/g, '');
            input.value = value;
        }
        
        function formatLotMarginInput(input) {
            // When user leaves the input, format it
            let value = input.value.replace(/,/g, '');
            if (value && parseInt(value) > 0) {
                lotMargin = parseInt(value);
                input.value = formatCurrency(lotMargin);
                saveFilters();
                // Reprocess data with new lot margin
                if (originalTradesData && originalTradesData.length > 0) {
                    applyDateFilterAndProcess();
                    applyFilters();
                }
            } else {
                input.value = formatCurrency(400000);
                lotMargin = 400000;
                saveFilters();
            }
        }
        
        function updateLotMarginValue(input) {
            // Update the value as user types (but don't reformat while typing)
            let value = input.value.replace(/,/g, '');
            if (value && parseInt(value) > 0) {
                lotMargin = parseInt(value);
            }
        }
        
        function updateLotMarginAndRecalculate() {
            const inputValue = parseFloat(document.getElementById('lotMarginInput').value);
            if (inputValue && inputValue > 0) {
                lotMargin = inputValue;
                // Update formatted display
                document.getElementById('lotMarginDisplay').textContent = '(' + formatCurrency(inputValue) + ')';
                // Save to localStorage
                saveFilters();
                // Reprocess data with new lot margin
                if (originalTradesData && originalTradesData.length > 0) {
                    applyDateFilterAndProcess();
                    applyFilters(); // Update the display with new calculations
                }
            }
        }
        
        function applyFilters() {
            const minDD = parseFloat(document.getElementById('minDrawdownFilter').value) || -Infinity;
            const viewType = document.getElementById('viewTypeFilter').value;
            // First, filter strategies (also filter by selected brokers)
            const filteredStrategies = drawdownData.filter(row => {
                if (!row.isChild) return false;
                const matchesStrategy = !hiddenStrategies.has(row.strategy);
                const matchesDD = row.maxDDPercent >= minDD;
                // Filter by selected broker
                const parentAccount = row.parentAccount;
                const matchesBroker = selectedBrokers.size === 0 || selectedBrokers.has(parentAccount);
                return matchesStrategy && matchesDD && matchesBroker;
            });
            // Get ALL accounts from drawdownData (not just those with filtered strategies)
            const allAccountsData = drawdownData.filter(d => d.isGroup);
            // Filter accounts by selected brokers
            const filteredAccountsData = allAccountsData.filter(d => selectedBrokers.size === 0 || selectedBrokers.has(d.strategy));
            // Recalculate each account based on its filtered strategies
            const recalculatedAccounts = filteredAccountsData.map(accountData => {
                const accountCode = accountData.strategy;
                // Get filtered strategies for this account
                const accountStrategies = filteredStrategies.filter(s => s.parentAccount === accountCode);
                // Return account with recalculated lot size from filtered strategies
                return {
                    strategy: accountCode,
                    isGroup: true,
                    isBroker: false,
                    isChild: false,
                    lotSize: accountStrategies.reduce((sum, s) => sum + (typeof s.lotSize === 'number' ? s.lotSize : 0), 0),
                    maxDD: accountData.maxDD,
                    maxDDPercent: accountData.maxDDPercent,
                    currentDD: accountData.currentDD,
                    currentDDPercent: accountData.currentDDPercent,
                    currentDDDuration: accountData.currentDDDuration,
                    ddDuration: accountData.ddDuration,
                    recoveryTime: accountData.recoveryTime,
                    ddStartDate: accountData.ddStartDate,
                    ddEndDate: accountData.ddEndDate,
                    ddCount: accountData.ddCount,
                    recoveryFactor: accountData.recoveryFactor,
                    underwaterPeriod: accountData.underwaterPeriod
                };
            });
            // Recalculate broker metrics based on filtered accounts (empty since brokerCode = accountCode now)
            const recalculatedBrokers = []; // No separate brokers anymore
            // Combine all filtered data - ALWAYS include all rows for rendering
            // Combine all filtered data - ALWAYS include all rows for rendering
            // View type only controls visibility via CSS, not calculations
            filteredData = [...recalculatedBrokers, ...recalculatedAccounts, ...filteredStrategies];
            // Set body data-view attribute to control visibility via CSS
            document.body.setAttribute('data-view', viewType);
            // Sort
            if (viewType === 'all') {
                filteredData.sort((a, b) => {
                    if (a.isGroup !== b.isGroup) return a.isGroup ? -1 : 1;
                    const aVal = a[sortColumn];
                    const bVal = b[sortColumn];
                    return sortDirection === 'asc' ? (aVal > bVal ? 1 : -1) : (aVal < bVal ? 1 : -1);
                });
            } else {
                filteredData.sort((a, b) => {
                    const aVal = a[sortColumn];
                    const bVal = b[sortColumn];
                    return sortDirection === 'asc' ? (aVal > bVal ? 1 : -1) : (aVal < bVal ? 1 : -1);
                });
            }            renderTable();
            renderBrokerLevelTable();
            updateSummaryCards([], recalculatedAccounts, filteredStrategies);
            saveFilters();
        }
        // Helper function to extract broker code from strategy name
        function extractBrokerCode(strategyName) {
            if (!strategyName) return null;
            if (strategyName.startsWith('A.PRO')) return 'A';
            // Match patterns like ACAPRO, CEAPRO, ZEAPRO, B1PRO, B2PRO
            const match = strategyName.match(/^([A-Z0-9]+)(?=PRO)/i);
            return match ? match[1] : null;
        }
// Helper function to get A.PRO drawdown for a broker strategy
        // Example: B1PRO3 -> A.PRO3, then multiply A.PRO3's DD by the broker strategy's lot size
        function getAProDrawdown(strategyName, lotSize) {
            if (!strategyName || !globalStrategyMap || !lotSize || lotSize === '-') return 0;
            // Extract the PRO number from the broker strategy name
            // Match patterns like ACAPRO 1, CEAPRO 4, ZEAPRO 7, etc.
            const proMatch = strategyName.match(/PRO\s*(\d+)/i);
            if (!proMatch) {
                return 0;
            }
            const proNumber = proMatch[1]; // Just the number, e.g., "3", "4", "5"
            // Search through all A.PRO strategies and find one with matching number
            for (const [aproName, aproStrategy] of Object.entries(globalStrategyMap)) {
                if (!aproName.startsWith('A.PRO')) continue;
                // Extract number from A.PRO strategy name
                const aproNumMatch = aproName.match(/PRO\s*(\d+)/i);
                if (!aproNumMatch) continue;
                const aproNumber = aproNumMatch[1];
                // If numbers match, this is our A.PRO strategy
                if (aproNumber === proNumber) {
                    // Calculate drawdown using the same logic as other strategies
                    if (aproStrategy.pnls && aproStrategy.dates && aproStrategy.pnls.length > 0) {
                        // Aggregate PNL by date - sum all trades on the same date
                        const dailyPnlMap = {};
                        aproStrategy.pnls.forEach((pnl, idx) => {
                            const date = aproStrategy.dates[idx];
                            if (!dailyPnlMap[date]) {
                                dailyPnlMap[date] = 0;
                            }
                            dailyPnlMap[date] += pnl;
                        });
                        
                        // Convert to array of daily PNLs
                        const aggregatedPnls = Object.values(dailyPnlMap);
                        
                        // Calculate drawdown starting from 0, not from starting capital
                        let cumPnl = 0;
                        let peak = 0;
                        aggregatedPnls.forEach(pnl => {
                            cumPnl += pnl;
                            if (cumPnl > peak) {
                                peak = cumPnl;
                            }
                        });
                        const currentDD = cumPnl - peak;
                        // Multiply A.PRO DD by the broker strategy's lot size
                        return currentDD * lotSize;
                    }
                }
            }
            return 0;
        }
        function renderTable() {const tbody = document.getElementById('drawdownTableBody');if (filteredData.length === 0) {tbody.innerHTML = '<tr><td colspan="15" class="empty-state">No data available</td></tr>';
                return;
            }
            const viewType = document.getElementById('viewTypeFilter').value;
            // Group data hierarchically
            const accounts = filteredData.filter(d => d.isGroup);
            const strategies = filteredData.filter(d => d.isChild);// Helper function to calculate sums for an account (ACA, CEA, ZEA, etc.)
            function calculateAccountSums(accountStrategy) {
                // Get the pre-calculated account data from accounts array
                const accountData = accounts.find(a => a.strategy === accountStrategy);
                const children = strategies.filter(s => s.parentAccount === accountStrategy);
                if (children.length === 0) return null;
                // Helper to find earliest date from filtered strategies
                function getEarliestDate(strategies) {
                    const validDates = strategies
                        .map(s => s.ddStartDate)
                        .filter(d => d && d !== '-');
                    if (validDates.length === 0) return '-';
                    
                    // Dates are now in DD/MM/YYYY format, sort them properly
                    const sortedDates = validDates.sort((a, b) => {
                        const dateA = a.split('/').reverse().join(''); // YYYYMMDD
                        const dateB = b.split('/').reverse().join(''); // YYYYMMDD
                        return dateA.localeCompare(dateB);
                    });
                    
                    return sortedDates[0]; // Return earliest date in DD/MM/YYYY format
                }
                const sums = {
                    lotSize: children.reduce((sum, c) => sum + (c.lotSize || 0), 0),
                    maxDD: children.reduce((sum, c) => sum + (c.maxDD || 0), 0),
                    maxDDPercent: 0, // Will be calculated below based on STG Margin
                    currentDD: children.reduce((sum, c) => sum + (c.currentDD || 0), 0),
                    currentDDPercent: 0, // Will be recalculated below based on STG Margin
                    stgDD: accountData ? accountData.currentDD : children.reduce((sum, c) => sum + (c.currentDD || 0), 0),
                    // DD Duration = MAX from filtered strategies
                    currentDDDuration: Math.max(...children.map(c => c.currentDDDuration || 0)),
                    recoveryTime: accountData ? accountData.recoveryTime : Math.max(...children.map(c => c.recoveryTime || 0)),
                    ddDuration: accountData ? accountData.ddDuration : Math.max(...children.map(c => c.ddDuration || 0)),
                    ddCount: accountData ? accountData.ddCount : Math.max(...children.map(c => c.ddCount || 0)),
                    underwaterPeriod: accountData ? accountData.underwaterPeriod : Math.max(...children.map(c => c.underwaterPeriod || 0)),
                    recoveryFactor: accountData ? accountData.recoveryFactor : children.reduce((sum, c) => sum + (c.recoveryFactor || 0), 0) / children.length,
                    // STG DD Start = EARLIEST start date from filtered strategies
                    ddStartDate: getEarliestDate(children),
                    ddEndDate: accountData ? accountData.ddEndDate : '-'
                };
                // Calculate STG Margin = Lot Size * lotMargin
                sums.stgMargin = sums.lotSize * lotMargin;
                // Calculate stg dd(%)
                if (sums.stgMargin > 0) {
                    sums.stgDDPercent = (sums.stgDD / sums.stgMargin) * 100;
                } else {
                    sums.stgDDPercent = 0;
                }
                // Recalculate Current DD % based on STG Margin
                if (sums.stgMargin > 0) {
                    sums.currentDDPercent = (sums.currentDD / sums.stgMargin) * 100;
                } else {
                    sums.currentDDPercent = 0;
                }
                // Calculate Max DD % as (Sum of Max DD ₹ / Sum of STG Margins) × 100
                if (sums.stgMargin > 0) {
                    sums.maxDDPercent = (sums.maxDD / sums.stgMargin) * 100;
                } else {
                    sums.maxDDPercent = 0;
                }
                // Broker margin and Add Fund are left blank for account rows
                sums.brokerMargin = null;
                sums.extraMargin = null;
                sums.extraMarginPercent = null;
                return sums;
            }
            // Helper function to calculate broker sums from accounts (B)
            let html = '';
            // Always render hierarchically (broker -> account -> strategy)
            // View type controls visibility via CSS, not rendering structure
            
            // Calculate totals for "All Broker" row
            let allBrokerLotSize = 0;
            let allBrokerStgMargin = 0;
            let allBrokerMargin = 0;
            let allBrokerCurrentDD = 0;
            let allBrokerMaxDD = 0;
            let allBrokerAProDD = 0;
            let allBrokerMaxDDDuration = 0;
            
            accounts.forEach(account => {
                const accountCode = account.strategy;
                const accountSums = calculateAccountSums(accountCode);
                const displayData = accountSums || account;
                allBrokerLotSize += displayData.lotSize || 0;
                allBrokerStgMargin += displayData.stgMargin || 0;
                const marginValue = getBrokerMarginForAccount(accountCode);allBrokerMargin += marginValue || 0;
                allBrokerCurrentDD += displayData.currentDD || 0;
                allBrokerMaxDD += displayData.maxDD || 0;
                const accountStrategies = strategies.filter(s => s.parentAccount === accountCode);
                const aproDD = accountStrategies.reduce((sum, s) => sum + getAProDrawdown(s.strategy, s.lotSize), 0);
                allBrokerAProDD += aproDD;
                allBrokerMaxDDDuration = Math.max(allBrokerMaxDDDuration, displayData.currentDDDuration || 0);
            });
            
            const allBrokerExtraMargin = allBrokerMargin - allBrokerStgMargin;
            const allBrokerExtraMarginPercent = allBrokerStgMargin > 0 ? (allBrokerExtraMargin / allBrokerStgMargin) * 100 : 0;
            const allBrokerCurrentDDPercent = allBrokerStgMargin > 0 ? (allBrokerCurrentDD / allBrokerStgMargin) * 100 : 0;
            const allBrokerAProDDPercent = allBrokerStgMargin > 0 ? (allBrokerAProDD / allBrokerStgMargin) * 100 : 0;
            
            // Calculate All Broker Max DD % as (Sum of Max DD ₹ / Sum of STG Margins) × 100
            const allBrokerMaxDDPercent = allBrokerStgMargin > 0 ? (allBrokerMaxDD / allBrokerStgMargin) * 100 : 0;
            
            // Calculate All Broker STG DD Start (minimum date) and STG DD End (maximum date) from filtered strategies
            let allBrokerDDStartDate = '-';
            let allBrokerDDEndDate = '-';
            
            const allDDStartDates = strategies
                .map(s => s.ddStartDate)
                .filter(d => d && d !== '-');
            const allDDEndDates = strategies
                .map(s => s.ddEndDate)
                .filter(d => d && d !== '-');
            
            // Dates are in DD/MM/YYYY format, sort by converting to YYYYMMDD
            if (allDDStartDates.length > 0) {
                const sortedStartDates = allDDStartDates.sort((a, b) => {
                    const dateA = a.split('/').reverse().join(''); // YYYYMMDD
                    const dateB = b.split('/').reverse().join(''); // YYYYMMDD
                    return dateA.localeCompare(dateB);
                });
                allBrokerDDStartDate = sortedStartDates[0]; // Earliest date
            }
            
            if (allDDEndDates.length > 0) {
                const sortedEndDates = allDDEndDates.sort((a, b) => {
                    const dateA = a.split('/').reverse().join(''); // YYYYMMDD
                    const dateB = b.split('/').reverse().join(''); // YYYYMMDD
                    return dateB.localeCompare(dateA); // Descending order
                });
                allBrokerDDEndDate = sortedEndDates[0]; // Latest date
            }
            
            const extraMarginClass = allBrokerExtraMargin > 0 ? 'positive' : (allBrokerExtraMargin < 0 ? 'negative' : 'neutral');
            const extraMarginPercentClass = allBrokerExtraMarginPercent > 0 ? 'positive' : (allBrokerExtraMarginPercent < 0 ? 'negative' : 'neutral');
            
            // Render "All Broker" summary row
            html += `<tr class="broker-row">
                <td class="broker-name">🏦 All Broker</td>
                <td>${formatNum(allBrokerLotSize, 2)}</td>
                <td>${formatCurrency(allBrokerStgMargin)}</td>
                <td>${formatCurrency(allBrokerMargin)}</td>
                <td class="${extraMarginClass}">${formatCurrency(allBrokerExtraMargin)}</td>
                <td class="${extraMarginPercentClass}">${formatPercent(allBrokerExtraMarginPercent)}</td>
                <td class="${allBrokerCurrentDD < 0 ? 'negative' : 'neutral'}">${formatCurrency(allBrokerCurrentDD)}</td>
                <td class="${allBrokerCurrentDDPercent < 0 ? 'negative' : 'neutral'}">${formatPercent(allBrokerCurrentDDPercent)}</td>
                <td class="${allBrokerAProDD < 0 ? 'negative' : 'neutral'}">${formatCurrency(allBrokerAProDD)}</td>
                <td class="${allBrokerAProDDPercent < 0 ? 'negative' : 'neutral'}">${formatPercent(allBrokerAProDDPercent)}</td>
                <td>${allBrokerCurrentDD < 0 && allBrokerMaxDDDuration > 0 ? allBrokerMaxDDDuration + ' days' : '-'}</td>
                <td>${allBrokerCurrentDD < 0 ? formatDate(allBrokerDDStartDate) : '-'}</td>
                <td>${allBrokerCurrentDD < 0 ? formatDate(allBrokerDDEndDate) : '-'}</td>
                <td class="negative">${formatCurrency(allBrokerMaxDD)}</td>
                <td class="negative">${formatPercent(allBrokerMaxDDPercent)}</td>
            </tr>`;
            
            // New simplified rendering: Render accounts directly (no broker hierarchy)
            accounts.forEach(account => {
                const accountCode = account.strategy;
                // Calculate sums for this account based on filtered data
                const accountSums = calculateAccountSums(accountCode);
                const displayData = accountSums || account;
                // Get Broker Margin from calculated trade data
                const marginValue = getBrokerMarginForAccount(accountCode);
                const brokerMargin = marginValue || 0;
                // Calculate extra margin for account
                const extraMargin = brokerMargin - (displayData.stgMargin || 0);
                const extraMarginPercent = displayData.stgMargin > 0 ? (extraMargin / displayData.stgMargin) * 100 : 0;
                const extraMarginClass = extraMargin > 0 ? 'positive' : (extraMargin < 0 ? 'negative' : 'neutral');
                const extraMarginPercentClass = extraMarginPercent > 0 ? 'positive' : (extraMarginPercent < 0 ? 'negative' : 'neutral');
                // Calculate total A.PRO DD for all strategies under this account
                const accountStrategies = strategies.filter(s => s.parentAccount === accountCode);
                const totalAProDD = accountStrategies.reduce((sum, s) => sum + getAProDrawdown(s.strategy, s.lotSize), 0);
                // Calculate A.PRO DD %
                const aproDDPercent = displayData.stgMargin > 0 ? (totalAProDD / displayData.stgMargin) * 100 : 0;
                
                // Assign color class based on broker code - alternate between pink and orange
                const brokerIndex = accounts.indexOf(account);
                const groupClass = (brokerIndex % 2 === 0) ? 'group-b1' : 'group-b2';
                const childClass = (brokerIndex % 2 === 0) ? 'child-row-b1' : 'child-row-b2';
                
                // Calculate rowspan only for child rows (not including account row)
                const childRowspan = accountStrategies.length;
                
                // Render account row (as top-level broker row) - showing its own values
                html += `<tr class="${groupClass}">
                    <td class="group-name">├─ ${getDisplayName(accountCode)}</td>
                    <td>${formatNum(displayData.lotSize, 2)}</td>
                    <td>${formatCurrency(displayData.stgMargin)}</td>
                    <td>${formatCurrency(brokerMargin)}</td>
                    <td class="${extraMarginClass}">${formatCurrency(extraMargin)}</td>
                    <td class="${extraMarginPercentClass}">${formatPercent(extraMarginPercent)}</td>
                    <td class="${displayData.currentDD < 0 ? 'negative' : 'neutral'}">${formatCurrency(displayData.currentDD)}</td>
                    <td class="${displayData.currentDDPercent < 0 ? 'negative' : 'neutral'}">${formatPercent(displayData.currentDDPercent)}</td>
                    <td class="${totalAProDD < 0 ? 'negative' : 'neutral'}">${formatCurrency(totalAProDD)}</td>
                    <td class="${aproDDPercent < 0 ? 'negative' : 'neutral'}">${formatPercent(aproDDPercent)}</td>
                    <td>${displayData.currentDD < 0 && displayData.currentDDDuration > 0 ? displayData.currentDDDuration + ' days' : '-'}</td>
                    <td>${displayData.currentDD < 0 ? formatDate(displayData.ddStartDate) : '-'}</td>
                    <td>${displayData.currentDD < 0 ? formatDate(displayData.ddEndDate) : '-'}</td>
                    <td class="negative">${formatCurrency(displayData.maxDD)}</td>
                    <td class="negative">${formatPercent(displayData.maxDDPercent)}</td>
                </tr>`;
                // Render strategies under this account
                accountStrategies.forEach((strategy, idx) => {
                    const isLast = idx === accountStrategies.length - 1;
                    const isFirst = idx === 0;
                    const prefix = isLast ? '  └─' : '  ├─';
                    const aproDD = getAProDrawdown(strategy.strategy, strategy.lotSize);
                    const aproDDPercent = strategy.stgMargin > 0 ? (aproDD / strategy.stgMargin) * 100 : 0;
                    
                    // First child row has rowspan cells spanning all child rows
                    if (isFirst) {
                        html += `<tr class="${childClass}">
                            <td style="padding-left: 40px;">${prefix} ${getDisplayName(strategy.strategy)}</td>
                            <td>${formatNum(strategy.lotSize, 2)}</td>
                            <td>${formatCurrency(strategy.stgMargin)}</td>
                            <td rowspan="${childRowspan}" class="rowspan-cell">${formatCurrency(brokerMargin)}</td>
                            <td rowspan="${childRowspan}" class="rowspan-cell ${extraMarginClass}">${formatCurrency(extraMargin)}</td>
                            <td rowspan="${childRowspan}" class="rowspan-cell ${extraMarginPercentClass}">${formatPercent(extraMarginPercent)}</td>
                            <td class="${strategy.currentDD < 0 ? 'negative' : 'neutral'}">${formatCurrency(strategy.currentDD)}</td>
                            <td class="${strategy.currentDDPercent < 0 ? 'negative' : 'neutral'}">${formatPercent(strategy.currentDDPercent)}</td>
                            <td class="${aproDD < 0 ? 'negative' : 'neutral'}">${formatCurrency(aproDD)}</td>
                            <td class="${aproDDPercent < 0 ? 'negative' : 'neutral'}">${formatPercent(aproDDPercent)}</td>
                            <td>${strategy.currentDD < 0 && strategy.currentDDDuration > 0 ? strategy.currentDDDuration + ' days' : '-'}</td>
                            <td>${strategy.currentDD < 0 ? formatDate(strategy.ddStartDate) : '-'}</td>
                            <td>${strategy.currentDD < 0 ? formatDate(strategy.ddEndDate) : '-'}</td>
                            <td class="negative">${formatCurrency(strategy.maxDD)}</td>
                            <td class="negative">${formatPercent(strategy.maxDDPercent)}</td>
                        </tr>`;
                    } else {
                        // Subsequent child rows skip the rowspan columns
                        html += `<tr class="${childClass}">
                            <td style="padding-left: 40px;">${prefix} ${getDisplayName(strategy.strategy)}</td>
                            <td>${formatNum(strategy.lotSize, 2)}</td>
                            <td>${formatCurrency(strategy.stgMargin)}</td>
                            <td class="${strategy.currentDD < 0 ? 'negative' : 'neutral'}">${formatCurrency(strategy.currentDD)}</td>
                            <td class="${strategy.currentDDPercent < 0 ? 'negative' : 'neutral'}">${formatPercent(strategy.currentDDPercent)}</td>
                            <td class="${aproDD < 0 ? 'negative' : 'neutral'}">${formatCurrency(aproDD)}</td>
                            <td class="${aproDDPercent < 0 ? 'negative' : 'neutral'}">${formatPercent(aproDDPercent)}</td>
                            <td>${strategy.currentDD < 0 && strategy.currentDDDuration > 0 ? strategy.currentDDDuration + ' days' : '-'}</td>
                            <td>${strategy.currentDD < 0 ? formatDate(strategy.ddStartDate) : '-'}</td>
                            <td>${strategy.currentDD < 0 ? formatDate(strategy.ddEndDate) : '-'}</td>
                            <td class="negative">${formatCurrency(strategy.maxDD)}</td>
                            <td class="negative">${formatPercent(strategy.maxDDPercent)}</td>
                        </tr>`;
                    }
                });
            });
            tbody.innerHTML = html;
        }
        function renderBrokerLevelTable() {
            const tbody = document.getElementById('brokerLevelTableBody');
            if (!tbody) return;
            // Get original broker data AND account-level data from drawdownData
            const allAccounts = drawdownData.filter(d => d.isGroup);
            // Get FILTERED strategies from filteredData
            const filteredStrategies = filteredData.filter(d => d.isChild);
            // Filter accounts by selected brokers
            const filteredAccounts = allAccounts.filter(d => selectedBrokers.has(d.strategy));
            // Use only filtered accounts for display
            const allBrokerLevelData = [...filteredAccounts];
            if (allBrokerLevelData.length === 0) {
                tbody.innerHTML = '<tr><td colspan="15" class="empty-state">No broker data available. Please select at least one broker.</td></tr>';
                return;
            }
            // Sort accounts by name
            allBrokerLevelData.sort((a, b) => {
                return a.strategy.localeCompare(b.strategy);
            });
            let html = '';
            
            // Calculate totals for "All Broker" row (only from SELECTED brokers)
            let allBrokerStrategyCount = 0;
            let allBrokerStgMargin = 0;
            let allBrokerMargin = 0;
            let allBrokerExpense = 0;
            let allBrokerMaxDD = 0;
            
            allBrokerLevelData.forEach(item => {
                const code = item.strategy;
                const strategies = filteredStrategies.filter(s => s.parentAccount === code);
                if (strategies.length === 0) return;
                
                const strategyCount = strategies.length;
                const totalLotSize = strategies.reduce((sum, s) => sum + (s.lotSize || 0), 0);
                const stgMargin = totalLotSize * lotMargin;
                const brokerMargin = getBrokerMarginForAccount(code) || 0;
                // Calculate expense for this account
                const accountExpense = calculateAccountExpense(code);
                const maxDD = item.maxDD || 0;
                
                allBrokerStrategyCount += strategyCount;
                allBrokerStgMargin += stgMargin;
                allBrokerMargin += brokerMargin;
                allBrokerExpense += accountExpense;
                allBrokerMaxDD += maxDD;
            });
            
            // For All Broker Current DD, calculate using SAME method as broker DD calculation
            // A/C DD = Current Total Margin - Peak Total Margin (NOT sum of individual account DDs)
            const currentTotalMarginForAllBroker = getCurrentTotalBrokerMargin();
            const peakTotalMarginForAllBroker = getPeakTotalBrokerMargin();
            const allBrokerCurrentDD = currentTotalMarginForAllBroker - peakTotalMarginForAllBroker;
            
            const allBrokerExtraMargin = allBrokerMargin - allBrokerStgMargin;
            const allBrokerExtraMarginPercent = allBrokerStgMargin > 0 ? (allBrokerExtraMargin / allBrokerStgMargin) * 100 : 0;
            // Calculate A/C DD % = (A/C DD ₹ / Peak Total Margin) × 100
            const allBrokerCurrentDDPercent = peakTotalMarginForAllBroker > 0 ? (allBrokerCurrentDD / peakTotalMarginForAllBroker) * 100 : 0;
            const allBrokerExpensePercent = allBrokerMargin > 0 ? (allBrokerExpense / allBrokerMargin) * 100 : 0;
            
            // Calculate All Broker Max DD % using historical margin data
            // Max DD % = (Max DD ₹ / Peak Margin at time of Max DD) * 100
            let allBrokerMaxDDPercent = 0;
            if (Object.keys(dailyTotalMarginsForDD).length > 0 && peakTotalBrokerMargin > 0) {
                // Find the maximum drawdown from daily margins
                let maxDD = 0;
                let peakAtMaxDD = peakTotalBrokerMargin;
                let currentPeak = 0;
                
                const sortedDates = Object.keys(dailyTotalMarginsForDD).sort((a, b) => {
                    const dateA = a.split('/').reverse().join('');
                    const dateB = b.split('/').reverse().join('');
                    return dateA.localeCompare(dateB);
                });
                
                sortedDates.forEach(date => {
                    const margin = dailyTotalMarginsForDD[date];
                    if (margin > currentPeak) {
                        currentPeak = margin;
                    }
                    const dd = margin - currentPeak;
                    if (dd < maxDD) {
                        maxDD = dd;
                        peakAtMaxDD = currentPeak; // Capture peak at the time of max DD
                    }
                });
                
                allBrokerMaxDDPercent = peakAtMaxDD > 0 ? (maxDD / peakAtMaxDD) * 100 : 0;
            }
            
            // Calculate DD Expense for All Broker from All Broker DD start date
            // Use same logic as individual accounts but with All Broker DD dates
            const allBrokerDDStartForExpense = getAllBrokerDDStartDate();
            let allBrokerDDExp = 0;
            
            if (allBrokerDDStartForExpense && allBrokerDDStartForExpense !== '-' && Object.keys(dailyTotalExpenses).length > 0) {
                const sortedDates = Object.keys(dailyTotalExpenses).sort((a, b) => {
                    const dateA = a.split('/').reverse().join('');
                    const dateB = b.split('/').reverse().join('');
                    return dateA.localeCompare(dateB);
                });
                
                const ddStartIndex = sortedDates.findIndex(d => {
                    const dateA = d.split('/').reverse().join('');
                    const dateB = allBrokerDDStartForExpense.split('/').reverse().join('');
                    return dateA >= dateB;
                });
                
                if (ddStartIndex >= 0) {
                    for (let i = ddStartIndex; i < sortedDates.length; i++) {
                        allBrokerDDExp += dailyTotalExpenses[sortedDates[i]] || 0;
                    }
                }
            }
            
            // Calculate DD Expense % for All Broker using Peak Total Margin
            const allBrokerDDExpensePercent = peakTotalMarginForAllBroker > 0 ? (allBrokerDDExp / peakTotalMarginForAllBroker) * 100 : 0;
            
            // Calculate combined DD duration, start and end for selected brokers
            let earliestDDStart = null;
            let latestDDEnd = null;
            allBrokerLevelData.forEach(item => {
                const code = item.strategy;
                const strategies = filteredStrategies.filter(s => s.parentAccount === code);
                if (strategies.length === 0) return;
                
                const ddStart = getAccountDDStartDate(code);
                const ddEnd = getAccountDDEndDate(code);
                
                if (ddStart && ddStart !== '-') {
                    if (!earliestDDStart || compareDates(ddStart, earliestDDStart) < 0) {
                        earliestDDStart = ddStart;
                    }
                }
                if (ddEnd && ddEnd !== '-') {
                    if (!latestDDEnd || compareDates(ddEnd, latestDDEnd) > 0) {
                        latestDDEnd = ddEnd;
                    }
                }
            });
            
            const allBrokerDDDur = earliestDDStart && latestDDEnd ? calculateDaysBetween(earliestDDStart, latestDDEnd) : 0;
            const allBrokerDDStart = formatDateForDisplay(earliestDDStart || '-');
            const allBrokerDDEnd = formatDateForDisplay(latestDDEnd || '-');
            
            const extraMarginClass = allBrokerExtraMargin > 0 ? 'positive' : (allBrokerExtraMargin < 0 ? 'negative' : 'neutral');
            const extraMarginPercentClass = allBrokerExtraMarginPercent > 0 ? 'positive' : (allBrokerExtraMarginPercent < 0 ? 'negative' : 'neutral');
            
            // Render "All Broker" summary row
            html += `<tr style="background: #f3f4f6; font-weight: 600;">
                <td style="font-weight: 600; color: #000000;">🏦 All Broker</td>
                <td>${allBrokerStrategyCount}</td>
                <td>${formatCurrency(allBrokerStgMargin)}</td>
                <td>${formatCurrency(allBrokerMargin)}</td>
                <td class="${extraMarginClass}">${formatCurrency(allBrokerExtraMargin)}</td>
                <td class="${extraMarginPercentClass}">${formatPercent(allBrokerExtraMarginPercent)}</td>
                <td class="${allBrokerCurrentDD < 0 ? 'negative' : 'neutral'}">${allBrokerCurrentDD < 0 ? formatCurrency(allBrokerCurrentDD) : '-'}</td>
                <td class="${allBrokerCurrentDDPercent < 0 ? 'negative' : 'neutral'}">${allBrokerCurrentDD < 0 ? formatPercent(allBrokerCurrentDDPercent) : '0.00%'}</td>
                <td class="${allBrokerDDExp < 0 ? 'negative' : (allBrokerDDExp > 0 ? 'positive' : 'neutral')}">${allBrokerCurrentDD < 0 && allBrokerDDExp !== 0 ? formatCurrency(allBrokerDDExp) : '-'}</td>
                <td class="${allBrokerDDExpensePercent < 0 ? 'negative' : (allBrokerDDExpensePercent > 0 ? 'positive' : 'neutral')}">${allBrokerCurrentDD < 0 && allBrokerDDExp !== 0 ? formatPercent(allBrokerDDExpensePercent) : '-'}</td>
                <td>${allBrokerCurrentDD < 0 && allBrokerDDDur > 0 ? allBrokerDDDur + ' days' : '-'}</td>
                <td>${allBrokerCurrentDD < 0 ? allBrokerDDStart : '-'}</td>
                <td>${allBrokerCurrentDD < 0 ? allBrokerDDEnd : '-'}</td>
                <td class="${allBrokerExpense < 0 ? 'negative' : (allBrokerExpense > 0 ? 'positive' : 'neutral')}">${formatCurrency(allBrokerExpense)}</td>
                <td class="negative">${formatPercent(allBrokerMaxDDPercent)}</td>
            </tr>`;
            
            allBrokerLevelData.forEach(item => {
                const code = item.strategy;
                // Get broker margin from calculated trade data
                const brokerMargin = getBrokerMarginForAccount(code) || 0;
                // Get FILTERED strategies under this broker/account for Lot Size and STG Margin calculation
                let strategies;
                if (false) { // Brokers removed
                } else {
                    strategies = filteredStrategies.filter(s => s.parentAccount === code);
                }
                // If no filtered strategies, skip this row
                if (strategies.length === 0) {
                    return;
                }
                // Calculate Strategy Count and STG Margin from FILTERED strategies
                const strategyCount = strategies.length;
                const totalLotSize = strategies.reduce((sum, s) => sum + (s.lotSize || 0), 0);
                const stgMargin = totalLotSize * lotMargin;
                // Calculate Add Fund (based on filtered STG Margin)
                const addFund = brokerMargin - stgMargin;
                const addFundPercent = stgMargin > 0 ? (addFund / stgMargin) * 100 : 0;
                const addFundClass = addFund > 0 ? 'positive' : (addFund < 0 ? 'negative' : 'neutral');
                const addFundPercentClass = addFundPercent > 0 ? 'positive' : (addFundPercent < 0 ? 'negative' : 'neutral');
                // Calculate account-level Expense
                const accountExpense = calculateAccountExpense(code);
                const expensePercent = brokerMargin > 0 ? (accountExpense / brokerMargin) * 100 : 0;
                // Calculate account-level current DD based on daily margins (same as broker DD calculation)
                // A/C DD = Current Account Margin - Peak Account Margin (NOT pre-calculated currentDD)
                const currentAccountMargin = getCurrentAccountMargin(code) || brokerMargin;
                const accountPeak = getAccountPeakMargin(code) || currentAccountMargin;
                const currentDD = currentAccountMargin - accountPeak;
                // A/C DD % = (A/C DD ₹ / Peak Account Margin) × 100
                const currentDDPercent = accountPeak > 0 ? (currentDD / accountPeak) * 100 : 0;
                // Get DD duration, start, and end from calculated values
                const ddDuration = getAccountDDDuration(code);
                const ddStartDate = formatDateForDisplay(getAccountDDStartDate(code));
                const ddEndDate = formatDateForDisplay(getAccountDDEndDate(code));
                // Calculate DD Expense (sum of expenses from DD start date)
                const ddExpense = getAccountDDExpense(code);
                // Calculate DD Expense % using Peak Account Margin
                const ddExpensePercent = accountPeak > 0 ? (ddExpense / accountPeak) * 100 : 0;
                
                // Calculate Max DD % using historical margin data (same method as All Broker)
                let maxDDPercent = 0;
                if (accountDailyMargins[code] && Object.keys(accountDailyMargins[code]).length > 0) {
                    const accountPeak = accountPeakMargins[code] || 0;
                    if (accountPeak > 0) {
                        let maxDD = 0;
                        let peakAtMaxDD = accountPeak;
                        let currentPeak = 0;
                        
                        const sortedDates = Object.keys(accountDailyMargins[code]).sort((a, b) => {
                            const dateA = a.split('/').reverse().join('');
                            const dateB = b.split('/').reverse().join('');
                            return dateA.localeCompare(dateB);
                        });
                        
                        sortedDates.forEach(date => {
                            const margin = accountDailyMargins[code][date];
                            if (margin > currentPeak) {
                                currentPeak = margin;
                            }
                            const dd = margin - currentPeak;
                            if (dd < maxDD) {
                                maxDD = dd;
                                peakAtMaxDD = currentPeak;
                            }
                        });
                        
                        maxDDPercent = peakAtMaxDD > 0 ? (maxDD / peakAtMaxDD) * 100 : 0;
                    }
                }
                
                // Account-level styling (no separate brokers)
                const icon = '├─';
                const nameStyle = 'font-weight: 500; color: #475569; padding-left: 20px;';
                
                html += `<tr>
                    <td style="${nameStyle}">${icon} ${getDisplayName(code)}</td>
                    <td>${strategyCount}</td>
                    <td>${formatCurrency(stgMargin)}</td>
                    <td>${formatCurrency(brokerMargin)}</td>
                    <td class="${addFundClass}">${formatCurrency(addFund)}</td>
                    <td class="${addFundPercentClass}">${formatPercent(addFundPercent)}</td>
                    <td class="${currentDD < 0 ? 'negative' : 'neutral'}">${currentDD < 0 ? formatCurrency(currentDD) : '-'}</td>
                    <td class="${currentDDPercent < 0 ? 'negative' : 'neutral'}">${currentDD < 0 ? formatPercent(currentDDPercent) : '0.00%'}</td>
                    <td class="${ddExpense < 0 ? 'negative' : (ddExpense > 0 ? 'positive' : 'neutral')}">${currentDD < 0 && ddExpense !== 0 ? formatCurrency(ddExpense) : '-'}</td>
                    <td class="${ddExpensePercent < 0 ? 'negative' : (ddExpensePercent > 0 ? 'positive' : 'neutral')}">${currentDD < 0 && ddExpense !== 0 ? formatPercent(ddExpensePercent) : '-'}</td>
                    <td>${currentDD < 0 && ddDuration > 0 ? ddDuration + ' days' : '-'}</td>
                    <td>${currentDD < 0 ? ddStartDate : '-'}</td>
                    <td>${currentDD < 0 ? ddEndDate : '-'}</td>
                    <td class="${accountExpense < 0 ? 'negative' : (accountExpense > 0 ? 'positive' : 'neutral')}">${formatCurrency(accountExpense)}</td>
                    <td class="negative">${formatPercent(maxDDPercent)}</td>
                </tr>`;
            });
            if (html === '') {
                tbody.innerHTML = '<tr><td colspan="15" class="empty-state">No broker data matches the current filters.</td></tr>';
            } else {
                tbody.innerHTML = html;
            }
        }
        function updateSummaryCards(allBrokers, allAccounts, allStrategies) {
            // Always use full data for summary cards, regardless of view type filter
            const accounts = allAccounts || [];
            const strategies = allStrategies || [];
            
            if (accounts.length === 0 && strategies.length === 0) return;
            
            // Initialize totals
            let totalBrokerMargin = 0;
            let totalStgMargin = 0;
            
            // Calculate totals from accounts
            accounts.forEach(account => {
                const accountCode = account.strategy;
                
                // Get filtered strategies for this account
                const accountStrategies = strategies.filter(s => s.parentAccount === accountCode);
                const lotSize = accountStrategies.reduce((sum, s) => sum + (s.lotSize || 0), 0);
                const stgMargin = lotSize * lotMargin;
                
                // Get broker margin
                const brokerMargin = getBrokerMarginForAccount(accountCode) || 0;
                
                totalBrokerMargin += brokerMargin;
                totalStgMargin += stgMargin;
            });
            
            // Calculate Total Current DD using same method as Strategy Level Metrics "All Broker" row
            // This is sum of Current DD (₹) from filtered strategies
            let totalCurrentDDRupees = 0;
            strategies.forEach(strategy => {
                totalCurrentDDRupees += strategy.currentDD || 0;
            });
            
            // Update Total Broker Margin
            if (totalBrokerMargin === 0) {
                document.getElementById('totalBrokerMargin').textContent = '-';
            } else {
                const formatted = formatCurrency(totalBrokerMargin);
                document.getElementById('totalBrokerMargin').textContent = formatted === '-' ? '-' : '₹' + formatted;
            }
            
            // Update Total STG Margin
            if (totalStgMargin === 0) {
                document.getElementById('totalStgMargin').textContent = '-';
            } else {
                const formatted = formatCurrency(totalStgMargin);
                document.getElementById('totalStgMargin').textContent = formatted === '-' ? '-' : '₹' + formatted;
            }
            
            // Update Total Current DD (₹) - use sum of account DDs from original data
            if (totalCurrentDDRupees === 0) {
                document.getElementById('totalCurrentDDRupees').textContent = '-';
            } else {
                const formatted = formatCurrency(totalCurrentDDRupees);
                document.getElementById('totalCurrentDDRupees').textContent = formatted === '-' ? '-' : '₹' + formatted;
            }
            
            // Calculate and update Total Current DD % (based on STG margin)
            const totalCurrentDDPercent = totalStgMargin > 0 
                ? (totalCurrentDDRupees / totalStgMargin) * 100 
                : 0;
            document.getElementById('totalCurrentDDPercent').textContent = formatPercent(totalCurrentDDPercent);
            
            // Calculate STG DD using SAME method as All Broker row
            // STG DD = Current Total Margin - Peak Total Margin
            const currentTotalMargin = getCurrentTotalBrokerMargin();
            const peakTotalMargin = getPeakTotalBrokerMargin();
            
            // If we have daily margin data, use it; otherwise fallback to sum of account DDs
            let calculatedStgDD;
            if (currentTotalMargin > 0 && peakTotalMargin > 0) {
                calculatedStgDD = currentTotalMargin - peakTotalMargin;
            } else {
                calculatedStgDD = totalCurrentDDRupees; // fallback
            }
            
            // Calculate ALL ACCOUNT DD percentage = (DD ₹ / Peak Total Margin) × 100
            const allAccountDDPercent = peakTotalMargin > 0 ? (calculatedStgDD / peakTotalMargin) * 100 : 0;
            
            // Update ALL ACCOUNT DD(₹) with percentage in brackets
            if (calculatedStgDD === 0) {
                document.getElementById('stgDDFromB').innerHTML = '-';
            } else {
                const formatted = formatCurrency(calculatedStgDD);
                const formattedPercent = formatPercent(allAccountDDPercent);
                document.getElementById('stgDDFromB').innerHTML = '₹' + formatted + '  <span style="font-size: 14px; color: #6b7280;">[' + formattedPercent + ']</span>';
            }
            // Update broker-wise DD cards
            updateBrokerWiseCards(accounts, strategies);
        }
        function updateBrokerWiseCards(accounts, strategies) {
            // Find the main summary-cards container
            const container = document.querySelector('.summary-cards');
            if (!container) {return;
            }            
            // Remove any existing broker DD cards (to avoid duplicates on re-render)
            const existingBrokerCards = container.querySelectorAll('.broker-dd-card');
            existingBrokerCards.forEach(card => card.remove());
            // Get all broker accounts (ACA, CEA, ZEA, B1, B2, etc.) from ORIGINAL drawdownData
            const allBrokerAccounts = drawdownData.filter(d => 
                d.strategy && 
                d.isGroup &&
                !d.isBroker &&
                !d.strategy.startsWith('A.PRO') && // Exclude A.PRO
                (extractBrokerCode(d.strategy) || /^[A-Z0-9]{2,4}A?$/.test(d.strategy)) // Match broker codes like ACA, CEA, ZEA, B1, B2 or extract from PRO strategies
            );// Sort broker accounts
            const sortedAccounts = allBrokerAccounts.sort((a, b) => {
                return a.strategy.localeCompare(b.strategy);
            });
            // Helper function to calculate account STG margin from FILTERED strategies
            function calculateAccountStgMargin(accountStrategy) {
                const children = strategies.filter(s => s.parentAccount === accountStrategy);
                if (children.length === 0) return 0;
                const lotSize = children.reduce((sum, c) => sum + (c.lotSize || 0), 0);
                return lotSize * lotMargin;
            }
            // Create and append each broker card to the main container
            sortedAccounts.forEach(account => {
                const accountName = getDisplayName(account.strategy);
                const accountCode = account.strategy;
                
                // Use SAME calculation as Broker Level Metrics table
                // Current DD = Current Account Margin - Peak Account Margin
                const currentAccountMargin = getCurrentAccountMargin(accountCode);
                const accountPeak = getAccountPeakMargin(accountCode);
                
                // If we have daily margin data, use it; otherwise fallback to original data
                let currentDD;
                if (currentAccountMargin > 0 && accountPeak > 0) {
                    currentDD = currentAccountMargin - accountPeak;
                } else {
                    // Fallback to original drawdownData
                    currentDD = account.currentDD || 0;
                }
                
                // Calculate percentage using peak account margin = (DD ₹ / Peak Margin) × 100
                const ddPercent = accountPeak > 0 ? (currentDD / accountPeak) * 100 : 0;
                const formattedPercent = formatPercent(ddPercent);
                // Format combined value with percentage in brackets with smaller font and grey color
                const formattedDD = currentDD === 0 ? '-' : '₹' + formatCurrency(currentDD) + '  <span style="font-size: 14px; color: #6b7280;">[' + formattedPercent + ']</span>';
                const valueClass = currentDD < 0 ? 'negative' : currentDD > 0 ? 'positive' : '';const cardDiv = document.createElement('div');
                cardDiv.className = 'summary-card drawdown-box broker-dd-card';
                cardDiv.innerHTML = `
                    <div class="summary-card-label">${accountName} DD (₹)</div>
                    <div class="summary-card-value ${valueClass}">${formattedDD}</div>
                `;
                container.appendChild(cardDiv);
            });        }
        function sortTable(column) {
            if (sortColumn === column) {
                sortDirection = sortDirection === 'asc' ? 'desc' : 'asc';
            } else {
                sortColumn = column;
                sortDirection = 'desc';
            }
            applyFilters();
        }
        function handleSortSelect() {
            sortColumn = document.getElementById('sortSelect').value;
            sortDirection = sortColumn === 'strategy' ? 'asc' : 'desc';
            applyFilters();
        }
        function resetFilters() {
            hiddenStrategies.clear();
            // Reset broker selection to all brokers
            allBrokerCodes.forEach(b => selectedBrokers.add(b));
            document.getElementById('minDrawdownFilter').value = '';
            document.getElementById('viewTypeFilter').value = 'all';
            document.getElementById('sortSelect').value = 'strategy';
            sortColumn = 'strategy';
            sortDirection = 'asc';
            
            // Reset Lot Margin to default
            lotMargin = 400000;
            document.getElementById('lotMarginInput').value = formatCurrency(400000);
            
            updateStrategyCheckboxes();
            updateSelectedCount();
            updateBrokerCheckboxes();
            updateBrokerSelectedCount();
            clearSavedFilters();
            
            // Recalculate with reset lot margin
            if (originalTradesData && originalTradesData.length > 0) {
                applyDateFilterAndProcess();
            }
            applyFilters();
        }
        function populateStrategyOptions() {
            allStrategyNames = drawdownData.filter(d => d.isChild).map(d => d.strategy).sort();
            const container = document.getElementById('strategyOptions');
            
            container.innerHTML = allStrategyNames.map(s => {
                // Format strategy name with space
                let displayName = s;
                // Handle B1, B2 patterns: B1PRO 1 -> B1 PRO 1
                const b1b2Match = s.match(/^(B[12])(PRO\s*\d+)$/i);
                if (b1b2Match) {
                    displayName = b1b2Match[1] + ' ' + b1b2Match[2];
                } else {
                    // Handle other patterns: ACAPRO 1 -> ACA PRO 1
                    const match = s.match(/^([A-Z]{2,3})(PRO\s*\d+)$/i);
                    if (match) {
                        displayName = match[1] + ' ' + match[2];
                    }
                }
                
                return `
                <div class="dropdown-option" onclick="handleRowClick(event, '${s.replace(/'/g, "\\'")}')">
                    <input type="checkbox" id="strategy-${CSS.escape(s)}" value="${s}" ${!hiddenStrategies.has(s) ? 'checked' : ''} onchange="toggleStrategy('${s.replace(/'/g, "\\'")}')">
                    <label for="strategy-${CSS.escape(s)}">${displayName}</label>
                </div>`;
            }).join('');
            
            updateSelectedCount();
        }
        function handleRowClick(event, strategy) {
            // If clicking directly on checkbox, let the default behavior handle it
            if (event.target.tagName === 'INPUT') {
                return;
            }
            // If clicking on label, let it toggle the checkbox naturally (via for attribute)
            if (event.target.tagName === 'LABEL') {
                return;
            }
            // Otherwise (clicking on div padding), toggle the checkbox which will trigger onchange
            const checkbox = document.getElementById(`strategy-${CSS.escape(strategy)}`);
            if (checkbox) {
                checkbox.checked = !checkbox.checked;
                // Manually trigger the change event
                checkbox.dispatchEvent(new Event('change'));
            }
        }
        function toggleStrategyDropdown(event) {
            if (event) event.stopPropagation();
            const menu = document.getElementById('strategyDropdownMenu');
            const isShowing = menu.classList.contains('show');
            
            document.getElementById('strategyDropdownMenu').classList.toggle('show');
            // Close broker dropdown if open
            document.getElementById('brokerDropdownMenu').classList.remove('show');
            
            // Clear any existing timeout
            if (window.strategyDropdownTimeout) {
                clearTimeout(window.strategyDropdownTimeout);
            }
            
            // Set 10-second auto-close timer if dropdown is now showing
            if (!isShowing) {
                window.strategyDropdownTimeout = setTimeout(() => {
                    document.getElementById('strategyDropdownMenu').classList.remove('show');
                }, 10000);
            }
        }
        function toggleStrategy(strategy) {
            hiddenStrategies.has(strategy) ? hiddenStrategies.delete(strategy) : hiddenStrategies.add(strategy);
            updateSelectedCount();
            applyFilters();
        }
        function selectAllStrategies() {
            hiddenStrategies.clear();
            updateStrategyCheckboxes();
            updateSelectedCount();
            applyFilters();
        }
        function selectNoneStrategies() {
            allStrategyNames.forEach(s => hiddenStrategies.add(s));
            updateStrategyCheckboxes();
            updateSelectedCount();
            applyFilters();
        }
        function resetStrategySelection() {
            hiddenStrategies.clear();
            updateStrategyCheckboxes();
            updateSelectedCount();
            applyFilters();
        }
        function updateStrategyCheckboxes() {
            allStrategyNames.forEach(s => {
                const cb = document.getElementById(`strategy-${CSS.escape(s)}`);
                if (cb) cb.checked = !hiddenStrategies.has(s);
            });
        }
        function updateSelectedCount() {
            const badge = document.getElementById('selectedCount');
            const hiddenCount = hiddenStrategies.size;
            
            if (hiddenCount > 0) {
                badge.textContent = hiddenCount;
                badge.style.display = 'inline-block';
            } else {
                badge.style.display = 'none';
            }
        }
        // Broker dropdown functions
        function populateBrokerOptions() {
            // Get all broker accounts from drawdownData
            allBrokerCodes = drawdownData
                .filter(d => d.isGroup && !d.isBroker && !d.strategy.startsWith('A.PRO'))
                .map(d => d.strategy)
                .sort();
            
            // If selectedBrokers is empty, select all brokers by default
            if (selectedBrokers.size === 0) {
                allBrokerCodes.forEach(b => selectedBrokers.add(b));
            }
            
            const container = document.getElementById('brokerOptions');
            container.innerHTML = allBrokerCodes.map(b => {
                return `
                <div class="dropdown-option" onclick="handleBrokerRowClick(event, '${b.replace(/'/g, "\\'")}')">
                    <input type="checkbox" id="broker-${CSS.escape(b)}" value="${b}" ${selectedBrokers.has(b) ? 'checked' : ''} onchange="toggleBroker('${b.replace(/'/g, "\\'")}')">
                    <label for="broker-${CSS.escape(b)}">${getDisplayName(b)}</label>
                </div>`;
            }).join('');
            
            updateBrokerSelectedCount();
        }
        function handleBrokerRowClick(event, broker) {
            if (event.target.tagName === 'INPUT' || event.target.tagName === 'LABEL') {
                return;
            }
            const checkbox = document.getElementById(`broker-${CSS.escape(broker)}`);
            if (checkbox) {
                checkbox.checked = !checkbox.checked;
                checkbox.dispatchEvent(new Event('change'));
            }
        }
        function toggleBrokerDropdown(event) {
            if (event) event.stopPropagation();
            const menu = document.getElementById('brokerDropdownMenu');
            const isShowing = menu.classList.contains('show');
            
            document.getElementById('brokerDropdownMenu').classList.toggle('show');
            // Close strategy dropdown if open
            document.getElementById('strategyDropdownMenu').classList.remove('show');
            
            // Clear any existing timeout
            if (window.brokerDropdownTimeout) {
                clearTimeout(window.brokerDropdownTimeout);
            }
            
            // Set 10-second auto-close timer if dropdown is now showing
            if (!isShowing) {
                window.brokerDropdownTimeout = setTimeout(() => {
                    document.getElementById('brokerDropdownMenu').classList.remove('show');
                }, 10000);
            }
        }
        function toggleBroker(broker) {
            if (selectedBrokers.has(broker)) {
                selectedBrokers.delete(broker);
            } else {
                selectedBrokers.add(broker);
            }
            updateBrokerSelectedCount();
            applyFilters();
        }
        function selectAllBrokers() {
            allBrokerCodes.forEach(b => selectedBrokers.add(b));
            updateBrokerCheckboxes();
            updateBrokerSelectedCount();
            applyFilters();
        }
        function selectNoneBrokers() {
            selectedBrokers.clear();
            updateBrokerCheckboxes();
            updateBrokerSelectedCount();
            applyFilters();
        }
        function updateBrokerCheckboxes() {
            allBrokerCodes.forEach(b => {
                const cb = document.getElementById(`broker-${CSS.escape(b)}`);
                if (cb) cb.checked = selectedBrokers.has(b);
            });
        }
        function updateBrokerSelectedCount() {
            const badge = document.getElementById('brokerSelectedCount');
            const totalBrokers = allBrokerCodes.length;
            const selectedCount = selectedBrokers.size;
            
            // Show badge only if some brokers are deselected (not all selected)
            if (selectedCount > 0 && selectedCount < totalBrokers) {
                badge.textContent = selectedCount;
                badge.style.display = 'inline-block';
            } else if (selectedCount === 0) {
                // All deselected - show 0
                badge.textContent = '0';
                badge.style.display = 'inline-block';
            } else {
                // All selected - hide badge
                badge.style.display = 'none';
            }
        }
        function expandAll() {
            document.querySelectorAll('tbody tr').forEach(row => row.style.display = '');
        }
        function collapseAll() {
            document.querySelectorAll('tbody tr').forEach(row => {
                if (row.classList.contains('child-row') || row.classList.contains('group-row')) {
                    row.style.display = 'none';
                }
            });
        }
        function loadSavedFilters() {
            try {
                const saved = localStorage.getItem('drawdownFilters');
                if (saved) {
                    const data = JSON.parse(saved);
                    hiddenStrategies = new Set(data.hiddenStrategies || []);
                    
                    // Load saved broker selection if it exists
                    if (data.selectedBrokers && Array.isArray(data.selectedBrokers)) {
                        selectedBrokers = new Set(data.selectedBrokers);
                    } else {
                        // If no saved broker selection, select all brokers by default
                        selectedBrokers = new Set(allBrokerCodes);
                    }
                    
                    document.getElementById('minDrawdownFilter').value = data.minDD || '';
                    document.getElementById('viewTypeFilter').value = data.viewType || 'all';
                    document.getElementById('sortSelect').value = data.sortBy || 'strategy';
                    sortColumn = data.sortBy || 'strategy';
                    
                    // Load saved lot margin
                    if (data.lotMargin && data.lotMargin > 0) {
                        lotMargin = data.lotMargin;
                        document.getElementById('lotMarginInput').value = formatCurrency(data.lotMargin);
                    }
                    
                    // Set body data-view attribute for CSS visibility control
                    document.body.setAttribute('data-view', data.viewType || 'all');
                } else {
                    // If no saved filters at all, select all brokers by default
                    selectedBrokers = new Set(allBrokerCodes);
                }
            } catch (e) {
                // On error, select all brokers by default
                selectedBrokers = new Set(allBrokerCodes);
            }
        }
        function saveFilters() {
            try {
                localStorage.setItem('drawdownFilters', JSON.stringify({
                    hiddenStrategies: Array.from(hiddenStrategies),
                    selectedBrokers: Array.from(selectedBrokers),
                    minDD: document.getElementById('minDrawdownFilter').value,
                    viewType: document.getElementById('viewTypeFilter').value,
                    sortBy: sortColumn,
                    lotMargin: lotMargin
                }));
            } catch (e) {}
        }
        function clearSavedFilters() {
            try {
                localStorage.removeItem('drawdownFilters');
            } catch (e) {}
        }
        
        function exportToCSV() {
            // Get current date and time for filename
            const now = new Date();
            const dateStr = now.toISOString().split('T')[0];
            const timeStr = now.toTimeString().split(' ')[0].replace(/:/g, '-');
            const timestamp = `${dateStr}_${timeStr}`;
            
            let csvContent = '';
            
            // Export Broker Level Metrics
            csvContent += 'BROKER LEVEL METRICS\n';
            csvContent += 'Strategy,STG COUNT,STG Margin,A/C Margin,Add Fund,Add Fund(%),A/C DD (₹),A/C DD %,DD Expense (₹),DD Expense(%),DD Duration,A/C DD Start,A/C DD End,Expense (₹),Max DD %\n';
            
            const brokerTableBody = document.getElementById('brokerLevelTableBody');
            if (brokerTableBody) {
                const rows = brokerTableBody.querySelectorAll('tr');
                rows.forEach(row => {
                    const cells = row.querySelectorAll('td');
                    if (cells.length > 0 && !cells[0].classList.contains('empty-state')) {
                        const rowData = Array.from(cells).map(cell => {
                            let text = cell.textContent.trim();
                            // Remove currency symbols and commas for proper CSV formatting
                            text = text.replace(/₹/g, '').replace(/,/g, '');
                            // Handle cells with percentage and wrap in quotes if contains comma
                            if (text.includes(',')) {
                                text = `"${text}"`;
                            }
                            return text;
                        });
                        csvContent += rowData.join(',') + '\n';
                    }
                });
            }
            
            csvContent += '\n\n';
            
            // Export Strategy Level Metrics
            csvContent += 'STRATEGY LEVEL METRICS\n';
            csvContent += 'Strategy,Lot Size,STG Margin,Broker Margin,Add Fund,Add Fund(%),Current DD (₹),Current DD %,A.PRO DD (₹),A.PRO DD(%),DD Duration,STG DD Start,STG DD End,Max DD (₹),Max DD %\n';
            
            const strategyTableBody = document.getElementById('drawdownTableBody');
            if (strategyTableBody) {
                const rows = strategyTableBody.querySelectorAll('tr');
                rows.forEach(row => {
                    const cells = row.querySelectorAll('td');
                    if (cells.length > 0 && !cells[0].classList.contains('empty-state')) {
                        const rowData = Array.from(cells).map(cell => {
                            let text = cell.textContent.trim();
                            // Remove currency symbols, commas, and special characters
                            text = text.replace(/₹/g, '').replace(/,/g, '');
                            // Remove tree structure characters
                            text = text.replace(/[├└─]/g, '').replace(/🏦/g, '');
                            text = text.trim();
                            // Wrap in quotes if contains comma
                            if (text.includes(',')) {
                                text = `"${text}"`;
                            }
                            return text;
                        });
                        csvContent += rowData.join(',') + '\n';
                    }
                });
            }
            
            // Create blob and download
            const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
            const link = document.createElement('a');
            const url = URL.createObjectURL(blob);
            link.setAttribute('href', url);
            link.setAttribute('download', `drawdown_analysis_${timestamp}.csv`);
            link.style.visibility = 'hidden';
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
        }
        function formatCurrency(val) {
            if (!val) return '-';
            const abs = Math.abs(val);
            const sign = val < 0 ? '-' : '';
            let str = Math.round(abs).toString();
            if (str.length > 3) {
                const last3 = str.slice(-3);
                const rest = str.slice(0, -3).replace(/\B(?=(\d{2})+(?!\d))/g, ',');
                str = rest + ',' + last3;
            }
            return sign + str;
        }
        function formatPercent(val) {
            return val ? val.toFixed(2) + '%' : '0.00%';
        }
        function formatNum(val, decimals = 2) {
            return val && val !== '-' ? val.toFixed(decimals) : '-';
        }
        function formatDate(dateStr) {
            if (!dateStr || dateStr === '-') return '-';
            try {
                const [d, m, y] = dateStr.split('/');
                const date = new Date(y, m - 1, d);
                const day = String(date.getDate()).padStart(2, '0');
                const month = date.toLocaleString('en-US', { month: 'short' });
                return `${day}-${month}`;
            } catch (e) {
                return dateStr;
            }
        }
        function getDisplayName(name) {
            // Handle specific mappings
            const displayNames = {
                'B': 'All Broker'
            };
            
            // If it's a special mapping, return mapped name
            if (displayNames[name]) {
                return displayNames[name];
            }
            
            // For strategy names with B1, B2 broker codes (e.g., B1PRO 1 -> PRO 1)
            const b1b2Match = name.match(/^B[12](PRO\s*\d+)$/i);
            if (b1b2Match) {
                return b1b2Match[1]; // Return just "PRO X" part
            }
            
            // For strategy names with other broker codes, remove the broker prefix
            // Examples: ACAPRO 4 -> PRO 4, CEAPRO 8 -> PRO 8, ZEAPRO 1 -> PRO 1
            const strategyMatch = name.match(/^[A-Z]{2,3}(PRO\s*\d+)$/i);
            if (strategyMatch) {
                return strategyMatch[1]; // Return just "PRO X" part
            }
            
            // For all other names (including ACA, CEA, ZEA, B1, B2, etc.), return as-is
            return name;
        }
        document.addEventListener('click', (e) => {
            // Close strategy dropdown
            const stratMenu = document.getElementById('strategyDropdownMenu');
            const stratSelector = e.target.closest('.strategy-selector');
            const allSelectors = document.querySelectorAll('.strategy-selector');
            
            // Check if click is outside any strategy-selector
            let clickedInsideSelector = false;
            allSelectors.forEach(sel => {
                if (sel.contains(e.target)) clickedInsideSelector = true;
            });
            
            if (!clickedInsideSelector) {
                if (stratMenu) {
                    stratMenu.classList.remove('show');
                    // Clear strategy dropdown timeout
                    if (window.strategyDropdownTimeout) {
                        clearTimeout(window.strategyDropdownTimeout);
                    }
                }
                const brokerMenu = document.getElementById('brokerDropdownMenu');
                if (brokerMenu) {
                    brokerMenu.classList.remove('show');
                    // Clear broker dropdown timeout
                    if (window.brokerDropdownTimeout) {
                        clearTimeout(window.brokerDropdownTimeout);
                    }
                }
            }
        });
        
        // Close dropdown with 250ms delay when mouse leaves the strategy-selector area
        let closeTimeout = null;
        const strategySelector = document.querySelector('.strategy-selector');
        if (strategySelector) {
            strategySelector.addEventListener('mouseleave', () => {
                closeTimeout = setTimeout(() => {
                    const menu = document.getElementById('strategyDropdownMenu');
                    if (menu) {
                        menu.classList.remove('show');
                    }
                }, 250);
            });
            
            // Cancel close if mouse re-enters before timeout
            strategySelector.addEventListener('mouseenter', () => {
                if (closeTimeout) {
                    clearTimeout(closeTimeout);
                    closeTimeout = null;
                }
            });
        }
        
        // Prevent clicks inside dropdown from closing it
        const dropdownMenu = document.getElementById('strategyDropdownMenu');
        if (dropdownMenu) {
            dropdownMenu.addEventListener('click', (e) => {
                e.stopPropagation();
            });
        }
        // Store trades data and calculated broker margins
        let tradesData = null;
        let originalTradesData = null; // Store original unfiltered data
        let calculatedBrokerMargins = {};
        // Calculate broker margin from trades data (same logic as strategy-performance.html)
        function calculateBrokerMarginFromTrades() {
            // tradesData is an array of trade objects
            if (!tradesData || !Array.isArray(tradesData) || tradesData.length === 0) {                calculatedBrokerMargins = {};
                return;
            }            
            // Build list of all strategies from trades
            const strategiesSet = new Set();
            tradesData.forEach(trade => {
                if (trade.strategyDetails) {
                    Object.keys(trade.strategyDetails).forEach(stratName => {
                        strategiesSet.add(stratName);
                    });
                }
            });
            const allStrategies = Array.from(strategiesSet);
            const allBrokerStrategies = allStrategies.filter(s => !s.startsWith('A.PRO'));const brokerMarginsByDate = {};
            // Collect margins by date and broker from trades
            tradesData.forEach(trade => {
                const tradeDate = trade.date;
                if (!brokerMarginsByDate[tradeDate]) {
                    brokerMarginsByDate[tradeDate] = {};
                }
                if (trade.strategyDetails) {
                    allBrokerStrategies.forEach(brokerStrat => {
                        const margin = trade.strategyDetails[brokerStrat]?.margin || 0;
                        const brokerCode = extractBrokerCode(brokerStrat);
                        if (brokerCode) {
                            if (!brokerMarginsByDate[tradeDate][brokerCode]) {
                                brokerMarginsByDate[tradeDate][brokerCode] = {};
                            }
                            // Store MAX margin for each strategy on each date
                            if (!brokerMarginsByDate[tradeDate][brokerCode][brokerStrat] || margin > brokerMarginsByDate[tradeDate][brokerCode][brokerStrat]) {
                                brokerMarginsByDate[tradeDate][brokerCode][brokerStrat] = margin;
                            }
                        }
                    });
                }
            });
            // Build PnL Tax by date and broker
            const brokerPnlTaxByDate = {};
            tradesData.forEach(trade => {
                const tradeDate = trade.date;
                if (!brokerPnlTaxByDate[tradeDate]) {
                    brokerPnlTaxByDate[tradeDate] = {};
                }
                if (trade && trade.strategyPnlTax) {
                    Object.entries(trade.strategyPnlTax).forEach(([stratName, pnlTax]) => {
                        if (!stratName.startsWith('A.PRO')) {
                            const brokerCode = extractBrokerCode(stratName);
                            if (brokerCode) {
                                if (!brokerPnlTaxByDate[tradeDate][brokerCode]) {
                                    brokerPnlTaxByDate[tradeDate][brokerCode] = {};
                                }
                                if (!brokerPnlTaxByDate[tradeDate][brokerCode][stratName]) {
                                    brokerPnlTaxByDate[tradeDate][brokerCode][stratName] = 0;
                                }
                                brokerPnlTaxByDate[tradeDate][brokerCode][stratName] += pnlTax;
                            }
                        }
                    });
                }
            });
            // Get sorted dates (latest first) - proper full date comparison
            const sortedDates = Object.keys(brokerMarginsByDate).sort((a, b) => {
                const parseDate = (dateStr) => {
                    const [day, month, year] = dateStr.split('/').map(Number);
                    return new Date(year, month - 1, day);
                };
                return parseDate(b) - parseDate(a); // Latest first
            });            
            // Get all unique brokers
            const allBrokersInData = new Set();
            Object.values(brokerMarginsByDate).forEach(dateMargins => {
                Object.keys(dateMargins).forEach(broker => allBrokersInData.add(broker));
            });
            // For each broker, find the most recent day with non-zero margin and calculate total margin with PnL tax
            const brokerMaxMargins = {};
            allBrokersInData.forEach(brokerCode => {
                for (let i = 0; i < sortedDates.length; i++) {
                    const checkDate = sortedDates[i];
                    if (brokerMarginsByDate[checkDate] && brokerMarginsByDate[checkDate][brokerCode]) {
                        const strategyMargins = Object.entries(brokerMarginsByDate[checkDate][brokerCode]);
                        const margins = strategyMargins.map(([strat, margin]) => margin);
                        const maxMargin = margins.length > 0 ? Math.max(...margins) : 0;
                        if (maxMargin > 0) {
                            // Accumulate PnL Tax from this date FORWARD to the most recent date
                            let accumulatedPnlTax = 0;
                            for (let j = i; j >= 0; j--) {
                                const dateToCheck = sortedDates[j];
                                if (brokerPnlTaxByDate[dateToCheck] && brokerPnlTaxByDate[dateToCheck][brokerCode]) {
                                    Object.values(brokerPnlTaxByDate[dateToCheck][brokerCode]).forEach(pnlTax => {
                                        accumulatedPnlTax += pnlTax;
                                    });
                                }
                            }
                            // Total margin = base margin + accumulated PnL tax
                            const totalMargin = maxMargin + accumulatedPnlTax;
                            brokerMaxMargins[brokerCode] = totalMargin;// Store margin for each account (ACA, CEA, ZEA, etc.)
                            calculatedBrokerMargins[brokerCode] = totalMargin;
                            break;
                        }
                    }
                }
            });}
        // Helper function to get broker margin for an account
        function getBrokerMarginForAccount(accountCode) {
            return calculatedBrokerMargins[accountCode] || 0;
        }
        
        // Store account margin history and expense data
        // Store account expense data and DD tracking
        let accountExpenseData = {};
        let peakTotalBrokerMargin = 0; // Peak of combined total margin
        let dailyTotalMarginsForDD = {}; // Store daily total margins same as strategy-performance
        let accountDailyMargins = {}; // Store daily margins per account (with PnL Tax)
        let accountPeakMargins = {}; // Store peak margin per account
        let accountDDStartDate = {}; // Store DD start date per account
        let accountDDEndDate = {}; // Store DD end date per account
        let accountDDDuration = {}; // Store DD duration per account
        let allBrokerDDStartDate = null; // DD start date for All Broker
        let allBrokerDDEndDate = null; // DD end date for All Broker
        let allBrokerDDDuration = 0; // DD duration for All Broker
        let accountDailyExpenses = {}; // Store daily expenses per account
        let dailyTotalExpenses = {}; // Store daily total expenses across all accounts
        
        // Helper function to calculate account-level expense
        function calculateAccountExpense(accountCode) {
            return accountExpenseData[accountCode] || 0;
        }
        
        // Helper function to get peak of total broker margin
        function getPeakTotalBrokerMargin() {
            return peakTotalBrokerMargin;
        }
        
        // Helper function to get current total broker margin from daily margins
        function getCurrentTotalBrokerMargin() {
            const dates = Object.keys(dailyTotalMarginsForDD);
            if (dates.length === 0) return 0;
            
            const sortedDates = dates.sort((a, b) => {
                const dateA = a.split('/').reverse().join('');
                const dateB = b.split('/').reverse().join('');
                return dateB.localeCompare(dateA); // Latest first
            });
            
            return dailyTotalMarginsForDD[sortedDates[0]] || 0;
        }
        
        // Helper function to get current margin for an account from daily margins
        function getCurrentAccountMargin(accountCode) {
            if (!accountDailyMargins[accountCode]) return 0;
            
            const dates = Object.keys(accountDailyMargins[accountCode]);
            if (dates.length === 0) return 0;
            
            const sortedDates = dates.sort((a, b) => {
                const dateA = a.split('/').reverse().join('');
                const dateB = b.split('/').reverse().join('');
                return dateB.localeCompare(dateA); // Latest first
            });
            
            return accountDailyMargins[accountCode][sortedDates[0]] || 0;
        }
        
        // Helper function to get peak margin for an account
        function getAccountPeakMargin(accountCode) {
            return accountPeakMargins[accountCode] || 0;
        }
        
        // Helper function to get DD start date for an account
        function getAccountDDStartDate(accountCode) {
            return accountDDStartDate[accountCode] || '-';
        }
        
        // Helper function to get DD end date for an account
        function getAccountDDEndDate(accountCode) {
            return accountDDEndDate[accountCode] || '-';
        }
        
        // Helper function to get DD duration for an account
        function getAccountDDDuration(accountCode) {
            return accountDDDuration[accountCode] || 0;
        }
        
        // Helper function to get All Broker DD start date
        function getAllBrokerDDStartDate() {
            return allBrokerDDStartDate || '-';
        }
        
        // Helper function to get All Broker DD end date
        function getAllBrokerDDEndDate() {
            return allBrokerDDEndDate || '-';
        }
        
        // Helper function to get All Broker DD duration
        function getAllBrokerDDDuration() {
            return allBrokerDDDuration || 0;
        }
        
        // Helper function to get DD Expense for an account (sum of expenses from DD start date)
        function getAccountDDExpense(accountCode) {
            const ddStart = accountDDStartDate[accountCode];
            if (!ddStart || !accountDailyExpenses[accountCode]) return 0;
            
            let totalExpense = 0;
            const sortedDates = Object.keys(accountDailyExpenses[accountCode]).sort((a, b) => {
                const dateA = a.split('/').reverse().join('');
                const dateB = b.split('/').reverse().join('');
                return dateA.localeCompare(dateB);
            });
            
            const ddStartIndex = sortedDates.findIndex(d => {
                const dateA = d.split('/').reverse().join('');
                const dateB = ddStart.split('/').reverse().join('');
                return dateA >= dateB;
            });
            
            if (ddStartIndex >= 0) {
                for (let i = ddStartIndex; i < sortedDates.length; i++) {
                    totalExpense += accountDailyExpenses[accountCode][sortedDates[i]] || 0;
                }
            }
            return totalExpense;
        }
        
        // Helper function to get All Broker DD Expense (sum of expenses from DD start date)
        function getAllBrokerDDExpense() {
            const ddStart = allBrokerDDStartDate;
            if (!ddStart || Object.keys(dailyTotalExpenses).length === 0) return 0;
            
            let totalExpense = 0;
            const sortedDates = Object.keys(dailyTotalExpenses).sort((a, b) => {
                const dateA = a.split('/').reverse().join('');
                const dateB = b.split('/').reverse().join('');
                return dateA.localeCompare(dateB);
            });
            
            const ddStartIndex = sortedDates.findIndex(d => {
                const dateA = d.split('/').reverse().join('');
                const dateB = ddStart.split('/').reverse().join('');
                return dateA >= dateB;
            });
            
            if (ddStartIndex >= 0) {
                for (let i = ddStartIndex; i < sortedDates.length; i++) {
                    totalExpense += dailyTotalExpenses[sortedDates[i]] || 0;
                }
            }
            return totalExpense;
        }
        
        // Helper function to format date from DD/MM/YY to DD-Mon format
        function formatDateForDisplay(dateStr) {
            if (!dateStr || dateStr === '-') return '-';
            const months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];
            const parts = dateStr.split('/');
            if (parts.length !== 3) return dateStr;
            const day = parts[0].padStart(2, '0');
            const monthIndex = parseInt(parts[1], 10) - 1;
            return `${day}-${months[monthIndex]}`;
        }
        
        // Helper function to calculate days between two dates
        function calculateDaysBetween(startDateStr, endDateStr) {
            if (!startDateStr || !endDateStr) return 0;
            const parseDate = (dateStr) => {
                const [day, month, year] = dateStr.split('/').map(Number);
                return new Date(2000 + year, month - 1, day);
            };
            const start = parseDate(startDateStr);
            const end = parseDate(endDateStr);
            const diffTime = Math.abs(end - start);
            return Math.ceil(diffTime / (1000 * 60 * 60 * 24));
        }
        
        // Helper function to compare two dates in DD/MM/YY format
        // Returns negative if date1 < date2, positive if date1 > date2, 0 if equal
        function compareDates(date1, date2) {
            if (!date1 || !date2) return 0;
            const d1 = date1.split('/').reverse().join('');
            const d2 = date2.split('/').reverse().join('');
            return d1.localeCompare(d2);
        }
        
        // Function to calculate margin history and expenses from trades
        // Uses SAME logic as strategy-performance.html calculateDailyTotalMargins
        function calculateAccountMetrics() {
            if (!tradesData || tradesData.length === 0) return;
            
            accountExpenseData = {};
            peakTotalBrokerMargin = 0;
            dailyTotalMarginsForDD = {};
            accountDailyMargins = {}; // Reset per-account daily margins
            accountPeakMargins = {}; // Reset per-account peak margins
            accountDDStartDate = {}; // Reset per-account DD start dates
            accountDDEndDate = {}; // Reset per-account DD end dates
            accountDDDuration = {}; // Reset per-account DD durations
            allBrokerDDStartDate = null; // Reset All Broker DD start date
            allBrokerDDEndDate = null; // Reset All Broker DD end date
            allBrokerDDDuration = 0; // Reset All Broker DD duration
            accountDailyExpenses = {}; // Reset per-account daily expenses
            dailyTotalExpenses = {}; // Reset daily total expenses
            
            // Track DD state for each account
            const accountDDState = {}; // { accountCode: { inDD: bool, ddStartDate: string } }
            let allBrokerDDState = { inDD: false, ddStartDate: null };
            
            // Get all broker strategies
            const strategiesSet = new Set();
            tradesData.forEach(trade => {
                if (trade.strategyDetails) {
                    Object.keys(trade.strategyDetails).forEach(stratName => {
                        if (!stratName.startsWith('A.PRO')) {
                            strategiesSet.add(stratName);
                        }
                    });
                }
            });
            
            // Sort trades by date (same as strategy-performance)
            const sortedTrades = [...tradesData].sort((a, b) => {
                const dateA = a.date.split('/').reverse().join('');
                const dateB = b.date.split('/').reverse().join('');
                return dateA.localeCompare(dateB);
            });
            
            // Group trades by date
            const tradesByDate = {};
            sortedTrades.forEach(trade => {
                const dateKey = trade.date;
                if (!tradesByDate[dateKey]) {
                    tradesByDate[dateKey] = [];
                }
                tradesByDate[dateKey].push(trade);
            });
            
            const sortedDates = Object.keys(tradesByDate).sort((a, b) => {
                const dateA = a.split('/').reverse().join('');
                const dateB = b.split('/').reverse().join('');
                return dateA.localeCompare(dateB);
            });
            
            // Build PnL Tax by date and broker (same as strategy-performance)
            const brokerPnlTaxByDate = {};
            sortedTrades.forEach(trade => {
                const tradeDate = trade.date;
                if (!brokerPnlTaxByDate[tradeDate]) {
                    brokerPnlTaxByDate[tradeDate] = {};
                }
                if (trade && trade.strategyPnlTax) {
                    Object.entries(trade.strategyPnlTax).forEach(([stratName, pnlTax]) => {
                        if (!stratName.startsWith('A.PRO')) {
                            const brokerCode = extractBrokerCode(stratName);
                            if (brokerCode) {
                                if (!brokerPnlTaxByDate[tradeDate][brokerCode]) {
                                    brokerPnlTaxByDate[tradeDate][brokerCode] = {};
                                }
                                if (!brokerPnlTaxByDate[tradeDate][brokerCode][stratName]) {
                                    brokerPnlTaxByDate[tradeDate][brokerCode][stratName] = 0;
                                }
                                brokerPnlTaxByDate[tradeDate][brokerCode][stratName] += pnlTax;
                            }
                        }
                    });
                }
            });
            
            // Track running totals by account for expense calculation
            const accountTotals = {};
            
            // Calculate daily total margins (SAME as strategy-performance.html)
            let previousDayBrokerMaxMargins = {};
            const brokerMarginDates = {};
            
            sortedDates.forEach((dateKey, dateIndex) => {
                const dayTrades = tradesByDate[dateKey];
                const dayBrokerMargins = {};
                
                dayTrades.forEach(trade => {
                    if (trade.strategyDetails) {
                        Object.entries(trade.strategyDetails).forEach(([stratName, details]) => {
                            if (!stratName.startsWith('A.PRO')) {
                                const margin = details.margin || 0;
                                const brokerCode = extractBrokerCode(stratName);
                                if (brokerCode) {
                                    if (!dayBrokerMargins[brokerCode]) {
                                        dayBrokerMargins[brokerCode] = {};
                                    }
                                    if (!dayBrokerMargins[brokerCode][stratName] || margin > dayBrokerMargins[brokerCode][stratName]) {
                                        dayBrokerMargins[brokerCode][stratName] = margin;
                                    }
                                    
                                    // Track for account expense calculation
                                    if (!accountTotals[brokerCode]) {
                                        accountTotals[brokerCode] = {
                                            margins: [],
                                            totalPnl: 0
                                        };
                                    }
                                    if (margin > 0) {
                                        accountTotals[brokerCode].margins.push(margin);
                                    }
                                }
                            }
                        });
                    }
                    
                    // Track PnL for expense calculation
                    if (trade.strategyPnlTax) {
                        Object.entries(trade.strategyPnlTax).forEach(([stratName, pnlTax]) => {
                            if (!stratName.startsWith('A.PRO')) {
                                const brokerCode = extractBrokerCode(stratName);
                                if (brokerCode && accountTotals[brokerCode]) {
                                    accountTotals[brokerCode].totalPnl += pnlTax || 0;
                                }
                            }
                        });
                    }
                });
                
                const currentDayBrokerMaxMargins = {};
                let dayTotalMargin = 0;
                
                const allBrokers = new Set([...Object.keys(dayBrokerMargins), ...Object.keys(previousDayBrokerMaxMargins)]);
                
                allBrokers.forEach(brokerCode => {
                    let brokerMaxMargin = 0;
                    let marginDate = dateKey;
                    
                    if (dayBrokerMargins[brokerCode]) {
                        const margins = Object.values(dayBrokerMargins[brokerCode]);
                        if (margins.length > 0) {
                            brokerMaxMargin = Math.max(...margins);
                        }
                    }
                    
                    // Carry forward previous day's margin if no data today
                    if (brokerMaxMargin === 0 && previousDayBrokerMaxMargins[brokerCode]) {
                        brokerMaxMargin = previousDayBrokerMaxMargins[brokerCode];
                        marginDate = brokerMarginDates[brokerCode] || dateKey;
                    }
                    
                    currentDayBrokerMaxMargins[brokerCode] = brokerMaxMargin;
                    brokerMarginDates[brokerCode] = marginDate;
                    dayTotalMargin += brokerMaxMargin;
                });
                
                // Add accumulated PnL Tax from margin date to current date (SAME as strategy-performance)
                let dayPnlTax = 0;
                const brokerPnlTaxForDay = {}; // Track PnL Tax per broker for this day
                
                allBrokers.forEach(brokerCode => {
                    const marginDate = brokerMarginDates[brokerCode];
                    const marginDateIndex = sortedDates.indexOf(marginDate);
                    let brokerDayPnlTax = 0;
                    
                    for (let i = marginDateIndex; i <= dateIndex; i++) {
                        const checkDate = sortedDates[i];
                        if (brokerPnlTaxByDate[checkDate] && brokerPnlTaxByDate[checkDate][brokerCode]) {
                            Object.values(brokerPnlTaxByDate[checkDate][brokerCode]).forEach(pnlTax => {
                                dayPnlTax += pnlTax;
                                brokerDayPnlTax += pnlTax;
                            });
                        }
                    }
                    brokerPnlTaxForDay[brokerCode] = brokerDayPnlTax;
                });
                
                // Calculate and store per-account daily margin (margin + PnL Tax) - SAME as strategy-performance
                // Also calculate daily expenses
                let dayTotalExpense = 0;
                
                allBrokers.forEach(brokerCode => {
                    const brokerMargin = currentDayBrokerMaxMargins[brokerCode] || 0;
                    const brokerPnlTax = brokerPnlTaxForDay[brokerCode] || 0;
                    const accountMarginOnDate = brokerMargin + brokerPnlTax;
                    
                    if (!accountDailyMargins[brokerCode]) {
                        accountDailyMargins[brokerCode] = {};
                    }
                    
                    // Calculate daily expense for this account
                    // Expense = Margin Change - PnL (negative expense means withdrawal)
                    const prevDates = Object.keys(accountDailyMargins[brokerCode]).sort((a, b) => {
                        const dateA = a.split('/').reverse().join('');
                        const dateB = b.split('/').reverse().join('');
                        return dateB.localeCompare(dateA); // Latest first
                    });
                    const prevMargin = prevDates.length > 0 ? accountDailyMargins[brokerCode][prevDates[0]] : 0;
                    
                    // Get today's PnL for this account from brokerPnlTaxByDate
                    let todayPnl = 0;
                    if (brokerPnlTaxByDate[dateKey] && brokerPnlTaxByDate[dateKey][brokerCode]) {
                        Object.values(brokerPnlTaxByDate[dateKey][brokerCode]).forEach(pnl => {
                            todayPnl += pnl || 0;
                        });
                    }
                    
                    const marginChange = accountMarginOnDate - prevMargin;
                    const dailyExpense = marginChange - todayPnl; // Positive = funds added, Negative = funds withdrawn
                    
                    if (!accountDailyExpenses[brokerCode]) {
                        accountDailyExpenses[brokerCode] = {};
                    }
                    accountDailyExpenses[brokerCode][dateKey] = dailyExpense;
                    dayTotalExpense += dailyExpense;
                    
                    accountDailyMargins[brokerCode][dateKey] = accountMarginOnDate;
                    
                    // Initialize DD state for this account if not exists
                    if (!accountDDState[brokerCode]) {
                        accountDDState[brokerCode] = { inDD: false, ddStartDate: null };
                    }
                    
                    // Track peak margin and DD state for each account
                    if (!accountPeakMargins[brokerCode] || accountMarginOnDate > accountPeakMargins[brokerCode]) {
                        // New peak - reset DD state
                        accountPeakMargins[brokerCode] = accountMarginOnDate;
                        accountDDState[brokerCode].inDD = false;
                        accountDDState[brokerCode].ddStartDate = null;
                    } else if (accountMarginOnDate < accountPeakMargins[brokerCode]) {
                        // Below peak - we're in drawdown
                        if (!accountDDState[brokerCode].inDD) {
                            // Just entered drawdown
                            accountDDState[brokerCode].inDD = true;
                            accountDDState[brokerCode].ddStartDate = dateKey;
                        }
                        // Update end date to current date (still in DD)
                        accountDDStartDate[brokerCode] = accountDDState[brokerCode].ddStartDate;
                        accountDDEndDate[brokerCode] = dateKey;
                        accountDDDuration[brokerCode] = calculateDaysBetween(accountDDState[brokerCode].ddStartDate, dateKey);
                    }
                });
                
                // Store total daily expense
                dailyTotalExpenses[dateKey] = dayTotalExpense;
                
                const totalMarginOnDate = dayTotalMargin + dayPnlTax;
                dailyTotalMarginsForDD[dateKey] = totalMarginOnDate;
                
                // Track All Broker peak and DD state
                if (totalMarginOnDate > peakTotalBrokerMargin) {
                    // New peak - reset DD state
                    peakTotalBrokerMargin = totalMarginOnDate;
                    allBrokerDDState.inDD = false;
                    allBrokerDDState.ddStartDate = null;
                } else if (totalMarginOnDate < peakTotalBrokerMargin) {
                    // Below peak - we're in drawdown
                    if (!allBrokerDDState.inDD) {
                        // Just entered drawdown
                        allBrokerDDState.inDD = true;
                        allBrokerDDState.ddStartDate = dateKey;
                    }
                    // Update end date to current date (still in DD)
                    allBrokerDDStartDate = allBrokerDDState.ddStartDate;
                    allBrokerDDEndDate = dateKey;
                    allBrokerDDDuration = calculateDaysBetween(allBrokerDDState.ddStartDate, dateKey);
                }
                
                previousDayBrokerMaxMargins = { ...currentDayBrokerMaxMargins };
            });
            
            // Calculate expense for each account
            Object.entries(accountTotals).forEach(([accountCode, data]) => {
                if (data.margins.length > 0) {
                    const currentMargin = getBrokerMarginForAccount(accountCode);
                    const initialMargin = data.margins[0];
                    const totalPnl = data.totalPnl;
                    
                    const marginChange = currentMargin - initialMargin;
                    const expense = marginChange - totalPnl;
                    
                    accountExpenseData[accountCode] = expense;
                }
            });
        }
        
        // Request trades data from parent on page load
        window.addEventListener('load', function() {// Check if we're in an iframe
            if (window.parent !== window) {window.parent.postMessage({ type: 'REQUEST_DATA_REFRESH' }, '*');
            } else {drawdownData = sampleData;// Initialize sample broker margins for standalone mode
                calculatedBrokerMargins = {
                    'ACA': 63700658,  // Sample broker margin for ACA
                    'CEA': 18181123   // Sample broker margin for CEA
                };
                // Initialize sample expense data for standalone mode
                accountExpenseData = {
                    'ACA': 250000,  // Sample expense for ACA (positive = added funds)
                    'CEA': 100000   // Sample expense for CEA (positive = added funds)
                };
                // Initialize peak total broker margin for standalone mode
                // Peak = max of (ACA + CEA) over time
                peakTotalBrokerMargin = 82000000;
                // Initialize daily total margins for standalone mode
                dailyTotalMarginsForDD = {
                    '01/01/25': 77000000,
                    '02/01/25': 80000000,
                    '03/01/25': 82000000, // Peak
                    '06/01/25': 81881781  // Current (ACA + CEA)
                };
                // Initialize per-account daily margins for standalone mode
                accountDailyMargins = {
                    'ACA': {
                        '01/01/25': 60000000,
                        '02/01/25': 62000000,
                        '03/01/25': 64000000, // Peak
                        '06/01/25': 63700658  // Current
                    },
                    'CEA': {
                        '01/01/25': 17000000,
                        '02/01/25': 18000000,
                        '03/01/25': 18000000, // Peak
                        '06/01/25': 18181123  // Current
                    }
                };
                // Initialize per-account peak margins for standalone mode
                accountPeakMargins = {
                    'ACA': 64000000,
                    'CEA': 18000000
                };
                // Initialize DD dates and durations for standalone mode
                accountDDStartDate = {
                    'ACA': '04/01/25',
                    'CEA': '04/01/25'
                };
                accountDDEndDate = {
                    'ACA': '06/01/25',
                    'CEA': '06/01/25'
                };
                accountDDDuration = {
                    'ACA': 2,
                    'CEA': 2
                };
                allBrokerDDStartDate = '04/01/25';
                allBrokerDDEndDate = '06/01/25';
                allBrokerDDDuration = 2;
                // Initialize daily expenses for standalone mode
                accountDailyExpenses = {
                    'ACA': {
                        '01/01/25': 0,
                        '02/01/25': -50000,
                        '03/01/25': -100000,
                        '04/01/25': -75000,  // DD starts here
                        '05/01/25': -50000,
                        '06/01/25': -25000
                    },
                    'CEA': {
                        '01/01/25': 0,
                        '02/01/25': -25000,
                        '03/01/25': -50000,
                        '04/01/25': -30000,  // DD starts here
                        '05/01/25': -20000,
                        '06/01/25': -10000
                    }
                };
                dailyTotalExpenses = {
                    '01/01/25': 0,
                    '02/01/25': -75000,
                    '03/01/25': -150000,
                    '04/01/25': -105000,  // DD starts here
                    '05/01/25': -70000,
                    '06/01/25': -35000
                };
                loadSavedFilters();
                populateStrategyOptions();
                populateBrokerOptions();
                applyFilters();
            }
        });

        // Date filtering and processing function
        function applyDateFilterAndProcess() {
            if (!originalTradesData) return;
            
            const fromDateInput = document.getElementById('fromDate');
            const toDateInput = document.getElementById('toDate');
            
            let filteredTrades = originalTradesData;
            
            // Parse dates if they exist
            const fromDate = fromDateInput?.value ? new Date(fromDateInput.value) : null;
            const toDate = toDateInput?.value ? new Date(toDateInput.value) : null;
            
            // Filter trades based on date range
            if (fromDate || toDate) {
                filteredTrades = originalTradesData.filter(trade => {
                    // Parse trade date (format: DD/MM/YY or DD/MM/YYYY)
                    const dateParts = trade.date.split('/');
                    if (dateParts.length !== 3) return true; // Keep if can't parse
                    
                    // Handle 2-digit years
                    let year = parseInt(dateParts[2]);
                    if (year < 100) {
                        year += 2000;
                    }
                    
                    const tradeDate = new Date(
                        year, // year
                        parseInt(dateParts[1]) - 1, // month (0-indexed)
                        parseInt(dateParts[0]) // day
                    );
                    
                    // Set both dates to start of day for inclusive comparison
                    if (fromDate) {
                        const fromDateStart = new Date(fromDate);
                        fromDateStart.setHours(0, 0, 0, 0);
                        if (tradeDate < fromDateStart) return false;
                    }
                    
                    if (toDate) {
                        // Set toDate to end of day for inclusive comparison
                        const toDateEnd = new Date(toDate);
                        toDateEnd.setHours(23, 59, 59, 999);
                        if (tradeDate > toDateEnd) return false;
                    }
                    
                    return true;
                });
            }
            
            // Set filtered trades as current tradesData
            tradesData = filteredTrades;
            
            // Calculate broker margins BEFORE processing drawdown
            calculateBrokerMarginFromTrades();
            // Calculate account-level metrics (DD and expenses)
            calculateAccountMetrics();
            // Now process the trades for drawdown display
            const tradesArray = Array.isArray(filteredTrades) ? filteredTrades : (filteredTrades?.trades || []);
            processTradesForDrawdown(tradesArray);
        }

        // Date range handling functions
        function setDateRange(range) {
            const today = new Date();
            const toDateInput = document.getElementById('toDate');
            const fromDateInput = document.getElementById('fromDate');
            
            // Set TO date to today using string format
            const todayYear = today.getFullYear();
            const todayMonth = String(today.getMonth() + 1).padStart(2, '0');
            const todayDay = String(today.getDate()).padStart(2, '0');
            toDateInput.value = `${todayYear}-${todayMonth}-${todayDay}`;
            
            if (range === '3M') {
                // Last 3 months
                const threeMonthsAgo = new Date(today);
                threeMonthsAgo.setMonth(today.getMonth() - 3);
                const year = threeMonthsAgo.getFullYear();
                const month = String(threeMonthsAgo.getMonth() + 1).padStart(2, '0');
                const day = String(threeMonthsAgo.getDate()).padStart(2, '0');
                fromDateInput.value = `${year}-${month}-${day}`;
            } else if (range === 'YTD') {
                // Year to date - January 1st of current year
                const year = today.getFullYear();
                fromDateInput.value = `${year}-01-01`;
            } else if (range === 'ALL') {
                // All time - reset to data range
                resetToAllTimeWithDataRange();
                applyDateFilterAndProcess();
                applyFilters();
                return; // Exit early as resetToAllTimeWithDataRange handles button activation
            }
            
            // Update active button styling
            document.querySelectorAll('.date-range-buttons .btn').forEach(btn => {
                btn.classList.remove('active');
            });
            event.target.classList.add('active');
            
            // Reprocess data with new date filter
            applyDateFilterAndProcess();
            // Reapply display filters
            applyFilters();
        }

        // Initialize date inputs on load
        window.addEventListener('DOMContentLoaded', () => {
            const fromDateInput = document.getElementById('fromDate');
            const toDateInput = document.getElementById('toDate');
            
            // Initial setup using string format
            const today = new Date();
            const year = today.getFullYear();
            const month = String(today.getMonth() + 1).padStart(2, '0');
            const day = String(today.getDate()).padStart(2, '0');
            
            if (toDateInput) {
                toDateInput.value = `${year}-${month}-${day}`;
            }
            
            // Set default to ALL TIME (no FROM date)
            if (fromDateInput) {
                fromDateInput.value = '';
            }
            
            // Set ALL TIME button as active by default
            document.querySelectorAll('.date-range-buttons .btn').forEach((btn) => {
                if (btn.textContent.trim() === 'ALL TIME') {
                    btn.classList.add('active');
                }
            });
            
            // Add event listeners for manual date changes
            if (fromDateInput) {
                fromDateInput.addEventListener('change', () => {
                    // Remove active class from all buttons when manually changing dates
                    document.querySelectorAll('.date-range-buttons .btn').forEach(btn => {
                        btn.classList.remove('active');
                    });
                    // Reprocess data with new date filter
                    applyDateFilterAndProcess();
                    // Reapply display filters
                    applyFilters();
                });
                
                // Add keyboard navigation with swapped arrow behavior
                fromDateInput.addEventListener('keydown', (e) => {
                    if (e.key === 'ArrowUp') {
                        e.preventDefault();
                        fromDateInput.stepDown();
                        document.querySelectorAll('.date-range-buttons .btn').forEach(btn => btn.classList.remove('active'));
                        applyDateFilterAndProcess();
                        applyFilters();
                    } else if (e.key === 'ArrowDown') {
                        e.preventDefault();
                        fromDateInput.stepUp();
                        document.querySelectorAll('.date-range-buttons .btn').forEach(btn => btn.classList.remove('active'));
                        applyDateFilterAndProcess();
                        applyFilters();
                    }
                });
            }
            
            if (toDateInput) {
                toDateInput.addEventListener('change', () => {
                    // Remove active class from all buttons when manually changing dates
                    document.querySelectorAll('.date-range-buttons .btn').forEach(btn => {
                        btn.classList.remove('active');
                    });
                    // Reprocess data with new date filter
                    applyDateFilterAndProcess();
                    // Reapply display filters
                    applyFilters();
                });
                
                // Add keyboard navigation with swapped arrow behavior
                toDateInput.addEventListener('keydown', (e) => {
                    if (e.key === 'ArrowUp') {
                        e.preventDefault();
                        toDateInput.stepDown();
                        document.querySelectorAll('.date-range-buttons .btn').forEach(btn => btn.classList.remove('active'));
                        applyDateFilterAndProcess();
                        applyFilters();
                    } else if (e.key === 'ArrowDown') {
                        e.preventDefault();
                        toDateInput.stepUp();
                        document.querySelectorAll('.date-range-buttons .btn').forEach(btn => btn.classList.remove('active'));
                        applyDateFilterAndProcess();
                        applyFilters();
                    }
                });
            }
            
            // Auto-close calendar popup on clicking outside
            document.addEventListener('click', function(event) {
                const isFromDate = fromDateInput && fromDateInput.contains(event.target);
                const isToDate = toDateInput && toDateInput.contains(event.target);
                
                if (!isFromDate && !isToDate) {
                    if (fromDateInput && document.activeElement === fromDateInput) {
                        fromDateInput.blur();
                    }
                    if (toDateInput && document.activeElement === toDateInput) {
                        toDateInput.blur();
                    }
                }
            });
            
            // Auto-close calendar popup on Escape key
            document.addEventListener('keydown', function(event) {
                if (event.key === 'Escape') {
                    if (fromDateInput && document.activeElement === fromDateInput) {
                        fromDateInput.blur();
                    }
                    if (toDateInput && document.activeElement === toDateInput) {
                        toDateInput.blur();
                    }
                }
            });
        });
        
        // Navigation functions for arrow buttons
        function navigateFromDate(direction) {
            const fromDateInput = document.getElementById('fromDate');
            if (!fromDateInput) return;
            
            let currentDate;
            if (fromDateInput.value) {
                currentDate = new Date(fromDateInput.value + 'T00:00:00');
            } else {
                currentDate = new Date();
            }
            
            let targetDate;
            if (direction === 'prev') {
                // Previous month's first date
                targetDate = new Date(currentDate.getFullYear(), currentDate.getMonth() - 1, 1);
            } else {
                // Next month's first date
                targetDate = new Date(currentDate.getFullYear(), currentDate.getMonth() + 1, 1);
            }
            
            const year = targetDate.getFullYear();
            const month = String(targetDate.getMonth() + 1).padStart(2, '0');
            const day = '01';
            
            fromDateInput.value = `${year}-${month}-${day}`;
            document.querySelectorAll('.date-range-buttons .btn').forEach(btn => btn.classList.remove('active'));
            applyDateFilterAndProcess();
            applyFilters();
        }
        
        function navigateToDate(direction) {
            const toDateInput = document.getElementById('toDate');
            if (!toDateInput) return;
            
            let currentDate;
            if (toDateInput.value) {
                currentDate = new Date(toDateInput.value + 'T00:00:00');
            } else {
                currentDate = new Date();
            }
            
            let targetDate;
            if (direction === 'prev') {
                // Previous month's last date
                targetDate = new Date(currentDate.getFullYear(), currentDate.getMonth(), 0);
            } else {
                // Next month's last date
                targetDate = new Date(currentDate.getFullYear(), currentDate.getMonth() + 2, 0);
            }
            
            const year = targetDate.getFullYear();
            const month = String(targetDate.getMonth() + 1).padStart(2, '0');
            const day = String(targetDate.getDate()).padStart(2, '0');
            
            toDateInput.value = `${year}-${month}-${day}`;
            document.querySelectorAll('.date-range-buttons .btn').forEach(btn => btn.classList.remove('active'));
            applyDateFilterAndProcess();
            applyFilters();
        }
    </script>
</body>
</html>
