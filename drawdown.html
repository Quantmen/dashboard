<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Drawdown Analysis</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        html, body { width: 100%; height: 100%; overflow: hidden; }
        
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: #f8fafc;
            color: #1e293b;
        }

        .container {
            overflow-y: auto;
            padding: 16px 32px 32px;
            height: 100vh;
        }

        .header { margin-bottom: 16px; }
        .header h1 { font-size: 20px; font-weight: 700; color: #111827; margin-bottom: 4px; letter-spacing: -0.5px; }
        .header p { font-size: 12px; color: #6b7280; }

        /* Summary Cards */
        .summary-cards {
            display: flex;
            gap: 12px;
            margin-bottom: 16px;
            overflow-x: auto;
        }

        .summary-card {
            background: white;
            border-radius: 8px;
            padding: 10px 12px;
            box-shadow: 0 1px 3px rgba(0,0,0,0.08);
            border: 1px solid #e5e7eb;
            flex: 1 1 0;
            min-width: 140px;
        }

        .summary-card-label {
            font-size: 10px;
            color: #6b7280;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            margin-bottom: 5px;
            font-weight: 700;
        }

        .summary-card-value {
            font-size: 18px;
            font-weight: 700;
            line-height: 1.2;
        }

        /* Controls */
        .controls {
            display: flex;
            gap: 12px;
            margin-bottom: 16px;
            flex-wrap: wrap;
            align-items: center;
        }

        .control-group {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .control-label {
            font-size: 12px;
            color: #374151;
            font-weight: 600;
        }

        select, input[type="number"], .btn {
            padding: 7px 12px;
            border: 1px solid #d1d5db;
            border-radius: 8px;
            font-size: 12px;
            font-weight: 500;
            background: white;
            color: #374151;
            cursor: pointer;
            transition: all 0.15s;
            font-family: inherit;
        }

        select:hover, input:hover, .btn:hover { 
            border-color: #9ca3af; 
            background: #f9fafb; 
        }

        select:focus, input:focus {
            outline: none;
            border-color: #3b82f6;
            box-shadow: 0 0 0 3px rgba(59,130,246,0.1);
        }

        /* Strategy Dropdown */
        .strategy-selector { position: relative; }
        
        .strategy-dropdown-btn {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 7px 12px;
            border: 1px solid #d1d5db;
            border-radius: 8px;
            background: white;
            cursor: pointer;
            font-size: 12px;
        }

        .strategy-dropdown-btn:hover { border-color: #9ca3af; background: #f9fafb; }

        .dropdown-badge {
            background: #3b82f6;
            color: white;
            padding: 2px 6px;
            border-radius: 10px;
            font-size: 10px;
            font-weight: 600;
        }

        .strategy-dropdown-menu {
            display: none;
            position: absolute;
            top: 100%;
            left: 0;
            margin-top: 6px;
            background: white;
            border: 1px solid #d1d5db;
            border-radius: 10px;
            box-shadow: 0 10px 15px rgba(0,0,0,0.1);
            min-width: 280px;
            max-height: 400px;
            overflow-y: auto;
            z-index: 1000;
        }

        .strategy-dropdown-menu.show { display: block; }

        .dropdown-header {
            padding: 12px 14px;
            border-bottom: 1px solid #e2e8f0;
            display: flex;
            justify-content: space-between;
        }

        .dropdown-action-btn {
            font-size: 11px;
            color: #1e40af;
            cursor: pointer;
            padding: 4px 8px;
            border-radius: 4px;
            background: none;
            border: none;
        }

        .dropdown-action-btn:hover { background: #eff6ff; }

        .dropdown-options { padding: 8px 0; }

        .dropdown-option {
            display: flex;
            align-items: center;
            padding: 8px 14px;
            cursor: pointer;
        }

        .dropdown-option:hover { background: #f8fafc; }
        .dropdown-option input { margin-right: 10px; cursor: pointer; }
        .dropdown-option label { font-size: 13px; color: #475569; cursor: pointer; }

        /* Table */
        .table-container {
            background: white;
            border-radius: 12px;
            box-shadow: 0 1px 3px rgba(0,0,0,0.08);
            border: 1px solid #e5e7eb;
        }

        table {
            width: 100%;
            border-collapse: separate;
            border-spacing: 0;
            font-size: 13px;
        }

        thead {
            background: #f3f4f6;
            position: sticky;
            top: 0;
            z-index: 10;
        }

        th {
            padding: 12px;
            text-align: left;
            font-size: 11px;
            font-weight: 700;
            color: #1f2937;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            border-bottom: 2px solid #d1d5db;
            border-right: 1px solid #e5e7eb;
            cursor: pointer;
        }

        th:last-child { border-right: none; }

        td {
            padding: 12px;
            border-right: 1px solid #f3f4f6;
            color: #374151;
        }

        td:last-child { border-right: none; }

        tbody tr {
            background: white;
            border-bottom: 1px solid #f3f4f6;
            transition: opacity 0.15s;
        }

        tbody tr:hover { opacity: 0.9; }

        /* Value Colors */
        .negative { color: #b91c1c; }
        .positive { color: #0d7c66; }
        .neutral { color: #6b7280; }

        /* Broker Row - Light Yellow */
        .broker-row {
            background: #fefce8 !important;
            font-weight: 700;
        }

        .broker-row:hover { background: #fef9c3 !important; }

        .broker-row td {
            border-right: 1px solid #fde047;
            color: #713f12;
            font-size: 14px;
        }

        .broker-name {
            font-size: 15px !important;
            font-weight: 800 !important;
            color: #1e40af !important;
        }

        /* Broker 1 (B1) - Pink */
        .group-b1 {
            background: #fce7f3 !important;
            font-weight: 700;
        }

        .group-b1:hover { background: #fbcfe8 !important; }

        .group-b1 td {
            border-right: 1px solid #f9a8d4;
            color: #831843;
            font-size: 13.5px;
        }

        .group-b1 .group-name {
            font-size: 14px !important;
            font-weight: 800 !important;
            color: #9f1239 !important;
            padding-left: 20px !important;
        }

        .child-row-b1 { background: #fef2f2 !important; }
        .child-row-b1:hover { background: #fce7f3 !important; }
        .child-row-b1 td { border-right: 1px solid #fecdd3; color: #7f1d1d; }

        /* Broker 2 (B2) - Light Orange */
        .group-b2 {
            background: #ffedd5 !important;
            font-weight: 700;
        }

        .group-b2:hover { background: #fed7aa !important; }

        .group-b2 td {
            border-right: 1px solid #fdba74;
            color: #7c2d12;
            font-size: 13.5px;
        }

        .group-b2 .group-name {
            font-size: 14px !important;
            font-weight: 800 !important;
            color: #9a3412 !important;
            padding-left: 20px !important;
        }

        .child-row-b2 { background: #fffbf5 !important; }
        .child-row-b2:hover { background: #ffedd5 !important; }
        .child-row-b2 td { border-right: 1px solid #fed7aa; color: #7c2d12; }

        /* Generic group/child fallback */
        .group-row {
            background: #f8fafc;
            font-weight: 600;
        }

        .group-name {
            font-weight: 700;
            color: #475569;
            padding-left: 20px;
        }

        .child-row { background: white; }

        /* Responsive */
        @media (max-width: 768px) {
            .container { padding: 12px 16px 24px; }
            .summary-cards { gap: 8px; }
            .summary-card { padding: 8px 10px; min-width: 120px; }
            .summary-card-value { font-size: 16px; }
            .controls { gap: 8px; }
            table { font-size: 11px; }
            th, td { padding: 8px 6px; }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>Drawdown Analysis Dashboard</h1>
            <p>Strategy-wise maximum and current drawdown metrics</p>
        </div>

        <div class="summary-cards">
            <div class="summary-card">
                <div class="summary-card-label">Portfolio Max DD</div>
                <div class="summary-card-value negative" id="portfolioMaxDD">-</div>
            </div>
            <div class="summary-card">
                <div class="summary-card-label">Worst Strategy</div>
                <div class="summary-card-value" id="worstStrategy">-</div>
            </div>
            <div class="summary-card">
                <div class="summary-card-label">Avg Drawdown</div>
                <div class="summary-card-value negative" id="avgDrawdown">-</div>
            </div>
            <div class="summary-card">
                <div class="summary-card-label">Avg Recovery</div>
                <div class="summary-card-value" id="avgRecovery">-</div>
            </div>
            <div class="summary-card">
                <div class="summary-card-label">Total DD Periods</div>
                <div class="summary-card-value" id="totalPeriods">-</div>
            </div>
        </div>

        <div class="controls">
            <div class="control-group">
                <label class="control-label">Hide Strategies:</label>
                <div class="strategy-selector">
                    <button class="strategy-dropdown-btn" onclick="toggleStrategyDropdown()">
                        <span>Select Strategies</span>
                        <span class="dropdown-badge" id="selectedCount">0</span>
                        <span>▼</span>
                    </button>
                    <div class="strategy-dropdown-menu" id="strategyDropdownMenu">
                        <div class="dropdown-header">
                            <button class="dropdown-action-btn" onclick="selectAllStrategies()">All</button>
                            <button class="dropdown-action-btn" onclick="selectNoneStrategies()">None</button>
                            <button class="dropdown-action-btn" onclick="resetStrategySelection()">Reset</button>
                        </div>
                        <div class="dropdown-options" id="strategyOptions"></div>
                    </div>
                </div>
            </div>
            <div class="control-group">
                <label class="control-label">Min DD % Filter:</label>
                <input type="number" id="minDrawdownFilter" placeholder="e.g., -10" step="0.1" oninput="applyFilters()">
            </div>
            <div class="control-group">
                <label class="control-label">View Type:</label>
                <select id="viewTypeFilter" onchange="applyFilters()">
                    <option value="all">All Levels</option>
                    <option value="broker">Broker Only</option>
                    <option value="account">Account Only</option>
                    <option value="strategy">Strategy Only</option>
                </select>
            </div>
            <div class="control-group">
                <label class="control-label">Sort By:</label>
                <select id="sortSelect" onchange="handleSortSelect()">
                    <option value="maxDDPercent">Max DD %</option>
                    <option value="currentDDPercent">Current DD %</option>
                    <option value="ddDuration">DD Duration</option>
                    <option value="recoveryTime">Recovery Time</option>
                    <option value="recoveryFactor">Recovery Factor</option>
                </select>
            </div>
            <button class="btn" onclick="expandAll()">Expand All</button>
            <button class="btn" onclick="collapseAll()">Collapse All</button>
            <button class="btn" onclick="resetFilters()">Reset Filters</button>
        </div>

        <div class="table-container">
            <table>
                <thead>
                    <tr>
                        <th onclick="sortTable('strategy')">Strategy</th>
                        <th onclick="sortTable('lotSize')">Lot Size</th>
                        <th onclick="sortTable('maxDD')">Max DD (₹)</th>
                        <th onclick="sortTable('maxDDPercent')">Max DD %</th>
                        <th onclick="sortTable('currentDD')">Current DD (₹)</th>
                        <th onclick="sortTable('currentDDPercent')">Current DD %</th>
                        <th onclick="sortTable('ddDuration')">DD Duration</th>
                        <th onclick="sortTable('recoveryTime')">Recovery Time</th>
                        <th onclick="sortTable('ddStartDate')">DD Start</th>
                        <th onclick="sortTable('ddEndDate')">DD End</th>
                        <th onclick="sortTable('ddCount')">DD Count</th>
                        <th onclick="sortTable('recoveryFactor')">Recovery Factor</th>
                        <th onclick="sortTable('underwaterPeriod')">Underwater</th>
                    </tr>
                </thead>
                <tbody id="drawdownTableBody"></tbody>
            </table>
        </div>
    </div>

    <script>
        let drawdownData = [];
        let filteredData = [];
        let hiddenStrategies = new Set();
        let allStrategyNames = [];
        let sortColumn = 'maxDDPercent';
        let sortDirection = 'desc';
        let globalStrategyMap = {};
        let globalAccountMap = {};
        let globalBrokerMap = {};

        // Sample data structure
        const sampleData = [
            {strategy: "B", isBroker: true, isGroup: false, isChild: false, lotSize: 14.90, maxDD: -584670, maxDDPercent: -7.34, currentDD: -48871, currentDDPercent: -0.50, ddDuration: 14, recoveryTime: 9, ddStartDate: "08-Sep", ddEndDate: "22-Sep", ddCount: 92, recoveryFactor: 8.83, underwaterPeriod: 809},
            {strategy: "B1", parentBroker: "B", isBroker: false, isGroup: true, isChild: false, lotSize: 10.40, maxDD: -584670, maxDDPercent: -7.34, currentDD: 0, currentDDPercent: 0.00, ddDuration: 14, recoveryTime: 8, ddStartDate: "08-Sep", ddEndDate: "22-Sep", ddCount: 67, recoveryFactor: 7.96, underwaterPeriod: 538},
            {strategy: "B1PRO 4", parentAccount: "B1", parentBroker: "B", isBroker: false, isGroup: false, isChild: true, lotSize: 6.20, maxDD: -584670, maxDDPercent: -7.34, currentDD: -267757, currentDDPercent: -3.18, ddDuration: 14, recoveryTime: 3, ddStartDate: "08-Sep", ddEndDate: "22-Sep", ddCount: 54, recoveryFactor: 5.97, underwaterPeriod: 192}
        ];

        // Listen for data from parent
        window.addEventListener('message', (event) => {
            const { type, data } = event.data;
            if (type === 'TRADES_DATA') {
                console.log('📊 Drawdown: Received trades data', data?.length || 0, 'trades');
                processTradesForDrawdown(data);
                populateStrategyOptions();
                loadSavedFilters();
                applyFilters();
            } else if (type === 'LOAD_SAMPLE_DATA') {
                console.log('🎲 Drawdown: Loading sample data');
                drawdownData = sampleData;
                populateStrategyOptions();
                loadSavedFilters();
                applyFilters();
            }
        });

        function processTradesForDrawdown(trades) {
            console.log('📊 Processing', trades.length, 'trades for drawdown analysis');
            
            const brokerMap = {};
            const accountMap = {};
            const strategyMap = {};
            
            const sortedTrades = [...trades].sort((a, b) => {
                const dateA = a.date.split('/').reverse().join('');
                const dateB = b.date.split('/').reverse().join('');
                return dateA.localeCompare(dateB);
            });
            
            sortedTrades.forEach(trade => {
                if (trade.strategyPnlTax) {
                    Object.entries(trade.strategyPnlTax).forEach(([stratName, pnlTax]) => {
                        if (stratName.startsWith('A.PRO')) return;
                        
                        const brokerMatch = stratName.match(/^([A-Z]\d+)/);
                        if (!brokerMatch) return;
                        
                        const accountCode = brokerMatch[1];
                        const brokerCode = accountCode.charAt(0);
                        
                        if (!strategyMap[stratName]) {
                            strategyMap[stratName] = {
                                name: stratName,
                                pnls: [],
                                dates: [],
                                broker: brokerCode,
                                account: accountCode,
                                startingCapital: 0,
                                lotSize: '-'
                            };
                        }
                        
                        if (trade.strategyDetails && trade.strategyDetails[stratName]) {
                            const details = trade.strategyDetails[stratName];
                            if (details.margin && details.margin > strategyMap[stratName].startingCapital) {
                                strategyMap[stratName].startingCapital = details.margin;
                            }
                            if (details.lot && details.lot > 0) {
                                strategyMap[stratName].lotSize = details.lot;
                            }
                        }
                        
                        strategyMap[stratName].pnls.push(pnlTax || 0);
                        strategyMap[stratName].dates.push(trade.date);
                        
                        if (!accountMap[accountCode]) {
                            accountMap[accountCode] = {
                                name: accountCode,
                                pnls: [],
                                dates: [],
                                broker: brokerCode,
                                startingCapital: 0
                            };
                        }
                        accountMap[accountCode].pnls.push(pnlTax || 0);
                        accountMap[accountCode].dates.push(trade.date);
                        
                        if (trade.strategyDetails && trade.strategyDetails[stratName]) {
                            const margin = trade.strategyDetails[stratName].margin || 0;
                            if (margin > accountMap[accountCode].startingCapital) {
                                accountMap[accountCode].startingCapital = margin;
                            }
                        }
                        
                        if (!brokerMap[brokerCode]) {
                            brokerMap[brokerCode] = {
                                name: brokerCode,
                                pnls: [],
                                dates: [],
                                startingCapital: 0
                            };
                        }
                        brokerMap[brokerCode].pnls.push(pnlTax || 0);
                        brokerMap[brokerCode].dates.push(trade.date);
                        
                        if (trade.strategyDetails && trade.strategyDetails[stratName]) {
                            const margin = trade.strategyDetails[stratName].margin || 0;
                            if (margin > brokerMap[brokerCode].startingCapital) {
                                brokerMap[brokerCode].startingCapital = margin;
                            }
                        }
                    });
                }
            });
            
            function calculateDrawdown(pnls, dates, startingCapital = 10000) {
                let cumPnl = 0;
                let equity = startingCapital;
                let peak = startingCapital;
                let maxDD = 0;
                let maxDDPercent = 0;
                let maxDDStartDate = '-';
                let maxDDEndDate = '-';
                let currentDD = 0;
                let currentDDPercent = 0;
                let ddCount = 0;
                let inDrawdown = false;
                let ddStartDate = null;
                let ddDays = 0;
                let maxDDDays = 0;
                let totalRecoveryDays = 0;
                let recoveryCount = 0;
                let totalUnderwaterDays = 0;
                let underwaterStartDate = null;
                
                pnls.forEach((pnl, index) => {
                    cumPnl += pnl;
                    equity = startingCapital + cumPnl;
                    
                    if (equity > peak) {
                        if (inDrawdown && ddStartDate) {
                            const recoveryDays = calculateDateDiff(ddStartDate, dates[index]);
                            totalRecoveryDays += recoveryDays;
                            recoveryCount++;
                        }
                        
                        if (underwaterStartDate) {
                            totalUnderwaterDays += calculateDateDiff(underwaterStartDate, dates[index]);
                            underwaterStartDate = null;
                        }
                        
                        peak = equity;
                        inDrawdown = false;
                        ddStartDate = null;
                        ddDays = 0;
                    } else if (equity < peak) {
                        if (!inDrawdown) {
                            ddCount++;
                            inDrawdown = true;
                            ddStartDate = dates[index];
                            underwaterStartDate = dates[index];
                        }
                        
                        if (ddStartDate) {
                            ddDays = calculateDateDiff(ddStartDate, dates[index]);
                        }
                        
                        const dd = equity - peak;
                        if (dd < maxDD) {
                            maxDD = dd;
                            maxDDPercent = peak > 0 ? (dd / peak) * 100 : 0;
                            maxDDStartDate = ddStartDate || dates[index];
                            maxDDEndDate = dates[index];
                            maxDDDays = ddDays;
                        }
                    }
                });
                
                if (underwaterStartDate && dates.length > 0) {
                    totalUnderwaterDays += calculateDateDiff(underwaterStartDate, dates[dates.length - 1]);
                }
                
                currentDD = equity - peak;
                currentDDPercent = peak > 0 ? (currentDD / peak) * 100 : 0;
                
                const avgRecoveryTime = recoveryCount > 0 ? Math.round(totalRecoveryDays / recoveryCount) : 0;
                
                return {
                    maxDD,
                    maxDDPercent,
                    currentDD,
                    currentDDPercent,
                    ddCount,
                    ddDuration: maxDDDays,
                    recoveryTime: avgRecoveryTime,
                    ddStartDate: formatDate(maxDDStartDate),
                    ddEndDate: formatDate(maxDDEndDate),
                    finalPnl: cumPnl,
                    finalEquity: equity,
                    peak,
                    underwaterPeriod: totalUnderwaterDays
                };
            }
            
            function calculateDateDiff(date1Str, date2Str) {
                if (!date1Str || !date2Str || date1Str === '-' || date2Str === '-') return 0;
                
                try {
                    const [d1, m1, y1] = date1Str.split('/').map(Number);
                    const [d2, m2, y2] = date2Str.split('/').map(Number);
                    
                    const date1 = new Date(y1, m1 - 1, d1);
                    const date2 = new Date(y2, m2 - 1, d2);
                    
                    const diffTime = Math.abs(date2 - date1);
                    const diffDays = Math.ceil(diffTime / (1000 * 60 * 60 * 24));
                    
                    return diffDays;
                } catch (e) {
                    return 0;
                }
            }
            
            function calculateTotalLotSize(strategies) {
                let totalLots = 0;
                let hasValidLots = false;
                
                strategies.forEach(strat => {
                    const lot = strat.lotSize;
                    if (lot && lot !== '-') {
                        const numLot = typeof lot === 'number' ? lot : parseFloat(lot);
                        if (!isNaN(numLot)) {
                            totalLots += numLot;
                            hasValidLots = true;
                        }
                    }
                });
                
                return hasValidLots ? totalLots : '-';
            }
            
            drawdownData = [];
            
            globalStrategyMap = strategyMap;
            globalAccountMap = accountMap;
            globalBrokerMap = brokerMap;
            
            Object.entries(brokerMap).forEach(([brokerCode, brokerData]) => {
                const metrics = calculateDrawdown(brokerData.pnls, brokerData.dates, brokerData.startingCapital);
                
                const brokerStrategies = Object.values(strategyMap).filter(s => s.broker === brokerCode);
                const totalLotSize = calculateTotalLotSize(brokerStrategies);
                
                drawdownData.push({
                    strategy: brokerCode,
                    isBroker: true,
                    isGroup: false,
                    isChild: false,
                    lotSize: totalLotSize,
                    maxDD: metrics.maxDD,
                    maxDDPercent: metrics.maxDDPercent,
                    currentDD: metrics.currentDD,
                    currentDDPercent: metrics.currentDDPercent,
                    ddDuration: metrics.ddDuration,
                    recoveryTime: metrics.recoveryTime,
                    ddStartDate: metrics.ddStartDate,
                    ddEndDate: metrics.ddEndDate,
                    ddCount: metrics.ddCount,
                    recoveryFactor: metrics.maxDD !== 0 ? Math.abs(metrics.finalPnl / metrics.maxDD) : 1.0,
                    underwaterPeriod: metrics.underwaterPeriod
                });
            });
            
            Object.entries(accountMap).forEach(([accountCode, accountData]) => {
                const metrics = calculateDrawdown(accountData.pnls, accountData.dates, accountData.startingCapital);
                
                const accountStrategies = Object.values(strategyMap).filter(s => s.account === accountCode);
                const totalLotSize = calculateTotalLotSize(accountStrategies);
                
                drawdownData.push({
                    strategy: accountCode,
                    parentBroker: accountData.broker,
                    isGroup: true,
                    isBroker: false,
                    isChild: false,
                    lotSize: totalLotSize,
                    maxDD: metrics.maxDD,
                    maxDDPercent: metrics.maxDDPercent,
                    currentDD: metrics.currentDD,
                    currentDDPercent: metrics.currentDDPercent,
                    ddDuration: metrics.ddDuration,
                    recoveryTime: metrics.recoveryTime,
                    ddStartDate: metrics.ddStartDate,
                    ddEndDate: metrics.ddEndDate,
                    ddCount: metrics.ddCount,
                    recoveryFactor: metrics.maxDD !== 0 ? Math.abs(metrics.finalPnl / metrics.maxDD) : 1.0,
                    underwaterPeriod: metrics.underwaterPeriod
                });
            });
            
            Object.entries(strategyMap).forEach(([stratName, stratData]) => {
                const metrics = calculateDrawdown(stratData.pnls, stratData.dates, stratData.startingCapital);
                
                drawdownData.push({
                    strategy: stratName,
                    parentAccount: stratData.account,
                    parentBroker: stratData.broker,
                    isChild: true,
                    isBroker: false,
                    isGroup: false,
                    lotSize: stratData.lotSize,
                    maxDD: metrics.maxDD,
                    maxDDPercent: metrics.maxDDPercent,
                    currentDD: metrics.currentDD,
                    currentDDPercent: metrics.currentDDPercent,
                    ddDuration: metrics.ddDuration,
                    recoveryTime: metrics.recoveryTime,
                    ddStartDate: metrics.ddStartDate,
                    ddEndDate: metrics.ddEndDate,
                    ddCount: metrics.ddCount,
                    recoveryFactor: metrics.maxDD !== 0 ? Math.abs(metrics.finalPnl / metrics.maxDD) : 1.0,
                    underwaterPeriod: metrics.underwaterPeriod
                });
            });
            
            console.log('✅ Created drawdown data:', {
                brokers: Object.keys(brokerMap).length,
                accounts: Object.keys(accountMap).length,
                strategies: Object.keys(strategyMap).length,
                total: drawdownData.length
            });
        }

        function applyFilters() {
            const minDD = parseFloat(document.getElementById('minDrawdownFilter').value) || -Infinity;
            const viewType = document.getElementById('viewTypeFilter').value;

            // First, filter strategies
            const filteredStrategies = drawdownData.filter(row => {
                if (!row.isChild) return false;
                const matchesStrategy = !hiddenStrategies.has(row.strategy);
                const matchesDD = row.maxDDPercent >= minDD;
                return matchesStrategy && matchesDD;
            });

            // Recalculate account metrics based on filtered strategies
            const accountMetrics = {};
            filteredStrategies.forEach(strat => {
                if (!accountMetrics[strat.parentAccount]) {
                    accountMetrics[strat.parentAccount] = {
                        strategies: [],
                        broker: strat.parentBroker
                    };
                }
                accountMetrics[strat.parentAccount].strategies.push(strat);
            });

            const recalculatedAccounts = Object.entries(accountMetrics).map(([accountCode, data]) => {
                const strategies = data.strategies;
                return {
                    strategy: accountCode,
                    parentBroker: data.broker,
                    isGroup: true,
                    isBroker: false,
                    isChild: false,
                    lotSize: strategies.reduce((sum, s) => sum + (typeof s.lotSize === 'number' ? s.lotSize : 0), 0),
                    maxDD: Math.min(...strategies.map(s => s.maxDD)),
                    maxDDPercent: Math.min(...strategies.map(s => s.maxDDPercent)),
                    currentDD: strategies.reduce((sum, s) => sum + s.currentDD, 0),
                    currentDDPercent: strategies.reduce((sum, s) => sum + s.currentDDPercent, 0) / strategies.length,
                    ddDuration: Math.max(...strategies.map(s => s.ddDuration)),
                    recoveryTime: Math.round(strategies.reduce((sum, s) => sum + s.recoveryTime, 0) / strategies.length),
                    ddStartDate: strategies[0].ddStartDate,
                    ddEndDate: strategies[0].ddEndDate,
                    ddCount: strategies.reduce((sum, s) => sum + s.ddCount, 0),
                    recoveryFactor: strategies.reduce((sum, s) => sum + s.recoveryFactor, 0) / strategies.length,
                    underwaterPeriod: Math.max(...strategies.map(s => s.underwaterPeriod))
                };
            });

            // Recalculate broker metrics based on filtered accounts
            const brokerMetrics = {};
            recalculatedAccounts.forEach(acc => {
                if (!brokerMetrics[acc.parentBroker]) {
                    brokerMetrics[acc.parentBroker] = {
                        accounts: []
                    };
                }
                brokerMetrics[acc.parentBroker].accounts.push(acc);
            });

            const recalculatedBrokers = Object.entries(brokerMetrics).map(([brokerCode, data]) => {
                const accounts = data.accounts;
                return {
                    strategy: brokerCode,
                    isBroker: true,
                    isGroup: false,
                    isChild: false,
                    lotSize: accounts.reduce((sum, a) => sum + (typeof a.lotSize === 'number' ? a.lotSize : 0), 0),
                    maxDD: Math.min(...accounts.map(a => a.maxDD)),
                    maxDDPercent: Math.min(...accounts.map(a => a.maxDDPercent)),
                    currentDD: accounts.reduce((sum, a) => sum + a.currentDD, 0),
                    currentDDPercent: accounts.reduce((sum, a) => sum + a.currentDDPercent, 0) / accounts.length,
                    ddDuration: Math.max(...accounts.map(a => a.ddDuration)),
                    recoveryTime: Math.round(accounts.reduce((sum, a) => sum + a.recoveryTime, 0) / accounts.length),
                    ddStartDate: accounts[0].ddStartDate,
                    ddEndDate: accounts[0].ddEndDate,
                    ddCount: accounts.reduce((sum, a) => sum + a.ddCount, 0),
                    recoveryFactor: accounts.reduce((sum, a) => sum + a.recoveryFactor, 0) / accounts.length,
                    underwaterPeriod: Math.max(...accounts.map(a => a.underwaterPeriod))
                };
            });

            // Combine all filtered data
            filteredData = [];
            
            if (viewType === 'all') {
                filteredData = [...recalculatedBrokers, ...recalculatedAccounts, ...filteredStrategies];
            } else if (viewType === 'broker') {
                filteredData = recalculatedBrokers;
            } else if (viewType === 'account') {
                filteredData = recalculatedAccounts;
            } else if (viewType === 'strategy') {
                filteredData = filteredStrategies;
            }

            // Sort
            if (viewType === 'all') {
                filteredData.sort((a, b) => {
                    if (a.isBroker !== b.isBroker) return a.isBroker ? -1 : 1;
                    if (a.isGroup !== b.isGroup) return a.isGroup ? -1 : 1;
                    const aVal = a[sortColumn];
                    const bVal = b[sortColumn];
                    return sortDirection === 'asc' ? (aVal > bVal ? 1 : -1) : (aVal < bVal ? 1 : -1);
                });
            } else {
                filteredData.sort((a, b) => {
                    const aVal = a[sortColumn];
                    const bVal = b[sortColumn];
                    return sortDirection === 'asc' ? (aVal > bVal ? 1 : -1) : (aVal < bVal ? 1 : -1);
                });
            }

            console.log('Filtered data:', filteredData.length, 'rows');
            renderTable();
            updateSummaryCards();
            saveFilters();
        }

        function renderTable() {
            const tbody = document.getElementById('drawdownTableBody');
            if (filteredData.length === 0) {
                tbody.innerHTML = '<tr><td colspan="13" style="text-align:center;padding:40px;">No data available</td></tr>';
                return;
            }

            // Group data hierarchically
            const brokers = filteredData.filter(d => d.isBroker);
            const accounts = filteredData.filter(d => d.isGroup);
            const strategies = filteredData.filter(d => d.isChild);
            
            let html = '';
            
            brokers.forEach(broker => {
                // Render broker row
                html += `<tr class="broker-row">
                    <td class="broker-name">🏦 ${broker.strategy}</td>
                    <td>${formatNum(broker.lotSize, 2)}</td>
                    <td class="negative">${formatCurrency(broker.maxDD)}</td>
                    <td class="negative">${formatPercent(broker.maxDDPercent)}</td>
                    <td class="${broker.currentDD < 0 ? 'negative' : 'neutral'}">${formatCurrency(broker.currentDD)}</td>
                    <td class="${broker.currentDDPercent < 0 ? 'negative' : 'neutral'}">${formatPercent(broker.currentDDPercent)}</td>
                    <td>${broker.ddDuration} days</td>
                    <td>${broker.recoveryTime > 0 ? broker.recoveryTime + ' days' : '-'}</td>
                    <td>${broker.ddStartDate}</td>
                    <td>${broker.ddEndDate}</td>
                    <td>${broker.ddCount}</td>
                    <td class="${broker.recoveryFactor >= 1 ? 'positive' : 'negative'}">${broker.recoveryFactor.toFixed(2)}</td>
                    <td>${broker.underwaterPeriod} days</td>
                </tr>`;
                
                // Find accounts under this broker
                const brokerAccounts = accounts.filter(a => a.parentBroker === broker.strategy);
                
                brokerAccounts.forEach(account => {
                    const accountCode = account.strategy.toLowerCase();
                    html += `<tr class="group-row group-${accountCode}">
                        <td class="group-name">├─ ${account.strategy}</td>
                        <td>${formatNum(account.lotSize, 2)}</td>
                        <td class="negative">${formatCurrency(account.maxDD)}</td>
                        <td class="negative">${formatPercent(account.maxDDPercent)}</td>
                        <td class="${account.currentDD < 0 ? 'negative' : 'neutral'}">${formatCurrency(account.currentDD)}</td>
                        <td class="${account.currentDDPercent < 0 ? 'negative' : 'neutral'}">${formatPercent(account.currentDDPercent)}</td>
                        <td>${account.ddDuration} days</td>
                        <td>${account.recoveryTime > 0 ? account.recoveryTime + ' days' : '-'}</td>
                        <td>${account.ddStartDate}</td>
                        <td>${account.ddEndDate}</td>
                        <td>${account.ddCount}</td>
                        <td class="${account.recoveryFactor >= 1 ? 'positive' : 'negative'}">${account.recoveryFactor.toFixed(2)}</td>
                        <td>${account.underwaterPeriod} days</td>
                    </tr>`;
                    
                    // Find strategies under this account
                    const accountStrategies = strategies.filter(s => s.parentAccount === account.strategy);
                    
                    accountStrategies.forEach(strategy => {
                        const parentAccountCode = strategy.parentAccount.toLowerCase();
                        html += `<tr class="child-row child-row-${parentAccountCode}">
                            <td style="padding-left: 40px;">${strategy.strategy}</td>
                            <td>${formatNum(strategy.lotSize, 2)}</td>
                            <td class="negative">${formatCurrency(strategy.maxDD)}</td>
                            <td class="negative">${formatPercent(strategy.maxDDPercent)}</td>
                            <td class="${strategy.currentDD < 0 ? 'negative' : 'neutral'}">${formatCurrency(strategy.currentDD)}</td>
                            <td class="${strategy.currentDDPercent < 0 ? 'negative' : 'neutral'}">${formatPercent(strategy.currentDDPercent)}</td>
                            <td>${strategy.ddDuration} days</td>
                            <td>${strategy.recoveryTime > 0 ? strategy.recoveryTime + ' days' : '-'}</td>
                            <td>${strategy.ddStartDate}</td>
                            <td>${strategy.ddEndDate}</td>
                            <td>${strategy.ddCount}</td>
                            <td class="${strategy.recoveryFactor >= 1 ? 'positive' : 'negative'}">${strategy.recoveryFactor.toFixed(2)}</td>
                            <td>${strategy.underwaterPeriod} days</td>
                        </tr>`;
                    });
                });
            });
            
            tbody.innerHTML = html;
        }

        function updateSummaryCards() {
            if (filteredData.length === 0) return;

            const broker = filteredData.find(d => d.isBroker);
            if (broker) {
                document.getElementById('portfolioMaxDD').textContent = formatPercent(broker.maxDDPercent);
            }

            const worst = filteredData.reduce((w, c) => c.maxDDPercent < w.maxDDPercent ? c : w);
            document.getElementById('worstStrategy').textContent = worst.strategy;

            const avgDD = filteredData.reduce((sum, d) => sum + d.maxDDPercent, 0) / filteredData.length;
            document.getElementById('avgDrawdown').textContent = formatPercent(avgDD);

            const recoveries = filteredData.filter(d => d.recoveryTime > 0);
            const avgRecovery = recoveries.length ? recoveries.reduce((sum, d) => sum + d.recoveryTime, 0) / recoveries.length : 0;
            document.getElementById('avgRecovery').textContent = avgRecovery > 0 ? Math.round(avgRecovery) + ' days' : '-';

            document.getElementById('totalPeriods').textContent = filteredData.reduce((sum, d) => sum + d.ddCount, 0);
        }

        function sortTable(column) {
            if (sortColumn === column) {
                sortDirection = sortDirection === 'asc' ? 'desc' : 'asc';
            } else {
                sortColumn = column;
                sortDirection = 'desc';
            }
            applyFilters();
        }

        function handleSortSelect() {
            sortColumn = document.getElementById('sortSelect').value;
            sortDirection = 'desc';
            applyFilters();
        }

        function resetFilters() {
            hiddenStrategies.clear();
            document.getElementById('minDrawdownFilter').value = '';
            document.getElementById('viewTypeFilter').value = 'all';
            document.getElementById('sortSelect').value = 'maxDDPercent';
            sortColumn = 'maxDDPercent';
            sortDirection = 'desc';
            updateStrategyCheckboxes();
            updateSelectedCount();
            clearSavedFilters();
            applyFilters();
        }

        function populateStrategyOptions() {
            allStrategyNames = drawdownData.filter(d => d.isChild).map(d => d.strategy).sort();
            const container = document.getElementById('strategyOptions');
            container.innerHTML = allStrategyNames.map(s => `
                <div class="dropdown-option">
                    <input type="checkbox" id="strategy-${CSS.escape(s)}" value="${s}" ${!hiddenStrategies.has(s) ? 'checked' : ''} onchange="toggleStrategy('${s.replace(/'/g, "\\'")}')">
                    <label for="strategy-${CSS.escape(s)}">${s}</label>
                </div>
            `).join('');
            updateSelectedCount();
        }

        function toggleStrategyDropdown() {
            document.getElementById('strategyDropdownMenu').classList.toggle('show');
        }

        function toggleStrategy(strategy) {
            hiddenStrategies.has(strategy) ? hiddenStrategies.delete(strategy) : hiddenStrategies.add(strategy);
            updateSelectedCount();
            applyFilters();
        }

        function selectAllStrategies() {
            hiddenStrategies.clear();
            updateStrategyCheckboxes();
            updateSelectedCount();
            applyFilters();
        }

        function selectNoneStrategies() {
            allStrategyNames.forEach(s => hiddenStrategies.add(s));
            updateStrategyCheckboxes();
            updateSelectedCount();
            applyFilters();
        }

        function resetStrategySelection() {
            hiddenStrategies.clear();
            updateStrategyCheckboxes();
            updateSelectedCount();
            applyFilters();
        }

        function updateStrategyCheckboxes() {
            allStrategyNames.forEach(s => {
                const cb = document.getElementById(`strategy-${CSS.escape(s)}`);
                if (cb) cb.checked = !hiddenStrategies.has(s);
            });
        }

        function updateSelectedCount() {
            document.getElementById('selectedCount').textContent = allStrategyNames.length - hiddenStrategies.size;
        }

        function expandAll() {
            document.querySelectorAll('tbody tr').forEach(row => row.style.display = '');
        }

        function collapseAll() {
            document.querySelectorAll('tbody tr').forEach(row => {
                if (row.classList.contains('child-row') || row.classList.contains('group-row')) {
                    row.style.display = 'none';
                }
            });
        }

        function loadSavedFilters() {
            try {
                const saved = localStorage.getItem('drawdownFilters');
                if (saved) {
                    const data = JSON.parse(saved);
                    hiddenStrategies = new Set(data.hiddenStrategies || []);
                    document.getElementById('minDrawdownFilter').value = data.minDD || '';
                    document.getElementById('viewTypeFilter').value = data.viewType || 'all';
                    document.getElementById('sortSelect').value = data.sortBy || 'maxDDPercent';
                    sortColumn = data.sortBy || 'maxDDPercent';
                }
            } catch (e) {}
        }

        function saveFilters() {
            try {
                localStorage.setItem('drawdownFilters', JSON.stringify({
                    hiddenStrategies: Array.from(hiddenStrategies),
                    minDD: document.getElementById('minDrawdownFilter').value,
                    viewType: document.getElementById('viewTypeFilter').value,
                    sortBy: sortColumn
                }));
            } catch (e) {}
        }

        function clearSavedFilters() {
            try {
                localStorage.removeItem('drawdownFilters');
            } catch (e) {}
        }

        function formatCurrency(val) {
            if (!val) return '-';
            const abs = Math.abs(val);
            const sign = val < 0 ? '-' : '';
            let str = Math.round(abs).toString();
            if (str.length > 3) {
                const last3 = str.slice(-3);
                const rest = str.slice(0, -3).replace(/\B(?=(\d{2})+(?!\d))/g, ',');
                str = rest + ',' + last3;
            }
            return sign + str;
        }

        function formatPercent(val) {
            return val ? val.toFixed(2) + '%' : '0.00%';
        }

        function formatNum(val, decimals = 2) {
            return val && val !== '-' ? val.toFixed(decimals) : '-';
        }

        function formatDate(dateStr) {
            if (!dateStr || dateStr === '-') return '-';
            try {
                const [d, m, y] = dateStr.split('/');
                const date = new Date(y, m - 1, d);
                const day = String(date.getDate()).padStart(2, '0');
                const month = date.toLocaleString('en-US', { month: 'short' });
                return `${day}-${month}`;
            } catch (e) {
                return dateStr;
            }
        }

        document.addEventListener('click', (e) => {
            const selector = document.querySelector('.strategy-selector');
            if (selector && !selector.contains(e.target)) {
                document.getElementById('strategyDropdownMenu').classList.remove('show');
            }
        });
    </script>
</body>
</html>
