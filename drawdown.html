<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Drawdown Analysis</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        html, body { width: 100%; height: 100%; overflow: hidden; }
        
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: #f8fafc;
            color: #1e293b;
        }

        .container {
            overflow-y: auto;
            padding: 16px 32px 32px;
            height: 100vh;
        }

        .header { margin-bottom: 16px; }
        .header h1 { font-size: 20px; font-weight: 700; color: #111827; margin-bottom: 4px; letter-spacing: -0.5px; }
        .header p { font-size: 12px; color: #6b7280; }

        /* Summary Cards */
        .summary-cards {
            display: flex;
            gap: 12px;
            margin-bottom: 16px;
            overflow-x: auto;
        }

        .summary-card {
            background: white;
            border-radius: 8px;
            padding: 10px 12px;
            box-shadow: 0 1px 3px rgba(0,0,0,0.08);
            border: 1px solid #e5e7eb;
            flex: 1 1 0;
            min-width: 140px;
        }

        .summary-card-label {
            font-size: 10px;
            color: #6b7280;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            margin-bottom: 5px;
            font-weight: 700;
        }

        .summary-card-value {
            font-size: 18px;
            font-weight: 700;
            line-height: 1.2;
        }

        /* Summary card colors matching strategy-performance.html */
        .summary-card-value.positive { color: #059669; }
        .summary-card-value.negative { color: #b96060; }
        
        .summary-card.broker-margin-box {
            background: #f0fdf4;
        }
        
        .summary-card.stg-margin-box {
            background: #fffbeb;
        }
        
        .summary-card.drawdown-box {
            background: #fdf2f8;
        }

        /* Controls */
        .controls {
            display: flex;
            gap: 12px;
            margin-bottom: 16px;
            flex-wrap: wrap;
            align-items: center;
        }

        .control-group {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .control-label {
            font-size: 12px;
            color: #374151;
            font-weight: 600;
        }

        select, input[type="number"], .btn {
            padding: 7px 12px;
            border: 1px solid #d1d5db;
            border-radius: 8px;
            font-size: 12px;
            font-weight: 500;
            background: white;
            color: #374151;
            cursor: pointer;
            transition: all 0.15s;
            font-family: inherit;
        }

        select:hover, input:hover, .btn:hover { 
            border-color: #9ca3af; 
            background: #f9fafb; 
        }

        select:focus, input:focus {
            outline: none;
            border-color: #3b82f6;
            box-shadow: 0 0 0 3px rgba(59,130,246,0.1);
        }

        /* Strategy Dropdown */
        .strategy-selector { position: relative; }
        
        .strategy-dropdown-btn {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 7px 12px;
            border: 1px solid #d1d5db;
            border-radius: 8px;
            background: white;
            cursor: pointer;
            font-size: 12px;
        }

        .strategy-dropdown-btn:hover { border-color: #9ca3af; background: #f9fafb; }

        .dropdown-badge {
            background: #3b82f6;
            color: white;
            padding: 2px 6px;
            border-radius: 10px;
            font-size: 10px;
            font-weight: 600;
        }

        .strategy-dropdown-menu {
            display: none;
            position: absolute;
            top: 100%;
            left: 0;
            margin-top: 6px;
            background: white;
            border: 1px solid #d1d5db;
            border-radius: 10px;
            box-shadow: 0 10px 15px rgba(0,0,0,0.1);
            min-width: 280px;
            max-height: 400px;
            overflow-y: auto;
            z-index: 1000;
        }

        .strategy-dropdown-menu.show { display: block; }

        .dropdown-header {
            padding: 12px 14px;
            border-bottom: 1px solid #e2e8f0;
            display: flex;
            justify-content: space-between;
        }

        .dropdown-action-btn {
            font-size: 11px;
            color: #1e40af;
            cursor: pointer;
            padding: 4px 8px;
            border-radius: 4px;
            background: none;
            border: none;
        }

        .dropdown-action-btn:hover { background: #eff6ff; }

        .dropdown-options { padding: 8px 0; }

        .dropdown-option {
            display: flex;
            align-items: center;
            padding: 8px 14px;
            cursor: pointer;
        }

        .dropdown-option:hover { background: #f8fafc; }
        .dropdown-option input { margin-right: 10px; cursor: pointer; }
        .dropdown-option label { font-size: 13px; color: #475569; cursor: pointer; flex: 1; }

        /* Table */
        .table-container {
            background: white;
            border-radius: 12px;
            box-shadow: 0 1px 3px rgba(0,0,0,0.08);
            border: 1px solid #e5e7eb;
        }

        table {
            width: 100%;
            border-collapse: separate;
            border-spacing: 0;
            font-size: 13px;
        }

        thead {
            background: #f3f4f6;
            position: sticky;
            top: 0;
            z-index: 10;
        }

        th {
            padding: 12px;
            text-align: left;
            font-size: 11px;
            font-weight: 700;
            color: #1f2937;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            border-bottom: 2px solid #d1d5db;
            border-right: 1px solid #e5e7eb;
            cursor: pointer;
            white-space: nowrap;
        }

        /* Right-align numeric column headers */
        th:nth-child(n+2) {
            text-align: right;
        }

        th:last-child { border-right: none; }

        /* Set minimum width for Strategy column */
        th:nth-child(1), td:nth-child(1) { /* Strategy */
            min-width: 150px;
        }

        /* Set common width for specific columns */
        th:nth-child(3), td:nth-child(3),  /* STG Margin */
        th:nth-child(4), td:nth-child(4),  /* Broker Margin */
        th:nth-child(5), td:nth-child(5),  /* Extra Margin */
        th:nth-child(13), td:nth-child(13) { /* Recovery Time */
            width: 120px;
            min-width: 120px;
            max-width: 120px;
        }
        
        /* Narrower columns for DD-related fields */
        th:nth-child(6), td:nth-child(6),  /* Current DD (₹) */
        th:nth-child(7), td:nth-child(7),  /* Current DD % */
        th:nth-child(9), td:nth-child(9),  /* stg dd(%) */
        th:nth-child(10), td:nth-child(10), /* DD Duration */
        th:nth-child(11), td:nth-child(11), /* STG DD Start */
        th:nth-child(12), td:nth-child(12) { /* STG DD End */
            width: 95px;
            min-width: 95px;
            max-width: 95px;
        }
        
        /* Special width for stg dd(₹) */
        th:nth-child(8), td:nth-child(8) { /* stg dd(₹) */
            width: 110px;
            min-width: 110px;
            max-width: 110px;
        }

        td {
            padding: 12px;
            border-right: 1px solid #f3f4f6;
            color: #374151;
        }

        /* Right-align numeric cells */
        td:nth-child(n+2) {
            text-align: right;
        }

        td:last-child { border-right: none; }

        tbody tr {
            background: white;
            border-bottom: 1px solid #f3f4f6;
            transition: opacity 0.15s;
        }

        tbody tr:hover { opacity: 0.9; }

        /* Value Colors - matching strategy-performance.html */
        .negative { color: #b96060; }
        .positive { color: #059669; }
        .neutral { color: #6b7280; }

        /* View type visibility control - only hides rows, calculations remain unchanged */
        body[data-view="broker"] .group-row,
        body[data-view="broker"] .child-row {
            display: none;
        }

        body[data-view="account"] .broker-row,
        body[data-view="account"] .child-row {
            display: none;
        }

        body[data-view="strategy"] .broker-row,
        body[data-view="strategy"] .group-row {
            display: none;
        }

        /* Broker Row - Same as Header */
        .broker-row {
            background: #f3f4f6 !important;
            font-weight: 600;
        }

        .broker-row:hover { background: #e5e7eb !important; }

        .broker-row td {
            border-right: 1px solid #d1d5db;
            color: #000000;
            font-size: 13px;
        }

        .broker-name {
            font-size: 13px !important;
            font-weight: 600 !important;
            color: #000000 !important;
        }

        /* Broker 1 (B1) - Pink */
        .group-b1 {
            background: #fce7f3 !important;
            font-weight: 600;
        }

        .group-b1:hover { background: #fbcfe8 !important; }

        .group-b1 td {
            border-right: 1px solid #f9a8d4;
            color: #831843;
            font-size: 13px;
        }

        .group-b1 .group-name {
            font-size: 13px !important;
            font-weight: 600 !important;
            color: #9f1239 !important;
            padding-left: 20px !important;
        }

        .child-row-b1 { background: #fef2f2 !important; }
        .child-row-b1:hover { background: #fce7f3 !important; }
        .child-row-b1 td { border-right: 1px solid #fecdd3; color: #7f1d1d; }

        /* Broker 2 (B2) - Light Orange */
        .group-b2 {
            background: #ffedd5 !important;
            font-weight: 600;
        }

        .group-b2:hover { background: #fed7aa !important; }

        .group-b2 td {
            border-right: 1px solid #fdba74;
            color: #7c2d12;
            font-size: 13px;
        }

        .group-b2 .group-name {
            font-size: 13px !important;
            font-weight: 600 !important;
            color: #9a3412 !important;
            padding-left: 20px !important;
        }

        .child-row-b2 { background: #fffbf5 !important; }
        .child-row-b2:hover { background: #ffedd5 !important; }
        .child-row-b2 td { border-right: 1px solid #fed7aa; color: #7c2d12; }

        /* Generic group/child fallback */
        .group-row {
            background: #f8fafc;
            font-weight: 600;
        }

        .group-row td {
            font-size: 13px;
        }

        .group-name {
            font-weight: 600;
            font-size: 13px;
            color: #475569;
            padding-left: 20px;
        }

        .child-row { 
            background: white; 
        }

        .child-row td {
            font-size: 13px;
        }

        /* Tablet Layout - Dynamic columns based on card count */
        @media screen and (min-width: 769px) and (max-width: 1024px) {
            .summary-cards {
                display: grid;
                grid-template-columns: repeat(3, 1fr);
                gap: 12px;
                flex-wrap: wrap;
                overflow-x: visible;
            }
            
            .summary-card {
                min-width: auto;
                flex: none;
            }
        }

        /* Responsive */
        @media (max-width: 768px) {
            .container { padding: 12px 16px 24px; }
            
            .summary-cards {
                display: grid;
                grid-template-columns: repeat(2, 1fr);
                gap: 10px;
                flex-wrap: wrap;
                overflow-x: visible;
            }
            
            .summary-card {
                min-width: auto;
                flex: none;
                padding: 14px 16px;
            }
            
            .summary-card-label {
                font-size: 11px;
            }
            
            .summary-card-value {
                font-size: 20px;
            }
            
            .controls { gap: 8px; }
            table { font-size: 11px; }
            th, td { padding: 8px 6px; }
        }
    </style>
</head>
<body data-view="all">
    <div class="container">
        <div class="header">
            <h1>Drawdown Analysis</h1>
            <p>Strategy-wise maximum and current drawdown metrics</p>
        </div>

        <div class="summary-cards">
            <div class="summary-card broker-margin-box">
                <div class="summary-card-label">Total Broker Margin</div>
                <div class="summary-card-value" id="totalBrokerMargin">-</div>
            </div>
            <div class="summary-card stg-margin-box">
                <div class="summary-card-label">Total Stg Margin</div>
                <div class="summary-card-value" id="totalStgMargin">-</div>
            </div>
            <div class="summary-card drawdown-box">
                <div class="summary-card-label">Total Current DD (₹)</div>
                <div class="summary-card-value negative" id="totalCurrentDDRupees">-</div>
            </div>
            <div class="summary-card drawdown-box">
                <div class="summary-card-label">STG DD (₹)</div>
                <div class="summary-card-value negative" id="stgDDFromB">-</div>
            </div>
            <div class="summary-card">
                <div class="summary-card-label">Total Current DD (%)</div>
                <div class="summary-card-value negative" id="totalCurrentDDPercent">-</div>
            </div>
            <div class="summary-card">
                <div class="summary-card-label">Avg Drawdown</div>
                <div class="summary-card-value negative" id="avgDrawdown">-</div>
            </div>
            <div class="summary-card">
                <div class="summary-card-label">DD Duration from B</div>
                <div class="summary-card-value" id="ddDurationFromB">-</div>
            </div>
        </div>

        <div class="controls">
            <div class="control-group">
                <label class="control-label">Hide Strategies:</label>
                <div class="strategy-selector">
                    <button class="strategy-dropdown-btn" onclick="toggleStrategyDropdown()">
                        <span>Select Strategies</span>
                        <span class="dropdown-badge" id="selectedCount">0</span>
                        <span>▼</span>
                    </button>
                    <div class="strategy-dropdown-menu" id="strategyDropdownMenu">
                        <div class="dropdown-header">
                            <button class="dropdown-action-btn" onclick="selectAllStrategies()">All</button>
                            <button class="dropdown-action-btn" onclick="selectNoneStrategies()">None</button>
                            <button class="dropdown-action-btn" onclick="resetStrategySelection()">Reset</button>
                        </div>
                        <div class="dropdown-options" id="strategyOptions"></div>
                    </div>
                </div>
            </div>
            <div class="control-group">
                <label class="control-label">Min DD % Filter:</label>
                <input type="number" id="minDrawdownFilter" placeholder="e.g., -10" step="0.1" oninput="applyFilters()">
            </div>
            <div class="control-group">
                <label class="control-label">View Type:</label>
                <select id="viewTypeFilter" onchange="applyFilters()">
                    <option value="all">All Levels</option>
                    <option value="broker">Broker Only</option>
                    <option value="account">Account Only</option>
                    <option value="strategy">Strategy Only</option>
                </select>
            </div>
            <div class="control-group">
                <label class="control-label">Sort By:</label>
                <select id="sortSelect" onchange="handleSortSelect()">
                    <option value="strategy" selected>Strategy</option>
                    <option value="maxDDPercent">Max DD %</option>
                    <option value="currentDDPercent">Current DD %</option>
                    <option value="currentDDDuration">DD Duration</option>
                    <option value="extraMargin">Extra Margin</option>
                    <option value="recoveryTime">Recovery Time</option>
                </select>
            </div>
            <button class="btn" onclick="expandAll()">Expand All</button>
            <button class="btn" onclick="collapseAll()">Collapse All</button>
            <button class="btn" onclick="resetFilters()">Reset Filters</button>
        </div>

        <div class="table-container">
            <table>
                <thead>
                    <tr>
                        <th onclick="sortTable('strategy')">Strategy</th>
                        <th onclick="sortTable('lotSize')">Lot Size</th>
                        <th onclick="sortTable('stgMargin')">STG Margin</th>
                        <th onclick="sortTable('brokerMargin')">Broker Margin</th>
                        <th onclick="sortTable('extraMargin')">Extra Margin</th>
                        <th onclick="sortTable('currentDD')">Current DD (₹)</th>
                        <th onclick="sortTable('currentDDPercent')">Current DD %</th>
                        <th onclick="sortTable('stgDD')">stg dd(₹)</th>
                        <th onclick="sortTable('stgDDPercent')">stg dd(%)</th>
                        <th onclick="sortTable('currentDDDuration')">DD Duration</th>
                        <th onclick="sortTable('ddStartDate')">STG DD Start</th>
                        <th onclick="sortTable('ddEndDate')">STG DD End</th>
                        <th onclick="sortTable('maxDD')">Max DD (₹)</th>
                        <th onclick="sortTable('maxDDPercent')">Max DD %</th>
                        <th onclick="sortTable('recoveryTime')">Recovery Time</th>
                        <th onclick="sortTable('ddCount')">DD Count</th>
                    </tr>
                </thead>
                <tbody id="drawdownTableBody"></tbody>
            </table>
        </div>
    </div>

    <script>
        let drawdownData = [];
        let filteredData = [];
        let hiddenStrategies = new Set();
        let allStrategyNames = [];
        let sortColumn = 'strategy';
        let sortDirection = 'asc';
        let globalStrategyMap = {};
        let globalAccountMap = {};
        let globalBrokerMap = {};

        // Sample data structure
        const sampleData = [
            {strategy: "B", isBroker: true, isGroup: false, isChild: false, lotSize: 14.90, maxDD: -584670, maxDDPercent: -7.34, currentDD: -48871, currentDDPercent: -0.50, ddDuration: 14, recoveryTime: 9, ddStartDate: "08-Sep", ddEndDate: "22-Sep", ddCount: 92, recoveryFactor: 8.83, underwaterPeriod: 809},
            {strategy: "B1", parentBroker: "B", isBroker: false, isGroup: true, isChild: false, lotSize: 10.40, maxDD: -584670, maxDDPercent: -7.34, currentDD: 0, currentDDPercent: 0.00, ddDuration: 14, recoveryTime: 8, ddStartDate: "08-Sep", ddEndDate: "22-Sep", ddCount: 67, recoveryFactor: 7.96, underwaterPeriod: 538},
            {strategy: "B1PRO 4", parentAccount: "B1", parentBroker: "B", isBroker: false, isGroup: false, isChild: true, lotSize: 6.20, maxDD: -584670, maxDDPercent: -7.34, currentDD: -267757, currentDDPercent: -3.18, ddDuration: 14, recoveryTime: 3, ddStartDate: "08-Sep", ddEndDate: "22-Sep", ddCount: 54, recoveryFactor: 5.97, underwaterPeriod: 192}
        ];

        // Listen for data from parent
        window.addEventListener('message', (event) => {
            const { type, data } = event.data;
            if (type === 'TRADES_DATA') {
                console.log('📊 Drawdown: Received trades data');
                
                // Store full trades data for broker margin calculation
                tradesData = event.data.data || data;
                
                // Calculate broker margins BEFORE processing drawdown
                calculateBrokerMarginFromTrades();
                
                // Now process the trades for drawdown display
                const tradesArray = Array.isArray(data) ? data : (data?.trades || []);
                console.log('📊 Processing', tradesArray.length, 'trades for drawdown analysis');
                processTradesForDrawdown(tradesArray);
                loadSavedFilters();
                populateStrategyOptions();
                applyFilters();
            } else if (type === 'LOAD_SAMPLE_DATA') {
                console.log('🎲 Drawdown: Loading sample data');
                drawdownData = sampleData;
                loadSavedFilters();
                populateStrategyOptions();
                applyFilters();
            }
        });

        function processTradesForDrawdown(trades) {
            console.log('📊 Processing', trades.length, 'trades for drawdown analysis');
            
            const brokerMap = {};
            const accountMap = {};
            const strategyMap = {};
            
            const sortedTrades = [...trades].sort((a, b) => {
                const dateA = a.date.split('/').reverse().join('');
                const dateB = b.date.split('/').reverse().join('');
                return dateA.localeCompare(dateB);
            });
            
            sortedTrades.forEach(trade => {
                if (trade.strategyPnlTax) {
                    Object.entries(trade.strategyPnlTax).forEach(([stratName, pnlTax]) => {
                        if (stratName.startsWith('A.PRO')) return;
                        
                        const brokerMatch = stratName.match(/^([A-Z]\d+)/);
                        if (!brokerMatch) return;
                        
                        const accountCode = brokerMatch[1];
                        const brokerCode = accountCode.charAt(0);
                        
                        if (!strategyMap[stratName]) {
                            strategyMap[stratName] = {
                                name: stratName,
                                pnls: [],
                                dates: [],
                                broker: brokerCode,
                                account: accountCode,
                                startingCapital: 0,
                                lotSize: '-'
                            };
                        }
                        
                        if (trade.strategyDetails && trade.strategyDetails[stratName]) {
                            const details = trade.strategyDetails[stratName];
                            if (details.margin && details.margin > strategyMap[stratName].startingCapital) {
                                strategyMap[stratName].startingCapital = details.margin;
                            }
                            if (details.lot && details.lot > 0) {
                                strategyMap[stratName].lotSize = details.lot;
                            }
                        }
                        
                        strategyMap[stratName].pnls.push(pnlTax || 0);
                        strategyMap[stratName].dates.push(trade.date);
                        
                        if (!accountMap[accountCode]) {
                            accountMap[accountCode] = {
                                name: accountCode,
                                pnls: [],
                                dates: [],
                                broker: brokerCode,
                                startingCapital: 0
                            };
                        }
                        accountMap[accountCode].pnls.push(pnlTax || 0);
                        accountMap[accountCode].dates.push(trade.date);
                        
                        if (trade.strategyDetails && trade.strategyDetails[stratName]) {
                            const margin = trade.strategyDetails[stratName].margin || 0;
                            if (margin > accountMap[accountCode].startingCapital) {
                                accountMap[accountCode].startingCapital = margin;
                            }
                        }
                        
                        if (!brokerMap[brokerCode]) {
                            brokerMap[brokerCode] = {
                                name: brokerCode,
                                pnls: [],
                                dates: [],
                                startingCapital: 0
                            };
                        }
                        brokerMap[brokerCode].pnls.push(pnlTax || 0);
                        brokerMap[brokerCode].dates.push(trade.date);
                        
                        if (trade.strategyDetails && trade.strategyDetails[stratName]) {
                            const margin = trade.strategyDetails[stratName].margin || 0;
                            if (margin > brokerMap[brokerCode].startingCapital) {
                                brokerMap[brokerCode].startingCapital = margin;
                            }
                        }
                    });
                }
            });
            
            function calculateDrawdown(pnls, dates, startingCapital = 10000) {
                let cumPnl = 0;
                let equity = startingCapital;
                let peak = startingCapital;
                let maxDD = 0;
                let maxDDPercent = 0;
                let maxDDStartDate = '-';
                let maxDDEndDate = '-';
                let currentDD = 0;
                let currentDDPercent = 0;
                let currentDDDuration = 0;
                let currentDDStartDate = null;
                let ddCount = 0;
                let inDrawdown = false;
                let ddStartDate = null;
                let ddDays = 0;
                let maxDDDays = 0;
                let totalRecoveryDays = 0;
                let recoveryCount = 0;
                let totalUnderwaterDays = 0;
                let underwaterStartDate = null;
                
                pnls.forEach((pnl, index) => {
                    cumPnl += pnl;
                    equity = startingCapital + cumPnl;
                    
                    if (equity > peak) {
                        if (inDrawdown && ddStartDate) {
                            const recoveryDays = calculateDateDiff(ddStartDate, dates[index]);
                            totalRecoveryDays += recoveryDays;
                            recoveryCount++;
                        }
                        
                        if (underwaterStartDate) {
                            totalUnderwaterDays += calculateDateDiff(underwaterStartDate, dates[index]);
                            underwaterStartDate = null;
                        }
                        
                        peak = equity;
                        inDrawdown = false;
                        ddStartDate = null;
                        ddDays = 0;
                        currentDDStartDate = null; // Reset current DD tracking
                    } else if (equity < peak) {
                        if (!inDrawdown) {
                            ddCount++;
                            inDrawdown = true;
                            ddStartDate = dates[index];
                            underwaterStartDate = dates[index];
                            if (!currentDDStartDate) {
                                currentDDStartDate = dates[index]; // Track current DD start
                            }
                        }
                        
                        if (ddStartDate) {
                            ddDays = calculateDateDiff(ddStartDate, dates[index]);
                        }
                        
                        const dd = equity - peak;
                        if (dd < maxDD) {
                            maxDD = dd;
                            maxDDPercent = peak > 0 ? (dd / peak) * 100 : 0;
                            maxDDStartDate = ddStartDate || dates[index];
                            maxDDEndDate = dates[index];
                            maxDDDays = ddDays;
                        }
                    }
                });
                
                if (underwaterStartDate && dates.length > 0) {
                    totalUnderwaterDays += calculateDateDiff(underwaterStartDate, dates[dates.length - 1]);
                }
                
                currentDD = equity - peak;
                currentDDPercent = peak > 0 ? (currentDD / peak) * 100 : 0;
                
                // Calculate current DD duration and end date (if currently in drawdown)
                let currentDDEndDate = '-';
                if (currentDD < 0 && currentDDStartDate && dates.length > 0) {
                    currentDDDuration = calculateDateDiff(currentDDStartDate, dates[dates.length - 1]);
                    currentDDEndDate = dates[dates.length - 1]; // Latest date is the current DD end
                } else {
                    currentDDDuration = 0;
                    currentDDStartDate = null;
                }
                
                const avgRecoveryTime = recoveryCount > 0 ? Math.round(totalRecoveryDays / recoveryCount) : 0;
                
                return {
                    maxDD,
                    maxDDPercent,
                    currentDD,
                    currentDDPercent,
                    currentDDDuration,
                    ddCount,
                    ddDuration: maxDDDays,
                    recoveryTime: avgRecoveryTime,
                    ddStartDate: formatDate(currentDDStartDate || '-'),
                    ddEndDate: formatDate(currentDDEndDate),
                    finalPnl: cumPnl,
                    finalEquity: equity,
                    peak,
                    underwaterPeriod: totalUnderwaterDays
                };
            }
            
            function calculateDateDiff(date1Str, date2Str) {
                if (!date1Str || !date2Str || date1Str === '-' || date2Str === '-') return 0;
                
                try {
                    const [d1, m1, y1] = date1Str.split('/').map(Number);
                    const [d2, m2, y2] = date2Str.split('/').map(Number);
                    
                    const date1 = new Date(y1, m1 - 1, d1);
                    const date2 = new Date(y2, m2 - 1, d2);
                    
                    const diffTime = Math.abs(date2 - date1);
                    const diffDays = Math.ceil(diffTime / (1000 * 60 * 60 * 24));
                    
                    return diffDays;
                } catch (e) {
                    return 0;
                }
            }
            
            function calculateTotalLotSize(strategies) {
                let totalLots = 0;
                let hasValidLots = false;
                
                strategies.forEach(strat => {
                    const lot = strat.lotSize;
                    if (lot && lot !== '-') {
                        const numLot = typeof lot === 'number' ? lot : parseFloat(lot);
                        if (!isNaN(numLot)) {
                            totalLots += numLot;
                            hasValidLots = true;
                        }
                    }
                });
                
                return hasValidLots ? totalLots : '-';
            }
            
            drawdownData = [];
            
            globalStrategyMap = strategyMap;
            globalAccountMap = accountMap;
            globalBrokerMap = brokerMap;
            
            Object.entries(brokerMap).forEach(([brokerCode, brokerData]) => {
                const metrics = calculateDrawdown(brokerData.pnls, brokerData.dates, brokerData.startingCapital);
                
                const brokerStrategies = Object.values(strategyMap).filter(s => s.broker === brokerCode);
                const totalLotSize = calculateTotalLotSize(brokerStrategies);
                
                drawdownData.push({
                    strategy: brokerCode,
                    isBroker: true,
                    isGroup: false,
                    isChild: false,
                    lotSize: totalLotSize,
                    maxDD: metrics.maxDD,
                    maxDDPercent: metrics.maxDDPercent,
                    currentDD: metrics.currentDD,
                    currentDDPercent: metrics.currentDDPercent,
                    currentDDDuration: metrics.currentDDDuration,
                    ddDuration: metrics.ddDuration,
                    recoveryTime: metrics.recoveryTime,
                    ddStartDate: metrics.ddStartDate,
                    ddEndDate: metrics.ddEndDate,
                    ddCount: metrics.ddCount,
                    recoveryFactor: metrics.maxDD !== 0 ? Math.abs(metrics.finalPnl / metrics.maxDD) : 1.0,
                    underwaterPeriod: metrics.underwaterPeriod
                });
            });
            
            Object.entries(strategyMap).forEach(([stratName, stratData]) => {
                const metrics = calculateDrawdown(stratData.pnls, stratData.dates, stratData.startingCapital);
                
                drawdownData.push({
                    strategy: stratName,
                    parentAccount: stratData.account,
                    parentBroker: stratData.broker,
                    isChild: true,
                    isBroker: false,
                    isGroup: false,
                    lotSize: stratData.lotSize,
                    maxDD: metrics.maxDD,
                    maxDDPercent: metrics.maxDDPercent,
                    currentDD: metrics.currentDD,
                    currentDDPercent: metrics.currentDDPercent,
                    currentDDDuration: metrics.currentDDDuration,
                    ddDuration: metrics.ddDuration,
                    recoveryTime: metrics.recoveryTime,
                    ddStartDate: metrics.ddStartDate,
                    ddEndDate: metrics.ddEndDate,
                    ddCount: metrics.ddCount,
                    recoveryFactor: metrics.maxDD !== 0 ? Math.abs(metrics.finalPnl / metrics.maxDD) : 1.0,
                    underwaterPeriod: metrics.underwaterPeriod
                });
            });
            
            // Process accounts with aggregated PnL data
            Object.entries(accountMap).forEach(([accountCode, accountData]) => {
                const metrics = calculateDrawdown(accountData.pnls, accountData.dates, accountData.startingCapital);
                
                const accountStrategies = Object.values(strategyMap).filter(s => s.account === accountCode);
                const totalLotSize = calculateTotalLotSize(accountStrategies);
                
                drawdownData.push({
                    strategy: accountCode,
                    parentBroker: accountData.broker,
                    isGroup: true,
                    isBroker: false,
                    isChild: false,
                    lotSize: totalLotSize,
                    maxDD: metrics.maxDD,
                    maxDDPercent: metrics.maxDDPercent,
                    currentDD: metrics.currentDD,
                    currentDDPercent: metrics.currentDDPercent,
                    currentDDDuration: metrics.currentDDDuration,
                    ddDuration: metrics.ddDuration,
                    recoveryTime: metrics.recoveryTime,
                    ddStartDate: metrics.ddStartDate,
                    ddEndDate: metrics.ddEndDate,
                    ddCount: metrics.ddCount,
                    recoveryFactor: metrics.maxDD !== 0 ? Math.abs(metrics.finalPnl / metrics.maxDD) : 1.0,
                    underwaterPeriod: metrics.underwaterPeriod
                });
            });
            
            // Recalculate Current DD % based on STG Margin instead of peak
            drawdownData.forEach(row => {
                const stgMargin = (row.lotSize && row.lotSize !== '-') ? row.lotSize * 400000 : 0;
                if (stgMargin > 0) {
                    row.currentDDPercent = (row.currentDD / stgMargin) * 100;
                } else {
                    row.currentDDPercent = 0;
                }
            });
            
            console.log('✅ Created drawdown data:', {
                brokers: Object.keys(brokerMap).length,
                accounts: Object.keys(accountMap).length,
                strategies: Object.keys(strategyMap).length,
                total: drawdownData.length
            });
        }

        function applyFilters() {
            const minDD = parseFloat(document.getElementById('minDrawdownFilter').value) || -Infinity;
            const viewType = document.getElementById('viewTypeFilter').value;

            // First, filter strategies
            const filteredStrategies = drawdownData.filter(row => {
                if (!row.isChild) return false;
                const matchesStrategy = !hiddenStrategies.has(row.strategy);
                const matchesDD = row.maxDDPercent >= minDD;
                return matchesStrategy && matchesDD;
            });

            // Get pre-calculated accounts from drawdownData that match filtered strategies
            const accountMetrics = {};
            filteredStrategies.forEach(strat => {
                if (!accountMetrics[strat.parentAccount]) {
                    accountMetrics[strat.parentAccount] = {
                        strategies: [],
                        broker: strat.parentBroker
                    };
                }
                accountMetrics[strat.parentAccount].strategies.push(strat);
            });

            const recalculatedAccounts = Object.entries(accountMetrics).map(([accountCode, data]) => {
                // Get the pre-calculated account data from drawdownData
                const accountData = drawdownData.find(d => d.isGroup && d.strategy === accountCode);
                
                if (accountData) {
                    // Use the pre-calculated metrics, but recalculate aggregated values for displayed strategies
                    const strategies = data.strategies;
                    return {
                        strategy: accountCode,
                        parentBroker: data.broker,
                        isGroup: true,
                        isBroker: false,
                        isChild: false,
                        lotSize: strategies.reduce((sum, s) => sum + (typeof s.lotSize === 'number' ? s.lotSize : 0), 0),
                        maxDD: accountData.maxDD,  // Use pre-calculated
                        maxDDPercent: accountData.maxDDPercent,  // Use pre-calculated
                        currentDD: accountData.currentDD,  // Use pre-calculated
                        currentDDPercent: accountData.currentDDPercent,  // Use pre-calculated
                        currentDDDuration: accountData.currentDDDuration,  // Use pre-calculated
                        ddDuration: accountData.ddDuration,  // Use pre-calculated
                        recoveryTime: accountData.recoveryTime,  // Use pre-calculated
                        ddStartDate: accountData.ddStartDate,  // Use pre-calculated
                        ddEndDate: accountData.ddEndDate,  // Use pre-calculated
                        ddCount: accountData.ddCount,  // Use pre-calculated
                        recoveryFactor: accountData.recoveryFactor,  // Use pre-calculated
                        underwaterPeriod: accountData.underwaterPeriod  // Use pre-calculated
                    };
                } else {
                    // Fallback to old calculation if account not found
                    const strategies = data.strategies;
                    return {
                        strategy: accountCode,
                        parentBroker: data.broker,
                        isGroup: true,
                        isBroker: false,
                        isChild: false,
                        lotSize: strategies.reduce((sum, s) => sum + (typeof s.lotSize === 'number' ? s.lotSize : 0), 0),
                        maxDD: Math.min(...strategies.map(s => s.maxDD)),
                        maxDDPercent: Math.min(...strategies.map(s => s.maxDDPercent)),
                        currentDD: strategies.reduce((sum, s) => sum + s.currentDD, 0),
                        currentDDPercent: strategies.reduce((sum, s) => sum + s.currentDDPercent, 0) / strategies.length,
                        currentDDDuration: Math.max(...strategies.map(s => s.currentDDDuration || 0)),
                        ddDuration: Math.max(...strategies.map(s => s.ddDuration)),
                        recoveryTime: Math.round(strategies.reduce((sum, s) => sum + s.recoveryTime, 0) / strategies.length),
                        ddStartDate: strategies[0].ddStartDate,
                        ddEndDate: strategies[0].ddEndDate,
                        ddCount: strategies.reduce((sum, s) => sum + s.ddCount, 0),
                        recoveryFactor: strategies.reduce((sum, s) => sum + s.recoveryFactor, 0) / strategies.length,
                        underwaterPeriod: Math.max(...strategies.map(s => s.underwaterPeriod))
                    };
                }
            });

            // Recalculate broker metrics based on filtered accounts
            const brokerMetrics = {};
            recalculatedAccounts.forEach(acc => {
                if (!brokerMetrics[acc.parentBroker]) {
                    brokerMetrics[acc.parentBroker] = {
                        accounts: []
                    };
                }
                brokerMetrics[acc.parentBroker].accounts.push(acc);
            });

            const recalculatedBrokers = Object.entries(brokerMetrics).map(([brokerCode, data]) => {
                // Get the pre-calculated broker data from drawdownData
                const brokerData = drawdownData.find(d => d.isBroker && d.strategy === brokerCode);
                
                if (brokerData) {
                    // Use the pre-calculated metrics, but recalculate aggregated values for displayed accounts
                    const accounts = data.accounts;
                    return {
                        strategy: brokerCode,
                        isBroker: true,
                        isGroup: false,
                        isChild: false,
                        lotSize: accounts.reduce((sum, a) => sum + (typeof a.lotSize === 'number' ? a.lotSize : 0), 0),
                        maxDD: brokerData.maxDD,  // Use pre-calculated
                        maxDDPercent: brokerData.maxDDPercent,  // Use pre-calculated
                        currentDD: brokerData.currentDD,  // Use pre-calculated
                        currentDDPercent: brokerData.currentDDPercent,  // Use pre-calculated
                        currentDDDuration: brokerData.currentDDDuration,  // Use pre-calculated
                        ddDuration: brokerData.ddDuration,  // Use pre-calculated
                        recoveryTime: brokerData.recoveryTime,  // Use pre-calculated
                        ddStartDate: brokerData.ddStartDate,  // Use pre-calculated
                        ddEndDate: brokerData.ddEndDate,  // Use pre-calculated
                        ddCount: brokerData.ddCount,  // Use pre-calculated
                        recoveryFactor: brokerData.recoveryFactor,  // Use pre-calculated
                        underwaterPeriod: brokerData.underwaterPeriod  // Use pre-calculated
                    };
                } else {
                    // Fallback to old calculation if broker not found
                    const accounts = data.accounts;
                    return {
                        strategy: brokerCode,
                        isBroker: true,
                        isGroup: false,
                        isChild: false,
                        lotSize: accounts.reduce((sum, a) => sum + (typeof a.lotSize === 'number' ? a.lotSize : 0), 0),
                        maxDD: Math.min(...accounts.map(a => a.maxDD)),
                        maxDDPercent: Math.min(...accounts.map(a => a.maxDDPercent)),
                        currentDD: accounts.reduce((sum, a) => sum + a.currentDD, 0),
                        currentDDPercent: accounts.reduce((sum, a) => sum + a.currentDDPercent, 0) / accounts.length,
                        currentDDDuration: Math.max(...accounts.map(a => a.currentDDDuration || 0)),
                        ddDuration: Math.max(...accounts.map(a => a.ddDuration)),
                        recoveryTime: Math.round(accounts.reduce((sum, a) => sum + a.recoveryTime, 0) / accounts.length),
                        ddStartDate: accounts[0].ddStartDate,
                        ddEndDate: accounts[0].ddEndDate,
                        ddCount: accounts.reduce((sum, a) => sum + a.ddCount, 0),
                        recoveryFactor: accounts.reduce((sum, a) => sum + a.recoveryFactor, 0) / accounts.length,
                        underwaterPeriod: Math.max(...accounts.map(a => a.underwaterPeriod))
                    };
                }
            });

            // Combine all filtered data - ALWAYS include all rows for rendering
            // View type only controls visibility via CSS, not calculations
            filteredData = [...recalculatedBrokers, ...recalculatedAccounts, ...filteredStrategies];
            
            // Set body data-view attribute to control visibility via CSS
            document.body.setAttribute('data-view', viewType);

            // Sort
            if (viewType === 'all') {
                filteredData.sort((a, b) => {
                    if (a.isBroker !== b.isBroker) return a.isBroker ? -1 : 1;
                    if (a.isGroup !== b.isGroup) return a.isGroup ? -1 : 1;
                    const aVal = a[sortColumn];
                    const bVal = b[sortColumn];
                    return sortDirection === 'asc' ? (aVal > bVal ? 1 : -1) : (aVal < bVal ? 1 : -1);
                });
            } else {
                filteredData.sort((a, b) => {
                    const aVal = a[sortColumn];
                    const bVal = b[sortColumn];
                    return sortDirection === 'asc' ? (aVal > bVal ? 1 : -1) : (aVal < bVal ? 1 : -1);
                });
            }

            console.log('Filtered data:', filteredData.length, 'rows');
            renderTable();
            updateSummaryCards(recalculatedBrokers, recalculatedAccounts, filteredStrategies);
            saveFilters();
        }

        function renderTable() {
            const tbody = document.getElementById('drawdownTableBody');
            if (filteredData.length === 0) {
                tbody.innerHTML = '<tr><td colspan="16" style="text-align:center;padding:40px;">No data available</td></tr>';
                return;
            }

            const viewType = document.getElementById('viewTypeFilter').value;
            
            // Group data hierarchically
            const brokers = filteredData.filter(d => d.isBroker);
            const accounts = filteredData.filter(d => d.isGroup);
            const strategies = filteredData.filter(d => d.isChild);
            
            // Helper function to calculate sums for an account (B1, B2, etc.)
            function calculateAccountSums(accountStrategy) {
                // Get the pre-calculated account data from accounts array
                const accountData = accounts.find(a => a.strategy === accountStrategy);
                
                const children = strategies.filter(s => s.parentAccount === accountStrategy);
                if (children.length === 0) return null;
                
                const sums = {
                    lotSize: children.reduce((sum, c) => sum + (c.lotSize || 0), 0),
                    maxDD: children.reduce((sum, c) => sum + (c.maxDD || 0), 0),
                    maxDDPercent: children.reduce((sum, c) => sum + (c.maxDDPercent || 0), 0),
                    currentDD: children.reduce((sum, c) => sum + (c.currentDD || 0), 0),
                    currentDDPercent: 0, // Will be recalculated below based on STG Margin
                    stgDD: accountData ? accountData.currentDD : children.reduce((sum, c) => sum + (c.currentDD || 0), 0),
                    currentDDDuration: accountData ? accountData.currentDDDuration : Math.max(...children.map(c => c.currentDDDuration || 0)),
                    recoveryTime: accountData ? accountData.recoveryTime : Math.max(...children.map(c => c.recoveryTime || 0)),
                    ddDuration: accountData ? accountData.ddDuration : Math.max(...children.map(c => c.ddDuration || 0)),
                    ddCount: accountData ? accountData.ddCount : Math.max(...children.map(c => c.ddCount || 0)),
                    underwaterPeriod: accountData ? accountData.underwaterPeriod : Math.max(...children.map(c => c.underwaterPeriod || 0)),
                    recoveryFactor: accountData ? accountData.recoveryFactor : children.reduce((sum, c) => sum + (c.recoveryFactor || 0), 0) / children.length,
                    ddStartDate: accountData ? accountData.ddStartDate : '-',
                    ddEndDate: accountData ? accountData.ddEndDate : '-'
                };
                
                // Calculate STG Margin = Lot Size * 400000
                sums.stgMargin = sums.lotSize * 400000;
                
                // Calculate stg dd(%)
                if (sums.stgMargin > 0) {
                    sums.stgDDPercent = (sums.stgDD / sums.stgMargin) * 100;
                } else {
                    sums.stgDDPercent = 0;
                }
                
                // Recalculate Current DD % based on STG Margin
                if (sums.stgMargin > 0) {
                    sums.currentDDPercent = (sums.currentDD / sums.stgMargin) * 100;
                } else {
                    sums.currentDDPercent = 0;
                }
                
                // Broker margin and extra margin are left blank for account rows
                sums.brokerMargin = null;
                sums.extraMargin = null;
                
                return sums;
            }
            
            // Helper function to calculate broker sums from accounts (B)
            function calculateBrokerSums(brokerStrategy) {
                // Get the pre-calculated broker data from brokers array
                const brokerData = brokers.find(b => b.strategy === brokerStrategy);
                
                const brokerAccounts = accounts.filter(a => a.parentBroker === brokerStrategy);
                if (brokerAccounts.length === 0) return null;
                
                const accountSums = brokerAccounts.map(a => calculateAccountSums(a.strategy)).filter(s => s !== null);
                if (accountSums.length === 0) return null;
                
                const sums = {
                    lotSize: accountSums.reduce((sum, a) => sum + (a.lotSize || 0), 0),
                    maxDD: accountSums.reduce((sum, a) => sum + (a.maxDD || 0), 0),
                    maxDDPercent: accountSums.reduce((sum, a) => sum + (a.maxDDPercent || 0), 0),
                    currentDD: accountSums.reduce((sum, a) => sum + (a.currentDD || 0), 0),
                    currentDDPercent: 0, // Will be recalculated below based on STG Margin
                    stgDD: brokerData ? brokerData.currentDD : accountSums.reduce((sum, a) => sum + (a.currentDD || 0), 0),
                    currentDDDuration: brokerData ? brokerData.currentDDDuration : Math.max(...accountSums.map(a => a.currentDDDuration || 0)),
                    recoveryTime: brokerData ? brokerData.recoveryTime : Math.max(...accountSums.map(a => a.recoveryTime || 0)),
                    ddDuration: brokerData ? brokerData.ddDuration : Math.max(...accountSums.map(a => a.ddDuration || 0)),
                    ddCount: brokerData ? brokerData.ddCount : Math.max(...accountSums.map(a => a.ddCount || 0)),
                    underwaterPeriod: brokerData ? brokerData.underwaterPeriod : Math.max(...accountSums.map(a => a.underwaterPeriod || 0)),
                    recoveryFactor: brokerData ? brokerData.recoveryFactor : accountSums.reduce((sum, a) => sum + (a.recoveryFactor || 0), 0) / accountSums.length,
                    ddStartDate: brokerData ? brokerData.ddStartDate : '-',
                    ddEndDate: brokerData ? brokerData.ddEndDate : '-'
                };
                
                // Calculate STG Margin = Lot Size * 400000
                sums.stgMargin = sums.lotSize * 400000;
                
                // Calculate stg dd(%)
                if (sums.stgMargin > 0) {
                    sums.stgDDPercent = (sums.stgDD / sums.stgMargin) * 100;
                } else {
                    sums.stgDDPercent = 0;
                }
                
                // Recalculate Current DD % based on STG Margin
                if (sums.stgMargin > 0) {
                    sums.currentDDPercent = (sums.currentDD / sums.stgMargin) * 100;
                } else {
                    sums.currentDDPercent = 0;
                }
                
                // Get Broker Margin from calculated trade data (if available)
                const marginValue = getBrokerMarginForAccount(brokerStrategy);
                console.log(`Getting broker margin for ${brokerStrategy}: ${marginValue}, available margins:`, calculatedBrokerMargins);
                sums.brokerMargin = marginValue || 0;
                
                // Calculate Extra Margin = Broker Margin - sum of STG Margin (filtered)
                // sums.stgMargin already contains the sum of filtered account STG margins
                sums.extraMargin = sums.brokerMargin - sums.stgMargin;
                
                return sums;
            }
            
            let html = '';
            
            // Always render hierarchically (broker -> account -> strategy)
            // View type controls visibility via CSS, not rendering structure
            brokers.forEach(broker => {
                // Calculate sums for the broker based on filtered data
                const brokerSums = calculateBrokerSums(broker.strategy);
                const displayData = brokerSums || broker;
                
                // Render broker row with calculated sums
                const extraMarginClass = displayData.extraMargin > 0 ? 'positive' : (displayData.extraMargin < 0 ? 'negative' : 'neutral');
                html += `<tr class="broker-row">
                    <td class="broker-name">🏦 ${getDisplayName(broker.strategy)}</td>
                    <td>${formatNum(displayData.lotSize, 2)}</td>
                    <td>${formatCurrency(displayData.stgMargin)}</td>
                    <td>${formatCurrency(displayData.brokerMargin)}</td>
                    <td class="${extraMarginClass}">${formatCurrency(displayData.extraMargin)}</td>
                    <td class="${displayData.currentDD < 0 ? 'negative' : 'neutral'}">${formatCurrency(displayData.currentDD)}</td>
                    <td class="${displayData.currentDDPercent < 0 ? 'negative' : 'neutral'}">${formatPercent(displayData.currentDDPercent)}</td>
                    <td class="${displayData.stgDD < 0 ? 'negative' : 'neutral'}">${formatCurrency(displayData.stgDD)}</td>
                    <td class="${displayData.stgDDPercent < 0 ? 'negative' : 'neutral'}">${formatPercent(displayData.stgDDPercent)}</td>
                    <td>${displayData.currentDDDuration > 0 ? displayData.currentDDDuration + ' days' : '-'}</td>
                    <td>${displayData.ddStartDate}</td>
                    <td>${displayData.ddEndDate}</td>
                    <td class="negative">${formatCurrency(displayData.maxDD)}</td>
                    <td class="negative">${formatPercent(displayData.maxDDPercent)}</td>
                    <td>${displayData.recoveryTime > 0 ? displayData.recoveryTime + ' days' : '-'}</td>
                    <td>${displayData.ddCount}</td>
                </tr>`;
                
                // Find accounts under this broker
                const brokerAccounts = accounts.filter(a => a.parentBroker === broker.strategy);
                
                brokerAccounts.forEach(account => {
                    const accountCode = account.strategy.toLowerCase();
                    // Calculate sums for this account based on filtered data
                    const accountSums = calculateAccountSums(account.strategy);
                    const displayData = accountSums || account;
                    
                    // Find visible strategies under this account (for display)
                    const accountStrategies = strategies.filter(s => s.parentAccount === account.strategy);
                    
                    // Get broker margin from calculated trade data
                    const accountBrokerMargin = getBrokerMarginForAccount(account.strategy.toUpperCase()) || 0;
                    
                    // Calculate total STG Margin for this account for Extra Margin calculation
                    const totalAccountStgMargin = accountStrategies.reduce((sum, s) => sum + (s.lotSize * 400000), 0);
                    const accountExtraMargin = accountBrokerMargin - totalAccountStgMargin;
                    const extraMarginClass = accountExtraMargin > 0 ? 'positive' : (accountExtraMargin < 0 ? 'negative' : 'neutral');
                    
                    // Account row - Broker Margin and Extra Margin are shown ONLY when viewType is 'account'
                    const showBrokerMarginInAccount = viewType === 'account';
                    html += `<tr class="group-row group-${accountCode}">
                        <td class="group-name">├─ ${getDisplayName(account.strategy)}</td>
                        <td>${formatNum(displayData.lotSize, 2)}</td>
                        <td>${formatCurrency(displayData.stgMargin)}</td>
                        <td>${showBrokerMarginInAccount ? formatCurrency(accountBrokerMargin) : ''}</td>
                        <td${showBrokerMarginInAccount ? ` class="${extraMarginClass}"` : ''}>${showBrokerMarginInAccount ? formatCurrency(accountExtraMargin) : ''}</td>
                        <td class="${displayData.currentDD < 0 ? 'negative' : 'neutral'}">${formatCurrency(displayData.currentDD)}</td>
                        <td class="${displayData.currentDDPercent < 0 ? 'negative' : 'neutral'}">${formatPercent(displayData.currentDDPercent)}</td>
                        <td class="${displayData.stgDD < 0 ? 'negative' : 'neutral'}">${formatCurrency(displayData.stgDD)}</td>
                        <td class="${displayData.stgDDPercent < 0 ? 'negative' : 'neutral'}">${formatPercent(displayData.stgDDPercent)}</td>
                        <td>${displayData.currentDDDuration > 0 ? displayData.currentDDDuration + ' days' : '-'}</td>
                        <td>${displayData.ddStartDate}</td>
                        <td>${displayData.ddEndDate}</td>
                        <td class="negative">${formatCurrency(displayData.maxDD)}</td>
                        <td class="negative">${formatPercent(displayData.maxDDPercent)}</td>
                        <td>${displayData.recoveryTime > 0 ? displayData.recoveryTime + ' days' : '-'}</td>
                        <td>${displayData.ddCount}</td>
                    </tr>`;
                    
                    // Strategy rows - STG Margin individual, Broker Margin and Extra Margin merged
                    accountStrategies.forEach((strategy, index) => {
                        const parentAccountCode = strategy.parentAccount.toLowerCase();
                        if (index === 0) {
                            // First strategy row - add merged Broker Margin and Extra Margin cells
                            html += `<tr class="child-row child-row-${parentAccountCode}">
                                <td style="padding-left: 40px;">${strategy.strategy}</td>
                                <td>${formatNum(strategy.lotSize, 2)}</td>
                                <td>${formatCurrency(strategy.lotSize * 400000)}</td>
                                <td rowspan="${accountStrategies.length}">${formatCurrency(accountBrokerMargin)}</td>
                                <td rowspan="${accountStrategies.length}" class="${extraMarginClass}">${formatCurrency(accountExtraMargin)}</td>
                                <td class="${strategy.currentDD < 0 ? 'negative' : 'neutral'}">${formatCurrency(strategy.currentDD)}</td>
                                <td class="${strategy.currentDDPercent < 0 ? 'negative' : 'neutral'}">${formatPercent(strategy.currentDDPercent)}</td>
                                <td class="${strategy.currentDD < 0 ? 'negative' : 'neutral'}">${formatCurrency(strategy.currentDD)}</td>
                                <td class="${strategy.currentDDPercent < 0 ? 'negative' : 'neutral'}">${formatPercent(strategy.currentDDPercent)}</td>
                                <td>${strategy.currentDDDuration > 0 ? strategy.currentDDDuration + ' days' : '-'}</td>
                                <td>${strategy.ddStartDate}</td>
                                <td>${strategy.ddEndDate}</td>
                                <td class="negative">${formatCurrency(strategy.maxDD)}</td>
                                <td class="negative">${formatPercent(strategy.maxDDPercent)}</td>
                                <td>${strategy.recoveryTime > 0 ? strategy.recoveryTime + ' days' : '-'}</td>
                                <td>${strategy.ddCount}</td>
                            </tr>`;
                        } else {
                            // Subsequent strategy rows - show individual STG Margin, no Broker Margin or Extra Margin cells (merged from first row)
                            html += `<tr class="child-row child-row-${parentAccountCode}">
                                <td style="padding-left: 40px;">${strategy.strategy}</td>
                                <td>${formatNum(strategy.lotSize, 2)}</td>
                                <td>${formatCurrency(strategy.lotSize * 400000)}</td>
                                <td class="${strategy.currentDD < 0 ? 'negative' : 'neutral'}">${formatCurrency(strategy.currentDD)}</td>
                                <td class="${strategy.currentDDPercent < 0 ? 'negative' : 'neutral'}">${formatPercent(strategy.currentDDPercent)}</td>
                                <td class="${strategy.currentDD < 0 ? 'negative' : 'neutral'}">${formatCurrency(strategy.currentDD)}</td>
                                <td class="${strategy.currentDDPercent < 0 ? 'negative' : 'neutral'}">${formatPercent(strategy.currentDDPercent)}</td>
                                <td>${strategy.currentDDDuration > 0 ? strategy.currentDDDuration + ' days' : '-'}</td>
                                <td>${strategy.ddStartDate}</td>
                                <td>${strategy.ddEndDate}</td>
                                <td class="negative">${formatCurrency(strategy.maxDD)}</td>
                                <td class="negative">${formatPercent(strategy.maxDDPercent)}</td>
                                <td>${strategy.recoveryTime > 0 ? strategy.recoveryTime + ' days' : '-'}</td>
                                <td>${strategy.ddCount}</td>
                            </tr>`;
                        }
                    });
                });
            });
            
            tbody.innerHTML = html;
        }

        function updateSummaryCards(allBrokers, allAccounts, allStrategies) {
            // Always use full data for summary cards, regardless of view type filter
            const brokers = allBrokers || [];
            const accounts = allAccounts || [];
            const strategies = allStrategies || [];
            
            if (brokers.length === 0 && accounts.length === 0 && strategies.length === 0) return;
            
            // Helper function to calculate sums for an account (same as in renderTable)
            function calculateAccountSums(accountStrategy) {
                const children = strategies.filter(s => s.parentAccount === accountStrategy);
                if (children.length === 0) return null;
                
                const sums = {
                    lotSize: children.reduce((sum, c) => sum + (c.lotSize || 0), 0),
                    currentDD: children.reduce((sum, c) => sum + (c.currentDD || 0), 0)
                };
                
                sums.stgMargin = sums.lotSize * 400000;
                
                return sums;
            }
            
            // Helper function to calculate broker sums (same as in renderTable)
            function calculateBrokerSums(brokerStrategy) {
                const brokerAccounts = accounts.filter(a => a.parentBroker === brokerStrategy);
                if (brokerAccounts.length === 0) return null;
                
                const accountSums = brokerAccounts.map(a => calculateAccountSums(a.strategy)).filter(s => s !== null);
                if (accountSums.length === 0) return null;
                
                const sums = {
                    lotSize: accountSums.reduce((sum, a) => sum + (a.lotSize || 0), 0),
                    currentDD: accountSums.reduce((sum, a) => sum + (a.currentDD || 0), 0)
                };
                
                sums.stgMargin = sums.lotSize * 400000;
                sums.brokerMargin = getBrokerMarginForAccount(brokerStrategy) || 0;
                
                return sums;
            }
            
            // Initialize totals
            let totalBrokerMargin = 0;
            let totalStgMargin = 0;
            let totalCurrentDDRupees = 0;
            
            // Calculate totals for each broker
            brokers.forEach(broker => {
                const brokerSums = calculateBrokerSums(broker.strategy);
                
                if (brokerSums) {
                    totalBrokerMargin += brokerSums.brokerMargin || 0;
                    totalStgMargin += brokerSums.stgMargin || 0;
                    totalCurrentDDRupees += brokerSums.currentDD || 0;
                }
            });
            
            // Update stat box with rupee symbol
            if (totalBrokerMargin === 0) {
                document.getElementById('totalBrokerMargin').textContent = '-';
            } else {
                const formatted = formatCurrency(totalBrokerMargin);
                document.getElementById('totalBrokerMargin').textContent = formatted === '-' ? '-' : '₹' + formatted;
            }
            
            if (totalStgMargin === 0) {
                document.getElementById('totalStgMargin').textContent = '-';
            } else {
                const formatted = formatCurrency(totalStgMargin);
                document.getElementById('totalStgMargin').textContent = formatted === '-' ? '-' : '₹' + formatted;
            }
            
            if (totalCurrentDDRupees === 0) {
                document.getElementById('totalCurrentDDRupees').textContent = '-';
            } else {
                const formatted = formatCurrency(totalCurrentDDRupees);
                document.getElementById('totalCurrentDDRupees').textContent = formatted === '-' ? '-' : '₹' + formatted;
            }
            
            // Calculate Total Current DD %
            const totalCurrentDDPercent = totalStgMargin > 0 
                ? (totalCurrentDDRupees / totalStgMargin) * 100 
                : 0;
            document.getElementById('totalCurrentDDPercent').textContent = formatPercent(totalCurrentDDPercent);

            // Calculate Avg Drawdown - use all data regardless of view type
            const allData = [...brokers, ...accounts, ...strategies];
            const avgDD = allData.length > 0 ? allData.reduce((sum, d) => sum + d.maxDDPercent, 0) / allData.length : 0;
            document.getElementById('avgDrawdown').textContent = formatPercent(avgDD);

            // Calculate DD Duration from B (broker B)
            const brokerB = brokers.find(b => b.strategy === 'B');
            let ddDurationFromB = 0;
            let stgDDFromB = 0;
            if (brokerB) {
                // Get the maximum currentDDDuration from all strategies under broker B
                const strategiesUnderB = strategies.filter(s => s.parentBroker === 'B');
                if (strategiesUnderB.length > 0) {
                    ddDurationFromB = Math.max(...strategiesUnderB.map(s => s.currentDDDuration || 0));
                }
                
                // Get STG DD from broker B - use the currentDD from broker data directly
                stgDDFromB = brokerB.currentDD || 0;
            }
            document.getElementById('ddDurationFromB').textContent = ddDurationFromB > 0 ? ddDurationFromB + ' days' : '-';
            
            // Update STG DD (₹) from B
            if (stgDDFromB === 0) {
                document.getElementById('stgDDFromB').textContent = '-';
            } else {
                const formatted = formatCurrency(stgDDFromB);
                document.getElementById('stgDDFromB').textContent = formatted === '-' ? '-' : '₹' + formatted;
            }
        }

        function sortTable(column) {
            if (sortColumn === column) {
                sortDirection = sortDirection === 'asc' ? 'desc' : 'asc';
            } else {
                sortColumn = column;
                sortDirection = 'desc';
            }
            applyFilters();
        }

        function handleSortSelect() {
            sortColumn = document.getElementById('sortSelect').value;
            sortDirection = sortColumn === 'strategy' ? 'asc' : 'desc';
            applyFilters();
        }

        function resetFilters() {
            hiddenStrategies.clear();
            document.getElementById('minDrawdownFilter').value = '';
            document.getElementById('viewTypeFilter').value = 'all';
            document.getElementById('sortSelect').value = 'strategy';
            sortColumn = 'strategy';
            sortDirection = 'asc';
            updateStrategyCheckboxes();
            updateSelectedCount();
            clearSavedFilters();
            applyFilters();
        }

        function populateStrategyOptions() {
            allStrategyNames = drawdownData.filter(d => d.isChild).map(d => d.strategy).sort();
            const container = document.getElementById('strategyOptions');
            container.innerHTML = allStrategyNames.map(s => `
                <div class="dropdown-option" onclick="handleRowClick(event, '${s.replace(/'/g, "\\'")}')">
                    <input type="checkbox" id="strategy-${CSS.escape(s)}" value="${s}" ${!hiddenStrategies.has(s) ? 'checked' : ''} onchange="toggleStrategy('${s.replace(/'/g, "\\'")}')">
                    <label for="strategy-${CSS.escape(s)}">${s}</label>
                </div>
            `).join('');
            updateSelectedCount();
        }

        function handleRowClick(event, strategy) {
            // If clicking directly on checkbox, let the default behavior handle it
            if (event.target.tagName === 'INPUT') {
                return;
            }
            // If clicking on label, let it toggle the checkbox naturally (via for attribute)
            if (event.target.tagName === 'LABEL') {
                return;
            }
            // Otherwise (clicking on div padding), toggle the checkbox which will trigger onchange
            const checkbox = document.getElementById(`strategy-${CSS.escape(strategy)}`);
            if (checkbox) {
                checkbox.checked = !checkbox.checked;
                // Manually trigger the change event
                checkbox.dispatchEvent(new Event('change'));
            }
        }

        function toggleStrategyDropdown() {
            document.getElementById('strategyDropdownMenu').classList.toggle('show');
        }

        function toggleStrategy(strategy) {
            hiddenStrategies.has(strategy) ? hiddenStrategies.delete(strategy) : hiddenStrategies.add(strategy);
            updateSelectedCount();
            applyFilters();
        }

        function selectAllStrategies() {
            hiddenStrategies.clear();
            updateStrategyCheckboxes();
            updateSelectedCount();
            applyFilters();
        }

        function selectNoneStrategies() {
            allStrategyNames.forEach(s => hiddenStrategies.add(s));
            updateStrategyCheckboxes();
            updateSelectedCount();
            applyFilters();
        }

        function resetStrategySelection() {
            hiddenStrategies.clear();
            updateStrategyCheckboxes();
            updateSelectedCount();
            applyFilters();
        }

        function updateStrategyCheckboxes() {
            allStrategyNames.forEach(s => {
                const cb = document.getElementById(`strategy-${CSS.escape(s)}`);
                if (cb) cb.checked = !hiddenStrategies.has(s);
            });
        }

        function updateSelectedCount() {
            document.getElementById('selectedCount').textContent = allStrategyNames.length - hiddenStrategies.size;
        }

        function expandAll() {
            document.querySelectorAll('tbody tr').forEach(row => row.style.display = '');
        }

        function collapseAll() {
            document.querySelectorAll('tbody tr').forEach(row => {
                if (row.classList.contains('child-row') || row.classList.contains('group-row')) {
                    row.style.display = 'none';
                }
            });
        }

        function loadSavedFilters() {
            try {
                const saved = localStorage.getItem('drawdownFilters');
                if (saved) {
                    const data = JSON.parse(saved);
                    hiddenStrategies = new Set(data.hiddenStrategies || []);
                    document.getElementById('minDrawdownFilter').value = data.minDD || '';
                    document.getElementById('viewTypeFilter').value = data.viewType || 'all';
                    document.getElementById('sortSelect').value = data.sortBy || 'strategy';
                    sortColumn = data.sortBy || 'strategy';
                    // Set body data-view attribute for CSS visibility control
                    document.body.setAttribute('data-view', data.viewType || 'all');
                }
            } catch (e) {}
        }

        function saveFilters() {
            try {
                localStorage.setItem('drawdownFilters', JSON.stringify({
                    hiddenStrategies: Array.from(hiddenStrategies),
                    minDD: document.getElementById('minDrawdownFilter').value,
                    viewType: document.getElementById('viewTypeFilter').value,
                    sortBy: sortColumn
                }));
            } catch (e) {}
        }

        function clearSavedFilters() {
            try {
                localStorage.removeItem('drawdownFilters');
            } catch (e) {}
        }

        function formatCurrency(val) {
            if (!val) return '-';
            const abs = Math.abs(val);
            const sign = val < 0 ? '-' : '';
            let str = Math.round(abs).toString();
            if (str.length > 3) {
                const last3 = str.slice(-3);
                const rest = str.slice(0, -3).replace(/\B(?=(\d{2})+(?!\d))/g, ',');
                str = rest + ',' + last3;
            }
            return sign + str;
        }

        function formatPercent(val) {
            return val ? val.toFixed(2) + '%' : '0.00%';
        }

        function formatNum(val, decimals = 2) {
            return val && val !== '-' ? val.toFixed(decimals) : '-';
        }

        function formatDate(dateStr) {
            if (!dateStr || dateStr === '-') return '-';
            try {
                const [d, m, y] = dateStr.split('/');
                const date = new Date(y, m - 1, d);
                const day = String(date.getDate()).padStart(2, '0');
                const month = date.toLocaleString('en-US', { month: 'short' });
                return `${day}-${month}`;
            } catch (e) {
                return dateStr;
            }
        }

        function getDisplayName(name) {
            // Handle specific mappings
            const displayNames = {
                'B': 'All Broker'
            };
            
            // Handle B1, B2, B3, etc. dynamically
            if (name.match(/^B\d+$/)) {
                const num = name.substring(1);
                return `Broker ${num}`;
            }
            
            // Return mapped name or original name
            return displayNames[name] || name;
        }

        document.addEventListener('click', (e) => {
            const selector = document.querySelector('.strategy-selector');
            if (selector && !selector.contains(e.target)) {
                document.getElementById('strategyDropdownMenu').classList.remove('show');
            }
        });

        // Store trades data and calculated broker margins
        let tradesData = null;
        let calculatedBrokerMargins = {};

        // Calculate broker margin from trades data (same logic as strategy-performance.html)
        function calculateBrokerMarginFromTrades() {
            // tradesData is an array of trade objects
            if (!tradesData || !Array.isArray(tradesData) || tradesData.length === 0) {
                console.log('⚠️ No trades data available for broker margin calculation');
                calculatedBrokerMargins = {};
                return;
            }

            console.log('💰 Calculating broker margins from', tradesData.length, 'trades');
            
            // Build list of all strategies from trades
            const strategiesSet = new Set();
            tradesData.forEach(trade => {
                if (trade.strategyDetails) {
                    Object.keys(trade.strategyDetails).forEach(stratName => {
                        strategiesSet.add(stratName);
                    });
                }
            });
            
            const allStrategies = Array.from(strategiesSet);
            const allBrokerStrategies = allStrategies.filter(s => !s.startsWith('A.PRO'));
            
            console.log('📋 Found', allBrokerStrategies.length, 'broker strategies:', allBrokerStrategies.slice(0, 5));
            
            const brokerMarginsByDate = {};
            
            // Collect margins by date and broker from trades
            tradesData.forEach(trade => {
                const tradeDate = trade.date;
                if (!brokerMarginsByDate[tradeDate]) {
                    brokerMarginsByDate[tradeDate] = {};
                }
                
                if (trade.strategyDetails) {
                    allBrokerStrategies.forEach(brokerStrat => {
                        const margin = trade.strategyDetails[brokerStrat]?.margin || 0;
                        const brokerMatch = brokerStrat.match(/^(B\d+|C\d+|D\d+|E\d+)/);
                        
                        if (brokerMatch) {
                            const brokerCode = brokerMatch[1];
                            if (!brokerMarginsByDate[tradeDate][brokerCode]) {
                                brokerMarginsByDate[tradeDate][brokerCode] = {};
                            }
                            // Store MAX margin for each strategy on each date
                            if (!brokerMarginsByDate[tradeDate][brokerCode][brokerStrat] || margin > brokerMarginsByDate[tradeDate][brokerCode][brokerStrat]) {
                                brokerMarginsByDate[tradeDate][brokerCode][brokerStrat] = margin;
                            }
                        }
                    });
                }
            });
            
            // Get sorted dates (latest first) - proper full date comparison
            const sortedDates = Object.keys(brokerMarginsByDate).sort((a, b) => {
                const parseDate = (dateStr) => {
                    const [day, month, year] = dateStr.split('/').map(Number);
                    return new Date(year, month - 1, day);
                };
                return parseDate(b) - parseDate(a); // Latest first
            });
            
            console.log('📅 Date range in data:', sortedDates.length > 0 ? `${sortedDates[sortedDates.length - 1]} to ${sortedDates[0]}` : 'No dates');
            
            // Get all unique brokers
            const allBrokersInData = new Set();
            Object.values(brokerMarginsByDate).forEach(dateMargins => {
                Object.keys(dateMargins).forEach(broker => allBrokersInData.add(broker));
            });
            
            // For each broker, find the most recent day with non-zero margin
            const brokerMaxMargins = {};
            
            allBrokersInData.forEach(brokerCode => {
                for (let i = 0; i < sortedDates.length; i++) {
                    const checkDate = sortedDates[i];
                    
                    if (brokerMarginsByDate[checkDate] && brokerMarginsByDate[checkDate][brokerCode]) {
                        const strategyMargins = Object.entries(brokerMarginsByDate[checkDate][brokerCode]);
                        const margins = strategyMargins.map(([strat, margin]) => margin);
                        const maxMargin = margins.length > 0 ? Math.max(...margins) : 0;
                        
                        if (maxMargin > 0) {
                            brokerMaxMargins[brokerCode] = maxMargin;
                            console.log(`  ${brokerCode}: ₹${maxMargin.toLocaleString()} from date ${checkDate} (strategies: ${strategyMargins.map(([s,m]) => `${s}:${m}`).join(', ')})`);
                            
                            // Store margin for each account (B1, B2, etc.)
                            calculatedBrokerMargins[brokerCode] = maxMargin;
                            break;
                        }
                    }
                }
            });
            
            // Calculate total broker margin for each broker type (A, B, C, etc.)
            // Group by first letter
            const brokerTotals = {};
            Object.entries(brokerMaxMargins).forEach(([code, margin]) => {
                const brokerLetter = code.charAt(0); // Get 'B' from 'B1'
                if (!brokerTotals[brokerLetter]) {
                    brokerTotals[brokerLetter] = 0;
                }
                brokerTotals[brokerLetter] += margin;
            });
            
            // Store totals for each broker type
            Object.entries(brokerTotals).forEach(([letter, total]) => {
                calculatedBrokerMargins[letter] = total;
            });
            
            console.log('✅ Calculated Broker Margins:', calculatedBrokerMargins);
            console.log('📊 Individual account margins:', Object.entries(calculatedBrokerMargins).filter(([k,v]) => k.length > 1).reduce((acc, [k,v]) => ({...acc, [k]: v}), {}));
            console.log('📊 Total broker margins:', Object.entries(calculatedBrokerMargins).filter(([k,v]) => k.length === 1).reduce((acc, [k,v]) => ({...acc, [k]: v}), {}));
        }

        // Helper function to get broker margin for an account
        function getBrokerMarginForAccount(accountCode) {
            return calculatedBrokerMargins[accountCode] || 0;
        }

        // Request trades data from parent on page load
        window.addEventListener('load', function() {
            console.log('🔄 Drawdown: Requesting data refresh from parent');
            window.parent.postMessage({ type: 'REQUEST_DATA_REFRESH' }, '*');
        });
    </script>
</body>
</html>
