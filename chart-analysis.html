<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Chart Analysis</title>
    <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.0/dist/chart.umd.min.js"></script>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        html, body { width: 100%; height: 100%; overflow: hidden; }
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            background: #f8fafc;
            color: #1e293b;
        }
        .main-content {
            overflow-y: auto;
            overflow-x: hidden;
            padding: 20px 32px 32px 32px;
            background: #f8fafc;
            height: 100vh;
            width: 100%;
        }
        .page-header { margin-bottom: 20px; }
        .page-title { font-size: 20px; font-weight: 700; color: #111827; margin-bottom: 4px; letter-spacing: -0.5px; }
        .page-subtitle { font-size: 12px; color: #6b7280; font-weight: 400; }
        
        /* Charts Grid */
        .charts-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            height: calc(100vh - 140px);
        }
        
        .chart-card {
            background: white;
            border-radius: 12px;
            padding: 20px;
            box-shadow: 0 1px 3px rgba(0,0,0,0.06), 0 1px 2px rgba(0,0,0,0.04);
            border: 1px solid #f1f5f9;
            display: flex;
            flex-direction: column;
            transition: box-shadow 0.2s ease;
            overflow: hidden;
        }
        
        .chart-card:hover { 
            box-shadow: 0 4px 6px rgba(0,0,0,0.07), 0 2px 4px rgba(0,0,0,0.05); 
        }
        
        .chart-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 16px;
        }
        
        .chart-title {
            font-size: 14px;
            font-weight: 600;
            color: #374151;
            letter-spacing: 0.3px;
        }
        
        .chart-toggles {
            display: flex;
            gap: 6px;
            background: #f1f5f9;
            padding: 3px;
            border-radius: 8px;
        }
        
        .chart-controls {
            display: flex;
            gap: 8px;
            align-items: center;
        }
        
        .toggle-btn {
            padding: 6px 12px;
            font-size: 11px;
            font-weight: 600;
            color: #64748b;
            background: transparent;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.2s ease;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }
        
        .toggle-btn:hover {
            color: #475569;
        }
        
        .toggle-btn.active {
            background: white;
            color: #1e40af;
            box-shadow: 0 1px 3px rgba(0,0,0,0.1);
        }
        
        .chart-container {
            flex: 1;
            position: relative;
            min-height: 0;
        }
        
        .chart-container canvas {
            width: 100% !important;
            height: 100% !important;
        }
        
        /* Loading State */
        .loading-state {
            display: none;
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            z-index: 10;
        }
        
        .loading-state.active {
            display: block;
        }
        
        .loading-spinner {
            width: 40px;
            height: 40px;
            border: 3px solid #e5e7eb;
            border-top: 3px solid #1e40af;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin: 0 auto 12px;
        }
        
        .loading-message {
            color: #64748b;
            font-size: 13px;
            font-weight: 500;
        }
        
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
    </style>
</head>
<body>
    <div class="main-content">
        <div class="page-header">
            <div class="page-title">Advanced Chart Analysis</div>
            <div class="page-subtitle">Comprehensive performance visualization across multiple metrics</div>
        </div>
        
        <div class="charts-grid">
            <!-- Cumulative P&L Chart -->
            <div class="chart-card">
                <div class="chart-header">
                    <div class="chart-title">Cumulative P&L</div>
                    <div class="chart-controls">
                        <div class="chart-toggles">
                            <button class="toggle-btn active" data-chart="pnl" data-type="value">Value</button>
                            <button class="toggle-btn" data-chart="pnl" data-type="percentage">%</button>
                        </div>
                        <div class="chart-toggles">
                            <button class="toggle-btn active" data-chart="pnl" data-period="day">Day</button>
                            <button class="toggle-btn" data-chart="pnl" data-period="week">Week</button>
                            <button class="toggle-btn" data-chart="pnl" data-period="month">Month</button>
                        </div>
                    </div>
                </div>
                <div class="chart-container">
                    <canvas id="pnlChart"></canvas>
                </div>
            </div>
            
            <!-- Drawdown Chart -->
            <div class="chart-card">
                <div class="chart-header">
                    <div class="chart-title">Drawdown</div>
                    <div class="chart-controls">
                        <div class="chart-toggles">
                            <button class="toggle-btn active" data-chart="drawdown" data-type="value">Value</button>
                            <button class="toggle-btn" data-chart="drawdown" data-type="percentage">%</button>
                        </div>
                        <div class="chart-toggles">
                            <button class="toggle-btn active" data-chart="drawdown" data-period="day">Day</button>
                            <button class="toggle-btn" data-chart="drawdown" data-period="week">Week</button>
                            <button class="toggle-btn" data-chart="drawdown" data-period="month">Month</button>
                        </div>
                    </div>
                </div>
                <div class="chart-container">
                    <canvas id="drawdownChart"></canvas>
                </div>
            </div>
            
            <!-- Periodic Returns Chart -->
            <div class="chart-card">
                <div class="chart-header">
                    <div class="chart-title">Periodic Returns</div>
                    <div class="chart-controls">
                        <div class="chart-toggles">
                            <button class="toggle-btn active" data-chart="pnlbar" data-type="value">Value</button>
                            <button class="toggle-btn" data-chart="pnlbar" data-type="percentage">%</button>
                        </div>
                        <div class="chart-toggles">
                            <button class="toggle-btn" data-chart="pnlbar" data-period="day">Day</button>
                            <button class="toggle-btn" data-chart="pnlbar" data-period="week">Week</button>
                            <button class="toggle-btn active" data-chart="pnlbar" data-period="month">Month</button>
                        </div>
                    </div>
                </div>
                <div class="chart-container">
                    <canvas id="pnlBarChart"></canvas>
                </div>
            </div>
            
            <!-- Strategy Comparison Chart -->
            <div class="chart-card">
                <div class="chart-header">
                    <div class="chart-title">Strategy Comparison</div>
                    <div class="chart-toggles">
                        <button class="toggle-btn" data-chart="compare" data-period="day">Day</button>
                        <button class="toggle-btn" data-chart="compare" data-period="week">Week</button>
                        <button class="toggle-btn active" data-chart="compare" data-period="month">Month</button>
                    </div>
                </div>
                <div class="chart-container">
                    <canvas id="compareChart"></canvas>
                </div>
            </div>
        </div>
        
        <div class="loading-state" id="loadingState">
            <div class="loading-spinner"></div>
            <div class="loading-message">Loading chart data...</div>
        </div>
    </div>

    <script>
        // Indian Number Formatting Function
        function formatIndianNumber(num, decimals = 0) {
            const isNegative = num < 0;
            const absNum = Math.abs(num);
            
            // Round to specified decimals
            const rounded = decimals > 0 ? absNum.toFixed(decimals) : Math.round(absNum).toString();
            const parts = rounded.split('.');
            let intPart = parts[0];
            const decPart = parts[1];
            
            // Indian formatting: x,xx,xxx
            let formatted = '';
            if (intPart.length <= 3) {
                formatted = intPart;
            } else {
                const lastThree = intPart.substring(intPart.length - 3);
                const remaining = intPart.substring(0, intPart.length - 3);
                
                // Add commas every 2 digits for remaining part
                formatted = remaining.replace(/\B(?=(\d{2})+(?!\d))/g, ',') + ',' + lastThree;
            }
            
            // Add decimal part if exists
            if (decPart) {
                formatted += '.' + decPart;
            }
            
            return (isNegative ? '-' : '') + formatted;
        }
        
        // Global state
        let allTrades = [];
        const charts = {
            pnl: null,
            drawdown: null,
            pnlbar: null,
            compare: null
        };
        const activePeriods = {
            pnl: 'day',
            drawdown: 'day',
            pnlbar: 'month',
            compare: 'month'
        };
        
        const displayTypes = {
            pnl: 'value',
            drawdown: 'value',
            pnlbar: 'value'
        };

        // Elements
        const elements = {
            loadingState: document.getElementById('loadingState'),
            pnlChart: document.getElementById('pnlChart'),
            drawdownChart: document.getElementById('drawdownChart'),
            pnlBarChart: document.getElementById('pnlBarChart'),
            compareChart: document.getElementById('compareChart')
        };

        // Initialize
        (function init() {
            loadStoredData();
            setupEventListeners();
            initializeCharts();
            window.addEventListener('message', handleParentMessage);
            
            // Request data from parent on load
            setTimeout(() => {
                window.parent.postMessage({ type: 'REQUEST_DATA_REFRESH' }, '*');
            }, 100);
        })();

        function setupEventListeners() {
            // Toggle button listeners
            document.querySelectorAll('.toggle-btn').forEach(btn => {
                btn.addEventListener('click', function() {
                    const chartType = this.dataset.chart;
                    const period = this.dataset.period;
                    const type = this.dataset.type;
                    
                    // Handle period toggle
                    if (period) {
                        // Update active state for period toggles
                        document.querySelectorAll(`.toggle-btn[data-chart="${chartType}"][data-period]`).forEach(b => {
                            b.classList.remove('active');
                        });
                        this.classList.add('active');
                        
                        // Update period and refresh chart
                        activePeriods[chartType] = period;
                        updateChart(chartType);
                    }
                    
                    // Handle display type toggle
                    if (type) {
                        // Update active state for type toggles
                        document.querySelectorAll(`.toggle-btn[data-chart="${chartType}"][data-type]`).forEach(b => {
                            b.classList.remove('active');
                        });
                        this.classList.add('active');
                        
                        // Update display type and refresh chart
                        displayTypes[chartType] = type;
                        updateChart(chartType);
                    }
                });
            });
        }

        function handleParentMessage(event) {
            const { type, data } = event.data;
            
            if (type === 'TRADES_DATA' && data) {
                allTrades = data;
                updateAllCharts();
            } else if (type === 'UPDATE_DATA' && data) {
                const tradesCount = data.tradesData ? data.tradesData.length : 0;
                allTrades = data.tradesData || [];
                updateAllCharts();
            }
        }

        function loadStoredData() {
            try {
                const stored = localStorage.getItem('dashboardData');
                if (stored) {
                    const data = JSON.parse(stored);
                    allTrades = data.tradesData || data || [];
                    if (allTrades.length > 0) {
                        updateAllCharts();
                    }
                }
            } catch (e) {
            }
        }

        // Calculate daily total margins using the exact same logic as Strategy Performance
        function calculateDailyTotalMargins(sortedTrades, allStrategiesParam) {
            const result = {};
            const tradesByDate = {};
            sortedTrades.forEach(trade => {
                const dateKey = trade.date;
                if (!tradesByDate[dateKey]) {
                    tradesByDate[dateKey] = [];
                }
                tradesByDate[dateKey].push(trade);
            });
            const sortedDates = Object.keys(tradesByDate).sort((a, b) => {
                const dateA = a.split('/').reverse().join('');
                const dateB = b.split('/').reverse().join('');
                return dateA.localeCompare(dateB);
            });
            const brokerPnlTaxByDate = {};
            sortedTrades.forEach(trade => {
                const tradeDate = trade.date;
                if (!brokerPnlTaxByDate[tradeDate]) {
                    brokerPnlTaxByDate[tradeDate] = {};
                }
                if (trade && trade.strategyPnlTax) {
                    Object.entries(trade.strategyPnlTax).forEach(([stratName, pnlTax]) => {
                        if (!stratName.startsWith('A.PRO')) {
                            const cleanName = stratName.replace(/\s+/g, '');
                            const brokerMatch = cleanName.match(/^(.+?)PRO/);
                            if (brokerMatch) {
                                const brokerCode = brokerMatch[1];
                                if (!brokerPnlTaxByDate[tradeDate][brokerCode]) {
                                    brokerPnlTaxByDate[tradeDate][brokerCode] = {};
                                }
                                if (!brokerPnlTaxByDate[tradeDate][brokerCode][stratName]) {
                                    brokerPnlTaxByDate[tradeDate][brokerCode][stratName] = 0;
                                }
                                brokerPnlTaxByDate[tradeDate][brokerCode][stratName] += pnlTax;
                            }
                        }
                    });
                }
            });
            let previousDayBrokerMaxMargins = {};
            const brokerMarginDates = {}; // Track which date each broker's margin comes from
            sortedDates.forEach((dateKey, dateIndex) => {
                const dayTrades = tradesByDate[dateKey];
                const dayBrokerMargins = {};
                dayTrades.forEach(trade => {
                    if (trade.strategyDetails) {
                        Object.entries(trade.strategyDetails).forEach(([stratName, details]) => {
                            if (!stratName.startsWith('A.PRO')) {
                                const margin = details.margin || 0, cleanName = stratName.replace(/\s+/g, '');
                                const brokerMatch = cleanName.match(/^(.+?)PRO/);
                                if (brokerMatch) {
                                    const brokerCode = brokerMatch[1];
                                    if (!dayBrokerMargins[brokerCode]) {
                                        dayBrokerMargins[brokerCode] = {};
                                    }
                                    if (!dayBrokerMargins[brokerCode][stratName] || margin > dayBrokerMargins[brokerCode][stratName]) {
                                        dayBrokerMargins[brokerCode][stratName] = margin;
                                    }
                                }
                            }
                        });
                    }
                });
                const currentDayBrokerMaxMargins = {};
                let dayTotalMargin = 0;
                const allBrokers = new Set([...Object.keys(dayBrokerMargins), ...Object.keys(previousDayBrokerMaxMargins)]);
                allBrokers.forEach(brokerCode => {
                    let brokerMaxMargin = 0;
                    let marginDate = dateKey;
                    if (dayBrokerMargins[brokerCode]) {
                        const margins = Object.values(dayBrokerMargins[brokerCode]);
                        if (margins.length > 0) {
                            brokerMaxMargin = Math.max(...margins);
                        }
                    }
                    if (brokerMaxMargin === 0 && previousDayBrokerMaxMargins[brokerCode]) {
                        brokerMaxMargin = previousDayBrokerMaxMargins[brokerCode];
                        marginDate = brokerMarginDates[brokerCode] || dateKey;
                    }
                    currentDayBrokerMaxMargins[brokerCode] = brokerMaxMargin;
                    brokerMarginDates[brokerCode] = marginDate;
                    dayTotalMargin += brokerMaxMargin;
                });
                let dayPnlTax = 0;
                allBrokers.forEach(brokerCode => {
                    const marginDate = brokerMarginDates[brokerCode];
                    const marginDateIndex = sortedDates.indexOf(marginDate);
                    for (let i = marginDateIndex; i <= dateIndex; i++) {
                        const checkDate = sortedDates[i];
                        if (brokerPnlTaxByDate[checkDate] && brokerPnlTaxByDate[checkDate][brokerCode]) {
                            Object.values(brokerPnlTaxByDate[checkDate][brokerCode]).forEach(pnlTax => {
                                dayPnlTax += pnlTax;
                            });
                        }
                    }
                });
                result[dateKey] = dayTotalMargin + dayPnlTax;
                previousDayBrokerMaxMargins = { ...currentDayBrokerMaxMargins };
            });
            return result;
        }

        // Data aggregation functions
        function aggregateByPeriod(trades, period) {
            if (!trades || trades.length === 0) {
                return [];
            }
            
            const sortedTrades = [...trades].sort((a, b) => {
                return compareDates(a.date, b.date);
            });
            
            // Calculate daily total margins using the same logic as Strategy Performance
            const dailyTotalMargins = calculateDailyTotalMargins(sortedTrades, []);
            
            const aggregated = new Map();
            
            sortedTrades.forEach((trade, idx) => {
                const key = getAggregationKey(trade.date, period);
                if (!aggregated.has(key)) {
                    aggregated.set(key, {
                        date: key,
                        profit: 0,
                        cumPnl: 0,
                        drawdown: 0,
                        peak: 0,
                        trades: [],
                        lastCumPnl: 0,
                        lastTradeIndex: -1,
                        totalMargin: 0,
                        lastMargin: 0
                    });
                }
                
                const agg = aggregated.get(key);
                agg.profit += trade.profit || 0;
                agg.trades.push(trade);
                
                // Keep track of the last trade (by index, since we sorted)
                agg.lastTradeIndex = idx;
                agg.lastCumPnl = trade.cumPnl !== undefined ? trade.cumPnl : 0;
                
                // Use pre-calculated daily total margin from Strategy Performance logic
                const tradeDate = trade.date;
                if (dailyTotalMargins[tradeDate]) {
                    agg.totalMargin = dailyTotalMargins[tradeDate];
                    agg.lastMargin = dailyTotalMargins[tradeDate];
                }
            });
            
            let result = Array.from(aggregated.values()).sort((a, b) => {
                return compareDates(a.date, b.date);
            });
            
            // For week and month views, fill in ALL periods from the first trade date to last trade date
            if ((period === 'week' || period === 'month') && result.length > 0) {
                result = fillMissingPeriods(result, period, sortedTrades[0].date, sortedTrades[sortedTrades.length - 1].date);
            }
            
            let peak = 0;
            let prevCumPnl = 0;
            let startingCapital = 0;  // Will be set from first period
            let cumulativeExpenses = 0;  // Track expenses/withdrawals (negative of margin additions)
            
            result.forEach((item, index) => {
                // Use the lastCumPnl from the last trade in this period
                if (item.trades.length > 0) {
                    if (item.lastCumPnl !== undefined) {
                        item.cumPnl = item.lastCumPnl;
                    } else {
                        item.cumPnl = prevCumPnl + item.profit;
                    }
                } else {
                    item.cumPnl = prevCumPnl;
                }
                
                // The totalMargin from trades already includes cumPnl (see calculateDailyTotalMargins line 1679)
                // So we need to extract the base margin WITHOUT cumPnl
                const totalMarginWithPnl = item.totalMargin || item.lastMargin || 0;
                
                if (index === 0) {
                    // First period: extract starting capital = totalMargin - cumPnl
                    startingCapital = totalMarginWithPnl - (item.cumPnl || 0);
                    cumulativeExpenses = 0;
                    console.log('First period - startingCapital:', startingCapital, 'totalMargin:', totalMarginWithPnl, 'cumPnl:', item.cumPnl);
                } else {
                    // Calculate expected total margin = startingCapital + cumPnl - cumulativeExpenses
                    const expectedTotalMargin = startingCapital + (item.cumPnl || 0) - cumulativeExpenses;
                    
                    // Calculate expenses for this period = expectedTotalMargin - actualTotalMargin
                    const periodExpense = expectedTotalMargin - totalMarginWithPnl;
                    cumulativeExpenses += periodExpense;
                    
                    if (index < 3 || Math.abs(periodExpense) > 1000) {
                        console.log(`Period ${item.date}: totalMargin=${totalMarginWithPnl}, cumPnl=${item.cumPnl}, expected=${expectedTotalMargin}, expense=${periodExpense}, cumExpenses=${cumulativeExpenses}`);
                    }
                }
                
                // cumMargin is simply the totalMargin (which already includes cumPnl)
                item.cumMargin = totalMarginWithPnl;
                
                // For the first period with actual trades, periodProfit should equal cumPnl
                // since there's no previous period to subtract from
                if (index === 0 && item.trades.length > 0) {
                    item.periodProfit = item.cumPnl;
                } else {
                    item.periodProfit = item.cumPnl - prevCumPnl;
                }
                
                prevCumPnl = item.cumPnl;
                
                if (item.cumPnl > peak) {
                    peak = item.cumPnl;
                }
                item.peak = peak;
                item.drawdown = item.cumPnl - peak;
            });
            
            // Filter out leading empty periods (periods with no trades at the start)
            let firstNonEmptyIndex = result.findIndex(item => item.trades.length > 0);
            if (firstNonEmptyIndex > 0) {
                result = result.slice(firstNonEmptyIndex);
                // Recalculate periodProfit for the new first period
                if (result.length > 0 && result[0].trades.length > 0) {
                    result[0].periodProfit = result[0].cumPnl;
                }
            }
            
            return result;
        }

        function fillMissingPeriods(aggregatedData, period, firstTradeDate, lastTradeDate) {
            if (aggregatedData.length === 0) return [];
            
            // Use the first and last periods from aggregated data (where trades exist)
            // not the first/last trade dates (which might be in the middle of a period)
            const firstPeriodKey = aggregatedData[0].date;
            const lastPeriodKey = aggregatedData[aggregatedData.length - 1].date;
            
            // Convert period key back to date for iteration
            const periodToDate = (periodStr) => {
                if (periodStr.startsWith('W')) {
                    // Week format: W23-23 or W23-2023 (ISO week-year format)
                    const parts = periodStr.substring(1).split('-');
                    const week = parseInt(parts[0]);
                    const year = parseInt(parts[1]);
                    const fullYear = year < 100 ? 2000 + year : year;
                    return getISOWeekDate(fullYear, week);
                } else if (periodStr.includes('-')) {
                    // Month format: Jan-23 or Jan-2023
                    const monthNames = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];
                    const parts = periodStr.split('-');
                    const monthStr = parts[0];
                    const year = parseInt(parts[1]);
                    const month = monthNames.indexOf(monthStr);
                    const fullYear = year < 100 ? 2000 + year : year;
                    return new Date(fullYear, month, 1);
                }
                return null;
            };
            
            const existingMap = new Map(aggregatedData.map(item => [item.date, item]));
            const allPeriods = [];
            
            // Generate all periods from first aggregated period to last aggregated period
            let currentDate = periodToDate(firstPeriodKey);
            const endDate = periodToDate(lastPeriodKey);
            
            if (!currentDate || !endDate) return aggregatedData;
            
            while (currentDate <= endDate) {
                // Create a dummy date string to get the period key
                const year = currentDate.getFullYear();
                const month = currentDate.getMonth() + 1;
                const day = currentDate.getDate();
                const dummyDateStr = `${day}/${month}/${year}`;
                const periodKey = getAggregationKey(dummyDateStr, period);
                
                if (existingMap.has(periodKey)) {
                    allPeriods.push(existingMap.get(periodKey));
                } else {
                    // Create empty period with no trades
                    allPeriods.push({
                        date: periodKey,
                        profit: 0,
                        cumPnl: 0,
                        drawdown: 0,
                        peak: 0,
                        trades: [],
                        lastCumPnl: 0,
                        lastTradeIndex: -1,
                        totalMargin: 0,
                        lastMargin: 0,
                        periodProfit: 0
                    });
                }
                
                // Increment by period
                if (period === 'week') {
                    currentDate.setDate(currentDate.getDate() + 7);
                } else if (period === 'month') {
                    currentDate.setMonth(currentDate.getMonth() + 1);
                }
            }
            
            return allPeriods;
        }

        function getAggregationKey(dateStr, period) {
            if (!dateStr) return '';
            
            const [day, month, year] = dateStr.split('/').map(Number);
            // Handle both 2-digit (23) and 4-digit (2023) years
            const fullYear = year < 100 ? 2000 + year : year;
            const date = new Date(fullYear, month - 1, day);
            
            if (period === 'day') {
                return dateStr; // Keep original format
            } else if (period === 'week') {
                // Get week number and the ISO week-year
                const { weekNum, weekYear } = getWeekNumberAndYear(date);
                // Format year consistently (2-digit)
                const yearSuffix = String(weekYear).slice(-2);
                return `W${weekNum}-${yearSuffix}`;
            } else if (period === 'month') {
                const monthNames = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];
                const yearSuffix = year < 100 ? String(year).padStart(2, '0') : String(year).slice(-2);
                return `${monthNames[month - 1]}-${yearSuffix}`;
            }
            
            return dateStr;
        }

        function getWeekNumber(date) {
            const result = getWeekNumberAndYear(date);
            return result.weekNum;
        }
        
        function getWeekNumberAndYear(date) {
            const d = new Date(Date.UTC(date.getFullYear(), date.getMonth(), date.getDate()));
            const dayNum = d.getUTCDay() || 7;
            d.setUTCDate(d.getUTCDate() + 4 - dayNum);
            const weekYear = d.getUTCFullYear(); // This is the ISO week-year
            const yearStart = new Date(Date.UTC(weekYear, 0, 1));
            const weekNum = Math.ceil((((d - yearStart) / 86400000) + 1) / 7);
            return { weekNum, weekYear };
        }
        
        function getISOWeekDate(year, week) {
            // Get the Thursday of week 1 (which defines week 1)
            const jan4 = new Date(Date.UTC(year, 0, 4));
            const jan4Day = jan4.getUTCDay() || 7; // Monday=1, Sunday=7
            // Get Monday of week 1
            const week1Monday = new Date(jan4);
            week1Monday.setUTCDate(jan4.getUTCDate() - jan4Day + 1);
            // Add weeks to get to target week
            const targetMonday = new Date(week1Monday);
            targetMonday.setUTCDate(week1Monday.getUTCDate() + (week - 1) * 7);
            return new Date(targetMonday.getUTCFullYear(), targetMonday.getUTCMonth(), targetMonday.getUTCDate());
        }

        function compareDates(dateStr1, dateStr2) {
            // Handle different formats
            const parseDate = (str) => {
                if (str.startsWith('W')) {
                    // Week format: W23-23 or W23-2023 (ISO week-year format)
                    const [week, year] = str.substring(1).split('-').map(Number);
                    const fullYear = year < 100 ? 2000 + year : year;
                    // Get the Monday of this ISO week
                    return getISOWeekDate(fullYear, week);
                } else if (str.includes('-') && str.length <= 10) {
                    // Month format: Jan-23 or Jan-2023
                    const monthNames = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];
                    const [monthStr, year] = str.split('-');
                    const month = monthNames.indexOf(monthStr);
                    const fullYear = parseInt(year) < 100 ? 2000 + parseInt(year) : parseInt(year);
                    return new Date(fullYear, month, 1);
                } else {
                    // Day format: 15/05/23 or 15/05/2023
                    const [day, month, year] = str.split('/').map(Number);
                    const fullYear = year < 100 ? 2000 + year : year;
                    return new Date(fullYear, month - 1, day);
                }
            };
            
            return parseDate(dateStr1) - parseDate(dateStr2);
        }

        // Aggregate trades by strategy and period for comparison chart
        function aggregateByStrategyAndPeriod(trades, period) {
            if (!trades || trades.length === 0) {
                return { labels: [], strategies: {} };
            }
            
            const sortedTrades = [...trades].sort((a, b) => {
                return compareDates(a.date, b.date);
            });
            
            // Get unique strategies
            const strategies = {};
            const periodKeys = new Set();
            
            // Group trades by strategy and period
            sortedTrades.forEach(trade => {
                const strategy = trade.strategy || 'Unknown';
                const periodKey = getAggregationKey(trade.date, period);
                
                if (!strategies[strategy]) {
                    strategies[strategy] = new Map();
                }
                
                if (!strategies[strategy].has(periodKey)) {
                    strategies[strategy].set(periodKey, {
                        date: periodKey,
                        profit: 0,
                        trades: [],
                        lastCumPnl: 0
                    });
                }
                
                const agg = strategies[strategy].get(periodKey);
                agg.profit += trade.profit || 0;
                agg.trades.push(trade);
                agg.lastCumPnl = trade.cumPnl !== undefined ? trade.cumPnl : 0;
                
                periodKeys.add(periodKey);
            });
            
            // Convert to sorted arrays and calculate cumulative values per strategy
            const sortedPeriods = Array.from(periodKeys).sort((a, b) => compareDates(a, b));
            
            const result = { labels: sortedPeriods, strategies: {} };
            
            for (const [strategyName, periodMap] of Object.entries(strategies)) {
                const strategyData = [];
                let strategyCumPnl = 0;
                
                sortedPeriods.forEach(periodKey => {
                    if (periodMap.has(periodKey)) {
                        const periodData = periodMap.get(periodKey);
                        // Add the profit from this period to strategy cumulative
                        strategyCumPnl += periodData.profit;
                        strategyData.push(strategyCumPnl);
                    } else {
                        // No trades in this period for this strategy
                        if (period === 'day') {
                            // For day view: carry forward the previous value (line continues)
                            strategyData.push(strategyCumPnl);
                        } else {
                            // For week/month view: create a gap in the line
                            strategyData.push(null);
                        }
                    }
                });
                
                result.strategies[strategyName] = strategyData;
            }
            
            return result;
        }

        function formatLabel(dateStr, period) {
            if (period === 'day') {
                const [day, month] = dateStr.split('/');
                const monthNames = ['JAN', 'FEB', 'MAR', 'APR', 'MAY', 'JUN', 'JUL', 'AUG', 'SEP', 'OCT', 'NOV', 'DEC'];
                return `${day.padStart(2, '0')}-${monthNames[parseInt(month) - 1] || ''}`;
            } else if (period === 'week') {
                return dateStr; // Already formatted as W23-23
            } else {
                return dateStr; // Already formatted as Jan-23
            }
        }

        // Chart initialization
        function initializeCharts() {
            const commonOptions = {
                responsive: true,
                maintainAspectRatio: false,
                plugins: {
                    legend: { display: false },
                    tooltip: {
                        backgroundColor: 'white',
                        borderWidth: 2,
                        padding: 14,
                        displayColors: false,
                        titleFont: { size: 12, weight: '600', family: '-apple-system, BlinkMacSystemFont, "Segoe UI", Roboto' },
                        bodyFont: { size: 14, weight: '700', family: '-apple-system, BlinkMacSystemFont, "Segoe UI", Roboto' },
                        cornerRadius: 8,
                        caretSize: 6,
                        titleColor: '#64748b',
                        bodyColor: '#1e293b'
                    }
                },
                scales: {
                    y: {
                        display: true,
                        position: 'right',
                        grid: { 
                            color: 'rgba(148, 163, 184, 0.08)',
                            lineWidth: 1,
                            drawBorder: false,
                            drawTicks: false
                        },
                        border: { display: false },
                        ticks: {
                            font: { size: 10, weight: '500', family: '-apple-system, BlinkMacSystemFont, "Segoe UI", Roboto' },
                            color: '#94a3b8',
                            padding: 8,
                            maxTicksLimit: 8,
                            callback: value => {
                                if (value === 0) return '₹0';
                                if (Math.abs(value) >= 100000) return `₹${Math.round(value / 100000)}L`;
                                if (Math.abs(value) >= 1000) return `₹${Math.round(value / 1000)}K`;
                                return `₹${Math.round(value)}`;
                            }
                        }
                    },
                    x: {
                        display: true,
                        grid: { display: false, drawBorder: false },
                        border: { display: false },
                        ticks: {
                            font: { size: 10, weight: '500', family: '-apple-system, BlinkMacSystemFont, "Segoe UI", Roboto' },
                            color: '#94a3b8',
                            maxTicksLimit: 10,
                            padding: 6
                        }
                    }
                },
                interaction: { intersect: false, mode: 'index' },
                elements: {
                    line: {
                        borderCapStyle: 'round',
                        borderJoinStyle: 'round'
                    }
                }
            };

            // Cumulative P&L Chart
            charts.pnl = new Chart(elements.pnlChart, {
                type: 'line',
                data: { labels: [], datasets: [{ data: [], borderColor: '#059669', backgroundColor: createGradient(elements.pnlChart, '#059669'), borderWidth: 3, pointRadius: 0, pointHoverRadius: 6, pointHoverBackgroundColor: '#059669', pointHoverBorderColor: '#fff', pointHoverBorderWidth: 2, fill: true, tension: 0.4 }] },
                options: {
                    ...commonOptions,
                    plugins: {
                        ...commonOptions.plugins,
                        tooltip: {
                            ...commonOptions.plugins.tooltip,
                            borderColor: '#059669',
                            callbacks: {
                                title: ctx => ctx[0].label,
                                label: ctx => `₹${formatIndianNumber(ctx.parsed.y, 2)}`
                            }
                        }
                    }
                }
            });

            // Drawdown Chart
            charts.drawdown = new Chart(elements.drawdownChart, {
                type: 'line',
                data: { labels: [], datasets: [{ data: [], borderColor: '#dc2626', backgroundColor: createGradient(elements.drawdownChart, '#dc2626'), borderWidth: 3, pointRadius: 0, pointHoverRadius: 6, pointHoverBackgroundColor: '#dc2626', pointHoverBorderColor: '#fff', pointHoverBorderWidth: 2, fill: true, tension: 0.4 }] },
                options: {
                    ...commonOptions,
                    plugins: {
                        ...commonOptions.plugins,
                        tooltip: {
                            ...commonOptions.plugins.tooltip,
                            borderColor: '#dc2626',
                            callbacks: {
                                title: ctx => ctx[0].label,
                                label: ctx => `₹${formatIndianNumber(ctx.parsed.y, 2)}`
                            }
                        }
                    }
                }
            });

            // Periodic Returns Chart
            charts.pnlbar = new Chart(elements.pnlBarChart, {
                type: 'bar',
                data: { 
                    labels: [], 
                    datasets: [{ 
                        data: [], 
                        backgroundColor: [],
                        borderWidth: 0,
                        borderRadius: 6,
                        barPercentage: 0.7,
                        categoryPercentage: 0.8
                    }] 
                },
                options: {
                    ...commonOptions,
                    plugins: {
                        ...commonOptions.plugins,
                        tooltip: {
                            ...commonOptions.plugins.tooltip,
                            borderColor: '#059669',
                            callbacks: {
                                title: ctx => ctx[0].label,
                                label: ctx => `₹${formatIndianNumber(ctx.parsed.y, 2)}`
                            }
                        }
                    },
                    scales: {
                        ...commonOptions.scales,
                        y: {
                            ...commonOptions.scales.y,
                            beginAtZero: true,
                            grace: '5%'
                        }
                    }
                },
                plugins: [{
                    id: 'barLabels',
                    afterDatasetsDraw(chart) {
                        // Only show labels in month view
                        if (activePeriods.pnlbar !== 'month') {
                            return;
                        }
                        
                        const { ctx, data } = chart;
                        chart.getDatasetMeta(0).data.forEach((bar, index) => {
                            const value = data.datasets[0].data[index];
                            
                            // Format value based on display type
                            let label;
                            if (displayTypes.pnlbar === 'percentage') {
                                label = value.toFixed(2) + '%';
                            } else {
                                const absValue = Math.abs(value);
                                if (absValue >= 100000) {
                                    label = `₹${(value / 100000).toFixed(1)}L`;
                                } else if (absValue >= 1000) {
                                    label = `₹${(value / 1000).toFixed(1)}K`;
                                } else {
                                    label = `₹${Math.round(value)}`;
                                }
                            }
                            
                            // Style
                            ctx.save();
                            ctx.font = '600 11px -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto';
                            ctx.fillStyle = value >= 0 ? '#059669' : '#dc2626';
                            ctx.textAlign = 'center';
                            
                            // Position above bar for positive, below bar for negative
                            const x = bar.x;
                            let y;
                            if (value >= 0) {
                                ctx.textBaseline = 'bottom';
                                y = bar.y - 5; // Above the bar
                            } else {
                                ctx.textBaseline = 'top';
                                y = bar.y + 5; // Below the bar (bar.y is at top of negative bar)
                            }
                            
                            ctx.fillText(label, x, y);
                            ctx.restore();
                        });
                    }
                }]
            });


            // Strategy Comparison Chart
            charts.compare = new Chart(elements.compareChart, {
                type: 'line',
                data: { 
                    labels: [], 
                    datasets: [] // Will be populated dynamically based on strategies
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: { 
                            display: true,
                            position: 'top',
                            align: 'start',
                            onClick: (e, legendItem, legend) => {
                                const index = legendItem.datasetIndex;
                                const chart = legend.chart;
                                const meta = chart.getDatasetMeta(index);
                                
                                // Toggle visibility - true = hidden, false/null = visible
                                if (meta.hidden === true) {
                                    meta.hidden = null; // Show
                                } else {
                                    meta.hidden = true; // Hide
                                }
                                
                                // Update chart
                                chart.update();
                            },
                            labels: {
                                boxWidth: 20,
                                boxHeight: 10,
                                padding: 8,
                                font: { 
                                    size: 10, 
                                    weight: '600',
                                    family: '-apple-system, BlinkMacSystemFont, "Segoe UI", Roboto'
                                },
                                color: '#475569',
                                usePointStyle: false,
                                generateLabels: (chart) => {
                                    // Custom label generation with strikethrough support
                                    return chart.data.datasets.map((dataset, i) => {
                                        const meta = chart.getDatasetMeta(i);
                                        const isHidden = meta.hidden === true;
                                        
                                        return {
                                            text: dataset.label,
                                            fillStyle: isHidden ? '#cbd5e1' : dataset.borderColor,
                                            strokeStyle: isHidden ? '#cbd5e1' : dataset.borderColor,
                                            lineWidth: 0,
                                            hidden: isHidden,
                                            datasetIndex: i,
                                            lineDash: [],
                                            fontColor: isHidden ? '#cbd5e1' : '#475569',
                                            textDecoration: isHidden ? 'line-through' : 'none'
                                        };
                                    });
                                }
                            },
                            onHover: (event, legendItem) => {
                                event.native.target.style.cursor = 'pointer';
                            },
                            onLeave: (event, legendItem) => {
                                event.native.target.style.cursor = 'default';
                            }
                        },
                        tooltip: {
                            backgroundColor: 'white',
                            borderWidth: 2,
                            padding: 14,
                            displayColors: true,
                            titleFont: { 
                                size: 12, 
                                weight: '600',
                                family: '-apple-system, BlinkMacSystemFont, "Segoe UI", Roboto'
                            },
                            bodyFont: { 
                                size: 13, 
                                weight: '600',
                                family: '-apple-system, BlinkMacSystemFont, "Segoe UI", Roboto'
                            },
                            cornerRadius: 8,
                            caretSize: 6,
                            titleColor: '#64748b',
                            bodyColor: '#1e293b',
                            boxPadding: 6,
                            callbacks: {
                                title: ctx => ctx[0].label,
                                label: ctx => {
                                    const label = ctx.dataset.label; // Strategy name only
                                    const value = ctx.parsed.y;
                                    return `${label}: ₹${formatIndianNumber(value, 0)}`;
                                },
                                labelColor: ctx => ({
                                    borderColor: ctx.dataset.borderColor,
                                    backgroundColor: ctx.dataset.borderColor,
                                    borderWidth: 2,
                                    borderRadius: 2
                                })
                            }
                        }
                    },
                    scales: {
                        y: {
                            display: true,
                            position: 'right',
                            grid: { 
                                color: 'rgba(148, 163, 184, 0.08)',
                                lineWidth: 1,
                                drawBorder: false,
                                drawTicks: false
                            },
                            border: {
                                display: false
                            },
                            ticks: {
                                font: { 
                                    size: 10, 
                                    weight: '500',
                                    family: '-apple-system, BlinkMacSystemFont, "Segoe UI", Roboto' 
                                },
                                color: '#94a3b8',
                                padding: 8,
                                maxTicksLimit: 8,
                                callback: value => {
                                    if (value === 0) return '₹0';
                                    if (Math.abs(value) >= 100000) return `₹${Math.round(value / 100000)}L`;
                                    if (Math.abs(value) >= 1000) return `₹${Math.round(value / 1000)}K`;
                                    return `₹${Math.round(value)}`;
                                }
                            }
                        },
                        x: {
                            display: true,
                            grid: { 
                                display: false,
                                drawBorder: false
                            },
                            border: {
                                display: false
                            },
                            ticks: {
                                font: { 
                                    size: 10, 
                                    weight: '500',
                                    family: '-apple-system, BlinkMacSystemFont, "Segoe UI", Roboto'
                                },
                                color: '#94a3b8',
                                maxTicksLimit: 10,
                                padding: 6
                            }
                        }
                    },
                    interaction: { 
                        intersect: false, 
                        mode: 'index' 
                    },
                    elements: {
                        line: {
                            borderCapStyle: 'round',
                            borderJoinStyle: 'round'
                        }
                    }
                },
                plugins: [{
                    id: 'customLegendStrikethrough',
                    afterUpdate: (chart) => {
                        // Store legend item positions for strikethrough rendering
                        const legend = chart.legend;
                        if (legend && legend.legendHitBoxes) {
                            chart._legendHitBoxes = legend.legendHitBoxes;
                        }
                    },
                    afterDraw: (chart) => {
                        const ctx = chart.ctx;
                        const legend = chart.legend;
                        
                        if (!legend || !chart._legendHitBoxes) return;
                        
                        ctx.save();
                        
                        // Iterate through each dataset
                        chart.data.datasets.forEach((dataset, i) => {
                            const meta = chart.getDatasetMeta(i);
                            const isHidden = meta.hidden === true;
                            
                            if (isHidden) {
                                const hitBox = chart._legendHitBoxes[i];
                                if (!hitBox) return;
                                
                                // Calculate text position
                                const textX = hitBox.left + hitBox.width - (hitBox.width - legend.options.labels.boxWidth - legend.options.labels.padding);
                                const textY = hitBox.top + (hitBox.height / 2);
                                
                                // Measure text width
                                ctx.font = '600 10px -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto';
                                const textWidth = ctx.measureText(dataset.label).width;
                                
                                // Draw strikethrough line
                                ctx.strokeStyle = '#94a3b8';
                                ctx.lineWidth = 1.3;
                                ctx.beginPath();
                                ctx.moveTo(textX, textY);
                                ctx.lineTo(textX + textWidth, textY);
                                ctx.stroke();
                            }
                        });
                        
                        ctx.restore();
                    }
                }]
            });
        }

        function createGradient(canvas, color) {
            const ctx = canvas.getContext('2d');
            const gradient = ctx.createLinearGradient(0, 0, 0, 400);
            
            if (color === '#059669' || color === '#10b981') {
                gradient.addColorStop(0, 'rgba(5, 150, 105, 0.15)');
                gradient.addColorStop(1, 'rgba(5, 150, 105, 0)');
            } else if (color === '#dc2626') {
                gradient.addColorStop(0, 'rgba(220, 38, 38, 0.15)');
                gradient.addColorStop(1, 'rgba(220, 38, 38, 0)');
            }
            
            return gradient;
        }

        // Update functions
        function updateAllCharts() {
            if (allTrades.length === 0) {
                return;
            }
            
            // Auto-select best period for PNL bar chart and Strategy Comparison
            autoSelectPnlBarPeriod();
            autoSelectComparePeriod();
            
            updateChart('pnl');
            updateChart('drawdown');
            updateChart('pnlbar');
            updateChart('compare');
        }
        
        function autoSelectPnlBarPeriod() {
            // Try month first
            const monthData = aggregateByPeriod(allTrades, 'month');
            if (monthData.length >= 4) {
                activePeriods.pnlbar = 'month';
                updatePeriodButtons('pnlbar', 'month');
                return;
            }
            
            // Try week if month has < 4 candles
            const weekData = aggregateByPeriod(allTrades, 'week');
            if (weekData.length >= 4) {
                activePeriods.pnlbar = 'week';
                updatePeriodButtons('pnlbar', 'week');
                return;
            }
            
            // Default to day if week also has < 4 candles
            activePeriods.pnlbar = 'day';
            updatePeriodButtons('pnlbar', 'day');
        }
        
        function autoSelectComparePeriod() {
            // Try month first
            const monthData = aggregateByPeriod(allTrades, 'month');
            if (monthData.length >= 4) {
                activePeriods.compare = 'month';
                updatePeriodButtons('compare', 'month');
                return;
            }
            
            // Try week if month has < 4 candles
            const weekData = aggregateByPeriod(allTrades, 'week');
            if (weekData.length >= 4) {
                activePeriods.compare = 'week';
                updatePeriodButtons('compare', 'week');
                return;
            }
            
            // Default to day if week also has < 4 candles
            activePeriods.compare = 'day';
            updatePeriodButtons('compare', 'day');
        }
        
        function updatePeriodButtons(chartType, period) {
            // Update button states
            const buttons = document.querySelectorAll(`[data-chart="${chartType}"][data-period]`);
            buttons.forEach(btn => {
                if (btn.dataset.period === period) {
                    btn.classList.add('active');
                } else {
                    btn.classList.remove('active');
                }
            });
        }

        function updateChart(chartType) {
            if (!charts[chartType]) {
                return;
            }
            
            if (allTrades.length === 0) {
                charts[chartType].data.labels = [];
                charts[chartType].data.datasets.forEach(dataset => {
                    dataset.data = [];
                });
                charts[chartType].update('none');
                return;
            }
            
            const period = activePeriods[chartType];
            const aggregatedData = aggregateByPeriod(allTrades, period);
            
            const labels = aggregatedData.map(d => formatLabel(d.date, period));
            
            if (chartType === 'pnl') {
                const displayType = displayTypes.pnl || 'value';
                let data;
                
                if (displayType === 'percentage') {
                    // Calculate NET PNL% = (cumPnl / startingCapital) * 100
                    // Use starting capital for all periods (Day/Week/Month)
                    
                    let startingCapital = 0;
                    if (allTrades.length > 0) {
                        const brokerDates = {};
                        
                        allTrades.forEach(trade => {
                            if (trade.strategyDetails) {
                                Object.keys(trade.strategyDetails).forEach(strategyName => {
                                    const cleanName = strategyName.replace(/\s+/g, '');
                                    const brokerMatch = cleanName.match(/^(.+?)PRO/);
                                    
                                    if (brokerMatch) {
                                        const brokerCode = brokerMatch[1];
                                        const margin = trade.strategyDetails[strategyName]?.margin || 0;
                                        
                                        if (margin > 0) {
                                            if (!brokerDates[brokerCode]) {
                                                brokerDates[brokerCode] = [];
                                            }
                                            if (!brokerDates[brokerCode].includes(trade.date)) {
                                                brokerDates[brokerCode].push(trade.date);
                                            }
                                        }
                                    }
                                });
                            }
                        });
                        
                        Object.keys(brokerDates).forEach(brokerCode => {
                            const dates = brokerDates[brokerCode].sort((a, b) => compareDates(a, b));
                            const brokerFirstDate = dates[0];
                            
                            const brokerMargins = [];
                            allTrades.filter(t => t.date === brokerFirstDate).forEach(trade => {
                                if (trade.strategyDetails) {
                                    Object.keys(trade.strategyDetails).forEach(strategyName => {
                                        const cleanName = strategyName.replace(/\s+/g, '');
                                        const brokerMatch = cleanName.match(/^(.+?)PRO/);
                                        
                                        if (brokerMatch && brokerMatch[1] === brokerCode) {
                                            const margin = trade.strategyDetails[strategyName]?.margin || 0;
                                            if (margin > 0) {
                                                brokerMargins.push(margin);
                                            }
                                        }
                                    });
                                }
                            });
                            
                            if (brokerMargins.length > 0) {
                                startingCapital += Math.max(...brokerMargins);
                            }
                        });
                    }
                    
                    console.log('Cumulative P&L - Starting Capital:', startingCapital);
                    
                    data = aggregatedData.map(d => {
                        if (startingCapital === 0) return 0;
                        return ((d.cumPnl / startingCapital) * 100);
                    });
                } else {
                    data = aggregatedData.map(d => d.cumPnl);
                }
                
                charts.pnl.data.labels = labels;
                charts.pnl.data.datasets[0].data = data;
                
                // Update color based on final value
                const isProfit = data[data.length - 1] >= 0;
                charts.pnl.data.datasets[0].borderColor = isProfit ? '#059669' : '#dc2626';
                charts.pnl.data.datasets[0].backgroundColor = createGradient(elements.pnlChart, isProfit ? '#059669' : '#dc2626');
                charts.pnl.data.datasets[0].pointHoverBackgroundColor = isProfit ? '#059669' : '#dc2626';
                
                // Update y-axis to show % or value
                charts.pnl.options.scales.y.ticks.callback = function(value) {
                    if (displayTypes.pnl === 'percentage') {
                        return value.toFixed(2) + '%';
                    }
                    return '₹' + formatIndianNumber(value);
                };
                
                // Update tooltip callback
                charts.pnl.options.plugins.tooltip.callbacks.label = function(ctx) {
                    if (displayTypes.pnl === 'percentage') {
                        return ctx.parsed.y.toFixed(2) + '%';
                    }
                    return `₹${formatIndianNumber(ctx.parsed.y, 2)}`;
                };
                
                charts.pnl.update('none');
            } else if (chartType === 'drawdown') {
                const displayType = displayTypes.drawdown || 'value';
                let data;
                
                if (displayType === 'percentage') {
                    // Calculate Drawdown% = (drawdown / peakMargin) * 100
                    // peakMargin = startingCapital + peak cumPnl at that point
                    
                    // Get starting capital
                    let startingCapital = 0;
                    if (allTrades.length > 0) {
                        const brokerDates = {};
                        
                        allTrades.forEach(trade => {
                            if (trade.strategyDetails) {
                                Object.keys(trade.strategyDetails).forEach(strategyName => {
                                    const cleanName = strategyName.replace(/\s+/g, '');
                                    const brokerMatch = cleanName.match(/^(.+?)PRO/);
                                    
                                    if (brokerMatch) {
                                        const brokerCode = brokerMatch[1];
                                        const margin = trade.strategyDetails[strategyName]?.margin || 0;
                                        
                                        if (margin > 0) {
                                            if (!brokerDates[brokerCode]) {
                                                brokerDates[brokerCode] = [];
                                            }
                                            if (!brokerDates[brokerCode].includes(trade.date)) {
                                                brokerDates[brokerCode].push(trade.date);
                                            }
                                        }
                                    }
                                });
                            }
                        });
                        
                        Object.keys(brokerDates).forEach(brokerCode => {
                            const dates = brokerDates[brokerCode].sort((a, b) => compareDates(a, b));
                            const brokerFirstDate = dates[0];
                            
                            const brokerMargins = [];
                            allTrades.filter(t => t.date === brokerFirstDate).forEach(trade => {
                                if (trade.strategyDetails) {
                                    Object.keys(trade.strategyDetails).forEach(strategyName => {
                                        const cleanName = strategyName.replace(/\s+/g, '');
                                        const brokerMatch = cleanName.match(/^(.+?)PRO/);
                                        
                                        if (brokerMatch && brokerMatch[1] === brokerCode) {
                                            const margin = trade.strategyDetails[strategyName]?.margin || 0;
                                            if (margin > 0) {
                                                brokerMargins.push(margin);
                                            }
                                        }
                                    });
                                }
                            });
                            
                            if (brokerMargins.length > 0) {
                                startingCapital += Math.max(...brokerMargins);
                            }
                        });
                    }
                    
                    console.log('Drawdown - Starting Capital:', startingCapital);
                    
                    data = aggregatedData.map(d => {
                        // peakMargin = startingCapital + peak cumPnl
                        const peakMargin = startingCapital + d.peak;
                        if (peakMargin === 0) return 0;
                        return ((d.drawdown / peakMargin) * 100);
                    });
                } else {
                    data = aggregatedData.map(d => d.drawdown);
                }
                
                charts.drawdown.data.labels = labels;
                charts.drawdown.data.datasets[0].data = data;
                
                // Update y-axis to show % or value
                charts.drawdown.options.scales.y.ticks.callback = function(value) {
                    if (displayTypes.drawdown === 'percentage') {
                        return value.toFixed(2) + '%';
                    }
                    return '₹' + formatIndianNumber(value);
                };
                
                // Update tooltip callback
                charts.drawdown.options.plugins.tooltip.callbacks.label = function(ctx) {
                    if (displayTypes.drawdown === 'percentage') {
                        return ctx.parsed.y.toFixed(2) + '%';
                    }
                    return `₹${formatIndianNumber(ctx.parsed.y, 2)}`;
                };
                
                charts.drawdown.update('none');
            } else if (chartType === 'pnlbar') {
                const displayType = displayTypes.pnlbar || 'value';
                let profitData;
                
                if (displayType === 'percentage') {
                    const period = activePeriods[chartType];
                    console.log('=== Percentage Calculation ===');
                    console.log('Period:', period);
                    console.log('First 3 items:', aggregatedData.slice(0, 3).map(d => ({
                        date: d.date,
                        cumMargin: d.cumMargin,
                        periodProfit: d.periodProfit,
                        cumPnl: d.cumPnl,
                        percent: d.cumMargin > 0 ? ((d.periodProfit / d.cumMargin) * 100).toFixed(2) + '%' : '0%'
                    })));
                    
                    if (period === 'day') {
                        // Build month boundaries
                        const monthLastDayMargins = new Map();
                        let currentMonth = null;
                        let currentMonthDays = [];
                        let firstMonthStartMargin = 0;
                        
                        aggregatedData.forEach((d, index) => {
                            const dateParts = d.date.split('/');
                            const month = dateParts.length >= 2 ? (dateParts[1] + '/' + dateParts[2]) : d.date;
                            
                            if (month !== currentMonth) {
                                if (currentMonth !== null && currentMonthDays.length > 0) {
                                    const lastDay = currentMonthDays[currentMonthDays.length - 1];
                                    monthLastDayMargins.set(currentMonth, lastDay.cumMargin || 0);
                                }
                                currentMonth = month;
                                currentMonthDays = [];
                                
                                // Store first month's starting margin
                                if (index === 0) {
                                    firstMonthStartMargin = d.cumMargin - (d.cumPnl || 0);
                                }
                            }
                            
                            currentMonthDays.push(d);
                            
                            if (index === aggregatedData.length - 1 && currentMonthDays.length > 0) {
                                const lastDay = currentMonthDays[currentMonthDays.length - 1];
                                monthLastDayMargins.set(currentMonth, lastDay.cumMargin || 0);
                            }
                        });
                        
                        // Calculate percentages - matching Strategy Performance % logic exactly
                        // First day of month: use month's starting margin
                        // Subsequent days: use previous day's cumMargin
                        
                        currentMonth = null; // Reset the existing variable
                        let monthStartMargin = 0;
                        
                        profitData = aggregatedData.map((d, index) => {
                            const dateParts = d.date.split('/');
                            const month = dateParts.length >= 2 ? (dateParts[1] + '/' + dateParts[2]) : d.date;
                            
                            // Check if this is the first day of a new month
                            const isFirstDayOfMonth = (month !== currentMonth);
                            
                            if (isFirstDayOfMonth) {
                                // First day of month: use starting margin
                                currentMonth = month;
                                if (index === 0) {
                                    // Very first day in dataset: starting capital
                                    monthStartMargin = (d.cumMargin || 0) - (d.cumPnl || 0);
                                } else {
                                    // First day of subsequent month: use previous day's cumMargin (which is previous month's ending)
                                    const prevDay = aggregatedData[index - 1];
                                    monthStartMargin = prevDay.cumMargin || 0;
                                }
                                
                                if (monthStartMargin === 0) {
                                    return 0;
                                } else {
                                    return ((d.periodProfit || 0) / monthStartMargin) * 100;
                                }
                            } else {
                                // Subsequent days in month: use previous day's cumMargin
                                const prevDay = aggregatedData[index - 1];
                                const previousDayMargin = prevDay.cumMargin || 0;
                                
                                if (previousDayMargin === 0) {
                                    return 0;
                                } else {
                                    return ((d.periodProfit || 0) / previousDayMargin) * 100;
                                }
                            }
                        });
                    } else if (period === 'week' || period === 'month') {
                        profitData = aggregatedData.map((d, index) => {
                            if (index === 0) {
                                // First period: use starting capital = cumMargin - cumPnl
                                const startingCapital = (d.cumMargin || 0) - (d.cumPnl || 0);
                                if (startingCapital === 0) {
                                    return 0;
                                } else {
                                    return ((d.periodProfit || 0) / startingCapital) * 100;
                                }
                            } else {
                                // Subsequent periods: use previous period's cumMargin
                                const prevPeriod = aggregatedData[index - 1];
                                const previousMargin = prevPeriod.cumMargin || 0;
                                if (previousMargin === 0) {
                                    return 0;
                                } else {
                                    return ((d.periodProfit || 0) / previousMargin) * 100;
                                }
                            }
                        });
                    }
                } else {
                    profitData = aggregatedData.map(d => d.periodProfit || 0);
                }
                
                // Create color array - green for positive, red for negative
                const colors = profitData.map(val => val >= 0 ? '#10b981' : '#ef4444');
                
                charts.pnlbar.data.labels = labels;
                charts.pnlbar.data.datasets[0].data = profitData;
                charts.pnlbar.data.datasets[0].backgroundColor = colors;
                
                // Update y-axis to show % or value
                charts.pnlbar.options.scales.y.ticks.callback = function(value) {
                    if (displayTypes.pnlbar === 'percentage') {
                        return value.toFixed(2) + '%';
                    }
                    return '₹' + formatIndianNumber(value);
                };
                
                // Update tooltip callback
                charts.pnlbar.options.plugins.tooltip.callbacks.label = function(ctx) {
                    if (displayTypes.pnlbar === 'percentage') {
                        return ctx.parsed.y.toFixed(2) + '%';
                    }
                    return `₹${formatIndianNumber(ctx.parsed.y, 2)}`;
                };
                
                charts.pnlbar.update('none');
            } else if (chartType === 'compare') {
                // Use strategy aggregation
                const strategyData = aggregateByStrategyAndPeriod(allTrades, period);
                const labels = strategyData.labels.map(d => formatLabel(d, period));
                
                // Premium professional color palette with better differentiation
                const premiumColors = [
                    { solid: '#2563eb', gradient: 'rgba(37, 99, 235, 0.1)' },   // Royal Blue
                    { solid: '#059669', gradient: 'rgba(5, 150, 105, 0.1)' },   // Emerald
                    { solid: '#dc2626', gradient: 'rgba(220, 38, 38, 0.1)' },   // Crimson
                    { solid: '#7c3aed', gradient: 'rgba(124, 58, 237, 0.1)' },  // Purple
                    { solid: '#ea580c', gradient: 'rgba(234, 88, 12, 0.1)' },   // Orange
                    { solid: '#0891b2', gradient: 'rgba(8, 145, 178, 0.1)' },   // Cyan
                    { solid: '#d946ef', gradient: 'rgba(217, 70, 239, 0.1)' },  // Magenta
                    { solid: '#65a30d', gradient: 'rgba(101, 163, 13, 0.1)' }   // Lime
                ];
                
                // Line style variations for better distinction
                const lineStyles = [
                    [],           // Solid
                    [5, 5],       // Dashed
                    [2, 3],       // Dotted
                    [10, 5, 2, 5], // Dash-dot
                    [],           // Solid
                    [8, 4],       // Long dash
                    [3, 3],       // Short dash
                    [15, 3, 3, 3] // Long dash-dot
                ];
                
                // Calculate final PnL for each strategy to rank them
                const strategyPerformance = [];
                for (const [strategyName, data] of Object.entries(strategyData.strategies)) {
                    const finalPnl = data[data.length - 1] || 0;
                    strategyPerformance.push({ name: strategyName, pnl: finalPnl, data: data });
                }
                
                // Sort by performance (descending)
                strategyPerformance.sort((a, b) => b.pnl - a.pnl);
                
                // Create datasets with enhanced styling
                const datasets = [];
                
                strategyPerformance.forEach((strategy, index) => {
                    const colorSet = premiumColors[index % premiumColors.length];
                    const lineStyle = lineStyles[index % lineStyles.length];
                    const isTopPerformer = index < 3; // Top 3 strategies
                    
                    // Create gradient
                    const ctx = elements.compareChart.getContext('2d');
                    const gradient = ctx.createLinearGradient(0, 0, 0, 400);
                    gradient.addColorStop(0, colorSet.gradient.replace('0.1', isTopPerformer ? '0.15' : '0.08'));
                    gradient.addColorStop(1, 'rgba(255, 255, 255, 0)');
                    
                    // spanGaps: false means null values create gaps in the line
                    // Day view: no nulls, line continues (no gaps)
                    // Week/Month view: nulls for missing periods, line stops (gaps shown)
                    datasets.push({
                        label: strategy.name, // Only strategy name, no PnL or indicators
                        data: strategy.data,
                        borderColor: colorSet.solid,
                        backgroundColor: gradient,
                        borderWidth: isTopPerformer ? 3 : 2.5,
                        borderDash: lineStyle,
                        pointRadius: 0,
                        pointHoverRadius: 6,
                        pointHoverBackgroundColor: colorSet.solid,
                        pointHoverBorderColor: '#fff',
                        pointHoverBorderWidth: 2,
                        fill: true,
                        tension: 0.4,
                        spanGaps: false, // Don't connect lines across gaps (null values)
                        order: isTopPerformer ? 0 : 1 // Top performers drawn last (on top)
                    });
                });
                
                charts.compare.data.labels = labels;
                charts.compare.data.datasets = datasets;
                
                // Update chart options for professional look
                charts.compare.options.plugins.legend.labels.font.size = 10;
                charts.compare.options.plugins.legend.labels.padding = 8;
                charts.compare.options.plugins.legend.labels.boxWidth = 20;
                charts.compare.options.plugins.legend.labels.boxHeight = 10;
                
                charts.compare.update('none');
            }
        }
    </script>
</body>
</html>
