<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Chart Analysis</title>
    <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.0/dist/chart.umd.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-datalabels@2.2.0/dist/chartjs-plugin-datalabels.min.js"></script>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        html, body { width: 100%; height: 100%; overflow: hidden; }
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            background: #f8fafc;
            color: #1e293b;
        }
        .main-content {
            overflow-y: auto;
            overflow-x: hidden;
            padding: 20px 32px 32px 32px;
            background: #f8fafc;
            height: 100vh;
            width: 100%;
        }
        .page-header { margin-bottom: 20px; }
        .page-title { font-size: 20px; font-weight: 700; color: #111827; margin-bottom: 4px; letter-spacing: -0.5px; }
        .page-subtitle { font-size: 12px; color: #6b7280; font-weight: 400; }
        
        /* Charts Grid */
        .charts-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            height: calc(100vh - 140px);
        }
        
        .chart-card {
            background: white;
            border-radius: 12px;
            padding: 20px;
            box-shadow: 0 1px 3px rgba(0,0,0,0.06), 0 1px 2px rgba(0,0,0,0.04);
            border: 1px solid #f1f5f9;
            display: flex;
            flex-direction: column;
            transition: box-shadow 0.2s ease;
            overflow: hidden;
        }
        
        .chart-card:hover { 
            box-shadow: 0 4px 6px rgba(0,0,0,0.07), 0 2px 4px rgba(0,0,0,0.05); 
        }
        
        .chart-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 16px;
        }
        
        .chart-title {
            font-size: 14px;
            font-weight: 600;
            color: #374151;
            letter-spacing: 0.3px;
        }
        
        .chart-toggles {
            display: flex;
            gap: 6px;
            background: #f1f5f9;
            padding: 3px;
            border-radius: 8px;
        }
        
        .chart-controls {
            display: flex;
            gap: 8px;
            align-items: center;
        }
        
        .toggle-btn {
            padding: 6px 12px;
            font-size: 11px;
            font-weight: 600;
            color: #64748b;
            background: transparent;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.2s ease;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }
        
        .toggle-btn:hover {
            color: #475569;
        }
        
        .toggle-btn.active {
            background: white;
            color: #1e40af;
            box-shadow: 0 1px 3px rgba(0,0,0,0.1);
        }
        
        .month-navigation {
            display: flex;
            gap: 8px;
            align-items: center;
            background: #f1f5f9;
            padding: 4px 8px;
            border-radius: 8px;
        }
        
        .nav-btn {
            padding: 6px 10px;
            font-size: 11px;
            font-weight: 600;
            color: #475569;
            background: white;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.2s ease;
            box-shadow: 0 1px 2px rgba(0,0,0,0.05);
        }
        
        .nav-btn:hover {
            background: #f8fafc;
            color: #1e40af;
        }
        
        .nav-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }
        
        .current-month {
            font-size: 12px;
            font-weight: 600;
            color: #1e293b;
            padding: 0 8px;
            min-width: 80px;
            text-align: center;
        }
        
        .chart-container {
            flex: 1;
            position: relative;
            min-height: 0;
        }
        
        .chart-container canvas {
            width: 100% !important;
            height: 100% !important;
        }
        
        /* Loading State */
        .loading-state {
            display: none;
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            z-index: 10;
        }
        
        .loading-state.active {
            display: block;
        }
        
        .loading-spinner {
            width: 40px;
            height: 40px;
            border: 3px solid #e5e7eb;
            border-top: 3px solid #1e40af;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin: 0 auto 12px;
        }
        
        .loading-message {
            color: #64748b;
            font-size: 13px;
            font-weight: 500;
        }
        
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
    </style>
</head>
<body>
    <div class="main-content">
        <div class="page-header">
            <div class="page-title">Advanced Chart Analysis</div>
            <div class="page-subtitle">Comprehensive performance visualization across multiple metrics</div>
        </div>
        
        <div class="charts-grid">
            <!-- Cumulative P&L Chart -->
            <div class="chart-card">
                <div class="chart-header">
                    <div class="chart-title">Cumulative P&L</div>
                    <div class="chart-controls">
                        <div class="chart-toggles">
                            <button class="toggle-btn active" data-chart="pnl" data-type="value">Value</button>
                            <button class="toggle-btn" data-chart="pnl" data-type="percentage">%</button>
                        </div>
                        <div class="chart-toggles">
                            <button class="toggle-btn active" data-chart="pnl" data-period="day">Day</button>
                            <button class="toggle-btn" data-chart="pnl" data-period="week">Week</button>
                            <button class="toggle-btn" data-chart="pnl" data-period="month">Month</button>
                        </div>
                    </div>
                </div>
                <div class="chart-container">
                    <canvas id="pnlChart"></canvas>
                </div>
            </div>
            
            <!-- Drawdown Chart -->
            <div class="chart-card">
                <div class="chart-header">
                    <div class="chart-title">Drawdown</div>
                    <div class="chart-controls">
                        <div class="chart-toggles">
                            <button class="toggle-btn active" data-chart="drawdown" data-type="value">Value</button>
                            <button class="toggle-btn" data-chart="drawdown" data-type="percentage">%</button>
                        </div>
                        <div class="chart-toggles">
                            <button class="toggle-btn active" data-chart="drawdown" data-period="day">Day</button>
                            <button class="toggle-btn" data-chart="drawdown" data-period="week">Week</button>
                            <button class="toggle-btn" data-chart="drawdown" data-period="month">Month</button>
                        </div>
                    </div>
                </div>
                <div class="chart-container">
                    <canvas id="drawdownChart"></canvas>
                </div>
            </div>
            
            <!-- Periodic Returns Chart -->
            <div class="chart-card">
                <div class="chart-header">
                    <div class="chart-title">Periodic Returns</div>
                    <div class="chart-controls">
                        <div class="chart-toggles">
                            <button class="toggle-btn" id="showPnlBarValues">Show</button>
                            <button class="toggle-btn active" id="hidePnlBarValues">Hide</button>
                        </div>
                        <div class="chart-toggles">
                            <button class="toggle-btn active" data-chart="pnlbar" data-type="value">Value</button>
                            <button class="toggle-btn" data-chart="pnlbar" data-type="percentage">%</button>
                        </div>
                        <div class="chart-toggles">
                            <button class="toggle-btn" data-chart="pnlbar" data-period="day">Day</button>
                            <button class="toggle-btn" data-chart="pnlbar" data-period="week">Week</button>
                            <button class="toggle-btn active" data-chart="pnlbar" data-period="month">Month</button>
                        </div>
                    </div>
                </div>
                <div class="chart-container">
                    <canvas id="pnlBarChart"></canvas>
                </div>
            </div>
            
            <!-- Breakdown (Waterfall) -->
            <div class="chart-card">
                <div class="chart-header">
                    <div class="chart-title">Breakdown</div>
                    <div class="chart-controls">
                        <div class="chart-toggles">
                            <button class="toggle-btn" id="showWaterfallValues">Show</button>
                            <button class="toggle-btn active" id="hideWaterfallValues">Hide</button>
                        </div>
                        <div class="chart-toggles">
                            <button class="toggle-btn active" data-chart="waterfall" data-type="value">Value</button>
                            <button class="toggle-btn" data-chart="waterfall" data-type="percentage">%</button>
                        </div>
                        <div class="chart-toggles">
                            <button class="toggle-btn active" data-chart="waterfall" data-view="monthly">Monthly</button>
                            <button class="toggle-btn" data-chart="waterfall" data-view="overall">Overall</button>
                        </div>
                        <div class="month-navigation">
                            <button class="nav-btn" id="prevMonth">◄ Prev</button>
                            <span class="current-month" id="currentMonth">JAN-26</span>
                            <button class="nav-btn" id="nextMonth">Next ►</button>
                        </div>
                    </div>
                </div>
                <div class="chart-container">
                    <canvas id="compareChart"></canvas>
                </div>
            </div>
        </div>
        
        <div class="loading-state" id="loadingState">
            <div class="loading-spinner"></div>
            <div class="loading-message">Loading chart data...</div>
        </div>
    </div>

    <script>
        // Indian Number Formatting Function
        function formatIndianNumber(num, decimals = 0) {
            const isNegative = num < 0;
            const absNum = Math.abs(num);
            
            // Round to specified decimals
            const rounded = decimals > 0 ? absNum.toFixed(decimals) : Math.round(absNum).toString();
            const parts = rounded.split('.');
            let intPart = parts[0];
            const decPart = parts[1];
            
            // Indian formatting: x,xx,xxx
            let formatted = '';
            if (intPart.length <= 3) {
                formatted = intPart;
            } else {
                const lastThree = intPart.substring(intPart.length - 3);
                const remaining = intPart.substring(0, intPart.length - 3);
                
                // Add commas every 2 digits for remaining part
                formatted = remaining.replace(/\B(?=(\d{2})+(?!\d))/g, ',') + ',' + lastThree;
            }
            
            // Add decimal part if exists
            if (decPart) {
                formatted += '.' + decPart;
            }
            
            return (isNegative ? '-' : '') + formatted;
        }
        
        // Short Indian Number Format (5L, 50K, 2.5Cr)
        function formatIndianShort(num) {
            const isNegative = num < 0;
            const absNum = Math.abs(num);
            
            if (absNum >= 10000000) {
                // Crores
                return (isNegative ? '-' : '') + (absNum / 10000000).toFixed(1) + 'Cr';
            } else if (absNum >= 100000) {
                // Lakhs
                return (isNegative ? '-' : '') + (absNum / 100000).toFixed(1) + 'L';
            } else if (absNum >= 1000) {
                // Thousands
                return (isNegative ? '-' : '') + (absNum / 1000).toFixed(1) + 'K';
            } else {
                return (isNegative ? '-' : '') + absNum.toFixed(0);
            }
        }
        
        // Format strategy name with space before PRO
        function formatStrategyName(name) {
            // Add space before PRO if not already present
            return name.replace(/([A-Z0-9]+)(PRO\s*\d+)/i, '$1 $2').trim();
        }
        
        // Global state
        let allTrades = [];
        const charts = {
            pnl: null,
            drawdown: null,
            pnlbar: null,
            compare: null
        };
        const activePeriods = {
            pnl: 'day',
            drawdown: 'day',
            pnlbar: 'month',
            compare: 'month'
        };
        
        const displayTypes = {
            pnl: 'value',
            drawdown: 'value',
            pnlbar: 'value',
            waterfall: 'value'
        };
        
        const showValues = {
            pnlbar: false,
            waterfall: false
        };
        
        window.waterfallView = 'monthly'; // 'monthly' or 'overall'
        let currentMonthIndex = 0;
        let availableMonths = [];

        // Elements
        const elements = {
            loadingState: document.getElementById('loadingState'),
            pnlChart: document.getElementById('pnlChart'),
            drawdownChart: document.getElementById('drawdownChart'),
            pnlBarChart: document.getElementById('pnlBarChart'),
            compareChart: document.getElementById('compareChart')
        };

        // Initialize
        (function init() {
            loadStoredData();
            setupEventListeners();
            initializeCharts();
            window.addEventListener('message', handleParentMessage);
            
            // Request data from parent on load
            setTimeout(() => {
                window.parent.postMessage({ type: 'REQUEST_DATA_REFRESH' }, '*');
            }, 100);
        })();

        function setupEventListeners() {
            // Toggle button listeners
            document.querySelectorAll('.toggle-btn').forEach(btn => {
                btn.addEventListener('click', function() {
                    const chartType = this.dataset.chart;
                    const period = this.dataset.period;
                    const type = this.dataset.type;
                    const view = this.dataset.view;
                    
                    // Handle period toggle
                    if (period) {
                        // Update active state for period toggles
                        document.querySelectorAll(`.toggle-btn[data-chart="${chartType}"][data-period]`).forEach(b => {
                            b.classList.remove('active');
                        });
                        this.classList.add('active');
                        
                        // Update period and refresh chart
                        activePeriods[chartType] = period;
                        updateChart(chartType);
                    }
                    
                    // Handle display type toggle
                    if (type) {
                        // Update active state for type toggles
                        document.querySelectorAll(`.toggle-btn[data-chart="${chartType}"][data-type]`).forEach(b => {
                            b.classList.remove('active');
                        });
                        this.classList.add('active');
                        
                        // Update display type and refresh chart
                        displayTypes[chartType] = type;
                        updateChart(chartType);
                    }
                    
                    // Handle view toggle (for waterfall)
                    if (view) {
                        // Update active state for view toggles
                        document.querySelectorAll(`.toggle-btn[data-chart="${chartType}"][data-view]`).forEach(b => {
                            b.classList.remove('active');
                        });
                        this.classList.add('active');
                        
                        // Update view and refresh chart
                        if (chartType === 'waterfall') {
                            window.waterfallView = view;
                            updateChart('compare'); // compare is the chart instance for waterfall
                        }
                    }
                });
            });
            
            // Month navigation listeners
            const prevBtn = document.getElementById('prevMonth');
            const nextBtn = document.getElementById('nextMonth');
            
            if (prevBtn) {
                prevBtn.addEventListener('click', () => {
                    if (currentMonthIndex > 0) {
                        currentMonthIndex--;
                        updateMonthDisplay();
                        updateChart('compare');
                    }
                });
            }
            
            if (nextBtn) {
                nextBtn.addEventListener('click', () => {
                    if (currentMonthIndex < availableMonths.length - 1) {
                        currentMonthIndex++;
                        updateMonthDisplay();
                        updateChart('compare');
                    }
                });
            }
            
            // Show/Hide Values toggle buttons
            const showPnlBarValues = document.getElementById('showPnlBarValues');
            const hidePnlBarValues = document.getElementById('hidePnlBarValues');
            const showWaterfallValues = document.getElementById('showWaterfallValues');
            const hideWaterfallValues = document.getElementById('hideWaterfallValues');
            
            if (showPnlBarValues && hidePnlBarValues) {
                showPnlBarValues.addEventListener('click', () => {
                    showValues.pnlbar = true;
                    showPnlBarValues.classList.add('active');
                    hidePnlBarValues.classList.remove('active');
                    updateChart('pnlbar');
                });
                
                hidePnlBarValues.addEventListener('click', () => {
                    showValues.pnlbar = false;
                    hidePnlBarValues.classList.add('active');
                    showPnlBarValues.classList.remove('active');
                    updateChart('pnlbar');
                });
            }
            
            if (showWaterfallValues && hideWaterfallValues) {
                showWaterfallValues.addEventListener('click', () => {
                    showValues.waterfall = true;
                    showWaterfallValues.classList.add('active');
                    hideWaterfallValues.classList.remove('active');
                    updateChart('compare');
                });
                
                hideWaterfallValues.addEventListener('click', () => {
                    showValues.waterfall = false;
                    hideWaterfallValues.classList.add('active');
                    showWaterfallValues.classList.remove('active');
                    updateChart('compare');
                });
            }
        }
        
        function updateMonthDisplay() {
            const monthDisplay = document.getElementById('currentMonth');
            const prevBtn = document.getElementById('prevMonth');
            const nextBtn = document.getElementById('nextMonth');
            
            if (monthDisplay && availableMonths.length > 0) {
                const currentMonth = availableMonths[currentMonthIndex];
                monthDisplay.textContent = currentMonth;
            }
            
            // Enable/disable navigation buttons
            if (prevBtn) {
                prevBtn.disabled = currentMonthIndex <= 0;
            }
            if (nextBtn) {
                nextBtn.disabled = currentMonthIndex >= availableMonths.length - 1;
            }
        }

        function handleParentMessage(event) {
            const { type, data } = event.data;
            
            if (type === 'TRADES_DATA' && data) {
                allTrades = data;
                updateAllCharts();
            } else if (type === 'UPDATE_DATA' && data) {
                const tradesCount = data.tradesData ? data.tradesData.length : 0;
                allTrades = data.tradesData || [];
                updateAllCharts();
            }
        }

        function loadStoredData() {
            try {
                const stored = localStorage.getItem('dashboardData');
                if (stored) {
                    const data = JSON.parse(stored);
                    allTrades = data.tradesData || data || [];
                    if (allTrades.length > 0) {
                        updateAllCharts();
                    }
                }
            } catch (e) {
            }
        }

        // Calculate daily total margins using the exact same logic as Strategy Performance
        function calculateDailyTotalMargins(sortedTrades, allStrategiesParam) {
            const result = {};
            const tradesByDate = {};
            sortedTrades.forEach(trade => {
                const dateKey = trade.date;
                if (!tradesByDate[dateKey]) {
                    tradesByDate[dateKey] = [];
                }
                tradesByDate[dateKey].push(trade);
            });
            const sortedDates = Object.keys(tradesByDate).sort((a, b) => {
                const dateA = a.split('/').reverse().join('');
                const dateB = b.split('/').reverse().join('');
                return dateA.localeCompare(dateB);
            });
            const brokerPnlTaxByDate = {};
            sortedTrades.forEach(trade => {
                const tradeDate = trade.date;
                if (!brokerPnlTaxByDate[tradeDate]) {
                    brokerPnlTaxByDate[tradeDate] = {};
                }
                if (trade && trade.strategyPnlTax) {
                    Object.entries(trade.strategyPnlTax).forEach(([stratName, pnlTax]) => {
                        if (!stratName.startsWith('A.PRO')) {
                            const cleanName = stratName.replace(/\s+/g, '');
                            const brokerMatch = cleanName.match(/^(.+?)PRO/);
                            if (brokerMatch) {
                                const brokerCode = brokerMatch[1];
                                if (!brokerPnlTaxByDate[tradeDate][brokerCode]) {
                                    brokerPnlTaxByDate[tradeDate][brokerCode] = {};
                                }
                                if (!brokerPnlTaxByDate[tradeDate][brokerCode][stratName]) {
                                    brokerPnlTaxByDate[tradeDate][brokerCode][stratName] = 0;
                                }
                                brokerPnlTaxByDate[tradeDate][brokerCode][stratName] += pnlTax;
                            }
                        }
                    });
                }
            });
            let previousDayBrokerMaxMargins = {};
            const brokerMarginDates = {}; // Track which date each broker's margin comes from
            sortedDates.forEach((dateKey, dateIndex) => {
                const dayTrades = tradesByDate[dateKey];
                const dayBrokerMargins = {};
                dayTrades.forEach(trade => {
                    if (trade.strategyDetails) {
                        Object.entries(trade.strategyDetails).forEach(([stratName, details]) => {
                            if (!stratName.startsWith('A.PRO')) {
                                const margin = details.margin || 0, cleanName = stratName.replace(/\s+/g, '');
                                const brokerMatch = cleanName.match(/^(.+?)PRO/);
                                if (brokerMatch) {
                                    const brokerCode = brokerMatch[1];
                                    if (!dayBrokerMargins[brokerCode]) {
                                        dayBrokerMargins[brokerCode] = {};
                                    }
                                    if (!dayBrokerMargins[brokerCode][stratName] || margin > dayBrokerMargins[brokerCode][stratName]) {
                                        dayBrokerMargins[brokerCode][stratName] = margin;
                                    }
                                }
                            }
                        });
                    }
                });
                const currentDayBrokerMaxMargins = {};
                let dayTotalMargin = 0;
                const allBrokers = new Set([...Object.keys(dayBrokerMargins), ...Object.keys(previousDayBrokerMaxMargins)]);
                allBrokers.forEach(brokerCode => {
                    let brokerMaxMargin = 0;
                    let marginDate = dateKey;
                    if (dayBrokerMargins[brokerCode]) {
                        const margins = Object.values(dayBrokerMargins[brokerCode]);
                        if (margins.length > 0) {
                            brokerMaxMargin = Math.max(...margins);
                        }
                    }
                    if (brokerMaxMargin === 0 && previousDayBrokerMaxMargins[brokerCode]) {
                        brokerMaxMargin = previousDayBrokerMaxMargins[brokerCode];
                        marginDate = brokerMarginDates[brokerCode] || dateKey;
                    }
                    currentDayBrokerMaxMargins[brokerCode] = brokerMaxMargin;
                    brokerMarginDates[brokerCode] = marginDate;
                    dayTotalMargin += brokerMaxMargin;
                });
                let dayPnlTax = 0;
                allBrokers.forEach(brokerCode => {
                    const marginDate = brokerMarginDates[brokerCode];
                    const marginDateIndex = sortedDates.indexOf(marginDate);
                    for (let i = marginDateIndex; i <= dateIndex; i++) {
                        const checkDate = sortedDates[i];
                        if (brokerPnlTaxByDate[checkDate] && brokerPnlTaxByDate[checkDate][brokerCode]) {
                            Object.values(brokerPnlTaxByDate[checkDate][brokerCode]).forEach(pnlTax => {
                                dayPnlTax += pnlTax;
                            });
                        }
                    }
                });
                result[dateKey] = dayTotalMargin + dayPnlTax;
                previousDayBrokerMaxMargins = { ...currentDayBrokerMaxMargins };
            });
            return result;
        }

        // Data aggregation functions
        function aggregateByPeriod(trades, period) {
            if (!trades || trades.length === 0) {
                return [];
            }
            
            const sortedTrades = [...trades].sort((a, b) => {
                return compareDates(a.date, b.date);
            });
            
            // Calculate daily total margins using the same logic as Strategy Performance
            const dailyTotalMargins = calculateDailyTotalMargins(sortedTrades, []);
            
            const aggregated = new Map();
            
            sortedTrades.forEach((trade, idx) => {
                const key = getAggregationKey(trade.date, period);
                if (!aggregated.has(key)) {
                    aggregated.set(key, {
                        date: key,
                        profit: 0,
                        cumPnl: 0,
                        drawdown: 0,
                        peak: 0,
                        trades: [],
                        lastCumPnl: 0,
                        lastTradeIndex: -1,
                        totalMargin: 0,
                        lastMargin: 0
                    });
                }
                
                const agg = aggregated.get(key);
                agg.profit += trade.profit || 0;
                agg.trades.push(trade);
                
                // Keep track of the last trade (by index, since we sorted)
                agg.lastTradeIndex = idx;
                agg.lastCumPnl = trade.cumPnl !== undefined ? trade.cumPnl : 0;
                
                // Use pre-calculated daily total margin from Strategy Performance logic
                const tradeDate = trade.date;
                if (dailyTotalMargins[tradeDate]) {
                    agg.totalMargin = dailyTotalMargins[tradeDate];
                    agg.lastMargin = dailyTotalMargins[tradeDate];
                }
            });
            
            let result = Array.from(aggregated.values()).sort((a, b) => {
                return compareDates(a.date, b.date);
            });
            
            // For week and month views, fill in ALL periods from the first trade date to last trade date
            if ((period === 'week' || period === 'month') && result.length > 0) {
                result = fillMissingPeriods(result, period, sortedTrades[0].date, sortedTrades[sortedTrades.length - 1].date);
            }
            
            let peak = 0;
            let prevCumPnl = 0;
            let startingCapital = 0;  // Will be set from first period
            let cumulativeExpenses = 0;  // Track expenses/withdrawals (negative of margin additions)
            
            result.forEach((item, index) => {
                // Use the lastCumPnl from the last trade in this period
                if (item.trades.length > 0) {
                    if (item.lastCumPnl !== undefined) {
                        item.cumPnl = item.lastCumPnl;
                    } else {
                        item.cumPnl = prevCumPnl + item.profit;
                    }
                } else {
                    item.cumPnl = prevCumPnl;
                }
                
                // The totalMargin from trades already includes cumPnl (see calculateDailyTotalMargins line 1679)
                // So we need to extract the base margin WITHOUT cumPnl
                const totalMarginWithPnl = item.totalMargin || item.lastMargin || 0;
                
                if (index === 0) {
                    // First period: extract starting capital = totalMargin - cumPnl
                    startingCapital = totalMarginWithPnl - (item.cumPnl || 0);
                    cumulativeExpenses = 0;
                    console.log('First period - startingCapital:', startingCapital, 'totalMargin:', totalMarginWithPnl, 'cumPnl:', item.cumPnl);
                } else {
                    // Calculate expected total margin = startingCapital + cumPnl - cumulativeExpenses
                    const expectedTotalMargin = startingCapital + (item.cumPnl || 0) - cumulativeExpenses;
                    
                    // Calculate expenses for this period = expectedTotalMargin - actualTotalMargin
                    const periodExpense = expectedTotalMargin - totalMarginWithPnl;
                    cumulativeExpenses += periodExpense;
                    
                    if (index < 3 || Math.abs(periodExpense) > 1000) {
                        console.log(`Period ${item.date}: totalMargin=${totalMarginWithPnl}, cumPnl=${item.cumPnl}, expected=${expectedTotalMargin}, expense=${periodExpense}, cumExpenses=${cumulativeExpenses}`);
                    }
                }
                
                // cumMargin is simply the totalMargin (which already includes cumPnl)
                item.cumMargin = totalMarginWithPnl;
                
                // For the first period with actual trades, periodProfit should equal cumPnl
                // since there's no previous period to subtract from
                if (index === 0 && item.trades.length > 0) {
                    item.periodProfit = item.cumPnl;
                } else {
                    item.periodProfit = item.cumPnl - prevCumPnl;
                }
                
                prevCumPnl = item.cumPnl;
                
                if (item.cumPnl > peak) {
                    peak = item.cumPnl;
                }
                item.peak = peak;
                item.drawdown = item.cumPnl - peak;
            });
            
            // Filter out leading empty periods (periods with no trades at the start)
            let firstNonEmptyIndex = result.findIndex(item => item.trades.length > 0);
            if (firstNonEmptyIndex > 0) {
                result = result.slice(firstNonEmptyIndex);
                // Recalculate periodProfit for the new first period
                if (result.length > 0 && result[0].trades.length > 0) {
                    result[0].periodProfit = result[0].cumPnl;
                }
            }
            
            return result;
        }

        function fillMissingPeriods(aggregatedData, period, firstTradeDate, lastTradeDate) {
            if (aggregatedData.length === 0) return [];
            
            // Use the first and last periods from aggregated data (where trades exist)
            // not the first/last trade dates (which might be in the middle of a period)
            const firstPeriodKey = aggregatedData[0].date;
            const lastPeriodKey = aggregatedData[aggregatedData.length - 1].date;
            
            // Convert period key back to date for iteration
            const periodToDate = (periodStr) => {
                if (periodStr.startsWith('W')) {
                    // Week format: W23-23 or W23-2023 (ISO week-year format)
                    const parts = periodStr.substring(1).split('-');
                    const week = parseInt(parts[0]);
                    const year = parseInt(parts[1]);
                    const fullYear = year < 100 ? 2000 + year : year;
                    return getISOWeekDate(fullYear, week);
                } else if (periodStr.includes('-')) {
                    // Month format: Jan-23 or Jan-2023
                    const monthNames = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];
                    const parts = periodStr.split('-');
                    const monthStr = parts[0];
                    const year = parseInt(parts[1]);
                    const month = monthNames.indexOf(monthStr);
                    const fullYear = year < 100 ? 2000 + year : year;
                    return new Date(fullYear, month, 1);
                }
                return null;
            };
            
            const existingMap = new Map(aggregatedData.map(item => [item.date, item]));
            const allPeriods = [];
            
            // Generate all periods from first aggregated period to last aggregated period
            let currentDate = periodToDate(firstPeriodKey);
            const endDate = periodToDate(lastPeriodKey);
            
            if (!currentDate || !endDate) return aggregatedData;
            
            while (currentDate <= endDate) {
                // Create a dummy date string to get the period key
                const year = currentDate.getFullYear();
                const month = currentDate.getMonth() + 1;
                const day = currentDate.getDate();
                const dummyDateStr = `${day}/${month}/${year}`;
                const periodKey = getAggregationKey(dummyDateStr, period);
                
                if (existingMap.has(periodKey)) {
                    allPeriods.push(existingMap.get(periodKey));
                } else {
                    // Create empty period with no trades
                    allPeriods.push({
                        date: periodKey,
                        profit: 0,
                        cumPnl: 0,
                        drawdown: 0,
                        peak: 0,
                        trades: [],
                        lastCumPnl: 0,
                        lastTradeIndex: -1,
                        totalMargin: 0,
                        lastMargin: 0,
                        periodProfit: 0
                    });
                }
                
                // Increment by period
                if (period === 'week') {
                    currentDate.setDate(currentDate.getDate() + 7);
                } else if (period === 'month') {
                    currentDate.setMonth(currentDate.getMonth() + 1);
                }
            }
            
            return allPeriods;
        }

        function getAggregationKey(dateStr, period) {
            if (!dateStr) return '';
            
            const [day, month, year] = dateStr.split('/').map(Number);
            // Handle both 2-digit (23) and 4-digit (2023) years
            const fullYear = year < 100 ? 2000 + year : year;
            const date = new Date(fullYear, month - 1, day);
            
            if (period === 'day') {
                return dateStr; // Keep original format
            } else if (period === 'week') {
                // Get week number and the ISO week-year
                const { weekNum, weekYear } = getWeekNumberAndYear(date);
                // Format year consistently (2-digit)
                const yearSuffix = String(weekYear).slice(-2);
                return `W${weekNum}-${yearSuffix}`;
            } else if (period === 'month') {
                const monthNames = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];
                const yearSuffix = year < 100 ? String(year).padStart(2, '0') : String(year).slice(-2);
                return `${monthNames[month - 1]}-${yearSuffix}`;
            }
            
            return dateStr;
        }

        function getWeekNumber(date) {
            const result = getWeekNumberAndYear(date);
            return result.weekNum;
        }
        
        function getWeekNumberAndYear(date) {
            const d = new Date(Date.UTC(date.getFullYear(), date.getMonth(), date.getDate()));
            const dayNum = d.getUTCDay() || 7;
            d.setUTCDate(d.getUTCDate() + 4 - dayNum);
            const weekYear = d.getUTCFullYear(); // This is the ISO week-year
            const yearStart = new Date(Date.UTC(weekYear, 0, 1));
            const weekNum = Math.ceil((((d - yearStart) / 86400000) + 1) / 7);
            return { weekNum, weekYear };
        }
        
        function getISOWeekDate(year, week) {
            // Get the Thursday of week 1 (which defines week 1)
            const jan4 = new Date(Date.UTC(year, 0, 4));
            const jan4Day = jan4.getUTCDay() || 7; // Monday=1, Sunday=7
            // Get Monday of week 1
            const week1Monday = new Date(jan4);
            week1Monday.setUTCDate(jan4.getUTCDate() - jan4Day + 1);
            // Add weeks to get to target week
            const targetMonday = new Date(week1Monday);
            targetMonday.setUTCDate(week1Monday.getUTCDate() + (week - 1) * 7);
            return new Date(targetMonday.getUTCFullYear(), targetMonday.getUTCMonth(), targetMonday.getUTCDate());
        }

        function compareDates(dateStr1, dateStr2) {
            // Handle different formats
            const parseDate = (str) => {
                if (str.startsWith('W')) {
                    // Week format: W23-23 or W23-2023 (ISO week-year format)
                    const [week, year] = str.substring(1).split('-').map(Number);
                    const fullYear = year < 100 ? 2000 + year : year;
                    // Get the Monday of this ISO week
                    return getISOWeekDate(fullYear, week);
                } else if (str.includes('-') && str.length <= 10) {
                    // Month format: Jan-23 or Jan-2023
                    const monthNames = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];
                    const [monthStr, year] = str.split('-');
                    const month = monthNames.indexOf(monthStr);
                    const fullYear = parseInt(year) < 100 ? 2000 + parseInt(year) : parseInt(year);
                    return new Date(fullYear, month, 1);
                } else {
                    // Day format: 15/05/23 or 15/05/2023
                    const [day, month, year] = str.split('/').map(Number);
                    const fullYear = year < 100 ? 2000 + year : year;
                    return new Date(fullYear, month - 1, day);
                }
            };
            
            return parseDate(dateStr1) - parseDate(dateStr2);
        }

        // Aggregate trades by strategy and period for comparison chart
        function aggregateByStrategyAndPeriod(trades, period) {
            if (!trades || trades.length === 0) {
                return { labels: [], strategies: {} };
            }
            
            const sortedTrades = [...trades].sort((a, b) => {
                return compareDates(a.date, b.date);
            });
            
            // Get unique strategies
            const strategies = {};
            const periodKeys = new Set();
            
            // Group trades by strategy and period
            sortedTrades.forEach(trade => {
                const strategy = trade.strategy || 'Unknown';
                const periodKey = getAggregationKey(trade.date, period);
                
                if (!strategies[strategy]) {
                    strategies[strategy] = new Map();
                }
                
                if (!strategies[strategy].has(periodKey)) {
                    strategies[strategy].set(periodKey, {
                        date: periodKey,
                        profit: 0,
                        trades: [],
                        lastCumPnl: 0
                    });
                }
                
                const agg = strategies[strategy].get(periodKey);
                agg.profit += trade.profit || 0;
                agg.trades.push(trade);
                agg.lastCumPnl = trade.cumPnl !== undefined ? trade.cumPnl : 0;
                
                periodKeys.add(periodKey);
            });
            
            // Convert to sorted arrays and calculate cumulative values per strategy
            const sortedPeriods = Array.from(periodKeys).sort((a, b) => compareDates(a, b));
            
            const result = { labels: sortedPeriods, strategies: {} };
            
            for (const [strategyName, periodMap] of Object.entries(strategies)) {
                const strategyData = [];
                let strategyCumPnl = 0;
                
                sortedPeriods.forEach(periodKey => {
                    if (periodMap.has(periodKey)) {
                        const periodData = periodMap.get(periodKey);
                        // Add the profit from this period to strategy cumulative
                        strategyCumPnl += periodData.profit;
                        strategyData.push(strategyCumPnl);
                    } else {
                        // No trades in this period for this strategy
                        if (period === 'day') {
                            // For day view: carry forward the previous value (line continues)
                            strategyData.push(strategyCumPnl);
                        } else {
                            // For week/month view: create a gap in the line
                            strategyData.push(null);
                        }
                    }
                });
                
                result.strategies[strategyName] = strategyData;
            }
            
            return result;
        }

        function formatLabel(dateStr, period) {
            if (period === 'day') {
                const [day, month] = dateStr.split('/');
                const monthNames = ['JAN', 'FEB', 'MAR', 'APR', 'MAY', 'JUN', 'JUL', 'AUG', 'SEP', 'OCT', 'NOV', 'DEC'];
                return `${day.padStart(2, '0')}-${monthNames[parseInt(month) - 1] || ''}`;
            } else if (period === 'week') {
                return dateStr; // Already formatted as W23-23
            } else {
                return dateStr; // Already formatted as Jan-23
            }
        }

        // Chart initialization
        function initializeCharts() {
            const commonOptions = {
                responsive: true,
                maintainAspectRatio: false,
                plugins: {
                    legend: { display: false },
                    tooltip: {
                        backgroundColor: 'white',
                        borderWidth: 2,
                        padding: 14,
                        displayColors: false,
                        titleFont: { size: 12, weight: '600', family: '-apple-system, BlinkMacSystemFont, "Segoe UI", Roboto' },
                        bodyFont: { size: 14, weight: '700', family: '-apple-system, BlinkMacSystemFont, "Segoe UI", Roboto' },
                        cornerRadius: 8,
                        caretSize: 6,
                        titleColor: '#64748b',
                        bodyColor: '#1e293b'
                    }
                },
                scales: {
                    y: {
                        display: true,
                        position: 'right',
                        grid: { 
                            color: 'rgba(148, 163, 184, 0.08)',
                            lineWidth: 1,
                            drawBorder: false,
                            drawTicks: false
                        },
                        border: { display: false },
                        ticks: {
                            font: { size: 10, weight: '500', family: '-apple-system, BlinkMacSystemFont, "Segoe UI", Roboto' },
                            color: '#94a3b8',
                            padding: 8,
                            maxTicksLimit: 8,
                            callback: value => {
                                if (value === 0) return '₹0';
                                if (Math.abs(value) >= 100000) return `₹${Math.round(value / 100000)}L`;
                                if (Math.abs(value) >= 1000) return `₹${Math.round(value / 1000)}K`;
                                return `₹${Math.round(value)}`;
                            }
                        }
                    },
                    x: {
                        display: true,
                        grid: { display: false, drawBorder: false },
                        border: { display: false },
                        ticks: {
                            font: { size: 10, weight: '500', family: '-apple-system, BlinkMacSystemFont, "Segoe UI", Roboto' },
                            color: '#94a3b8',
                            maxTicksLimit: 10,
                            padding: 6
                        }
                    }
                },
                interaction: { intersect: false, mode: 'index' },
                elements: {
                    line: {
                        borderCapStyle: 'round',
                        borderJoinStyle: 'round'
                    }
                }
            };

            // Cumulative P&L Chart
            charts.pnl = new Chart(elements.pnlChart, {
                type: 'line',
                data: { labels: [], datasets: [{ data: [], borderColor: '#059669', backgroundColor: createGradient(elements.pnlChart, '#059669'), borderWidth: 3, pointRadius: 0, pointHoverRadius: 6, pointHoverBackgroundColor: '#059669', pointHoverBorderColor: '#fff', pointHoverBorderWidth: 2, fill: true, tension: 0.4 }] },
                options: {
                    ...commonOptions,
                    plugins: {
                        ...commonOptions.plugins,
                        tooltip: {
                            ...commonOptions.plugins.tooltip,
                            borderColor: '#059669',
                            callbacks: {
                                title: ctx => ctx[0].label,
                                label: ctx => `₹${formatIndianNumber(ctx.parsed.y, 2)}`
                            }
                        }
                    }
                }
            });

            // Drawdown Chart
            charts.drawdown = new Chart(elements.drawdownChart, {
                type: 'line',
                data: { labels: [], datasets: [{ data: [], borderColor: '#dc2626', backgroundColor: createGradient(elements.drawdownChart, '#dc2626'), borderWidth: 3, pointRadius: 0, pointHoverRadius: 6, pointHoverBackgroundColor: '#dc2626', pointHoverBorderColor: '#fff', pointHoverBorderWidth: 2, fill: true, tension: 0.4 }] },
                options: {
                    ...commonOptions,
                    plugins: {
                        ...commonOptions.plugins,
                        tooltip: {
                            ...commonOptions.plugins.tooltip,
                            borderColor: '#dc2626',
                            callbacks: {
                                title: ctx => ctx[0].label,
                                label: ctx => `₹${formatIndianNumber(ctx.parsed.y, 2)}`
                            }
                        }
                    }
                }
            });

            // Periodic Returns Chart
            charts.pnlbar = new Chart(elements.pnlBarChart, {
                type: 'bar',
                data: { 
                    labels: [], 
                    datasets: [{ 
                        data: [], 
                        backgroundColor: [],
                        borderWidth: 0,
                        borderRadius: 6,
                        barPercentage: 0.7,
                        categoryPercentage: 0.8
                    }] 
                },
                options: {
                    ...commonOptions,
                    plugins: {
                        ...commonOptions.plugins,
                        tooltip: {
                            ...commonOptions.plugins.tooltip,
                            borderColor: '#059669',
                            callbacks: {
                                title: ctx => ctx[0].label,
                                label: ctx => `₹${formatIndianNumber(ctx.parsed.y, 2)}`
                            }
                        }
                    },
                    scales: {
                        ...commonOptions.scales,
                        y: {
                            ...commonOptions.scales.y,
                            beginAtZero: true,
                            grace: '5%'
                        }
                    }
                },
                plugins: [{
                    id: 'barLabels',
                    afterDatasetsDraw(chart) {
                        // Only show labels if showValues.pnlbar is true
                        if (!showValues.pnlbar) {
                            return;
                        }
                        
                        const { ctx, data } = chart;
                        chart.getDatasetMeta(0).data.forEach((bar, index) => {
                            const value = data.datasets[0].data[index];
                            
                            // Format value based on display type
                            let label;
                            if (displayTypes.pnlbar === 'percentage') {
                                label = value.toFixed(2) + '%';
                            } else {
                                label = formatIndianShort(value);
                            }
                            
                            // Style
                            ctx.save();
                            ctx.font = '600 11px -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto';
                            ctx.fillStyle = value >= 0 ? '#059669' : '#c2410c';
                            ctx.textAlign = 'center';
                            
                            // Position above bar for positive, below bar for negative
                            const x = bar.x;
                            let y;
                            if (value >= 0) {
                                ctx.textBaseline = 'bottom';
                                y = bar.y - 5; // Above the bar
                            } else {
                                ctx.textBaseline = 'top';
                                y = bar.y + 5; // Below the bar (bar.y is at top of negative bar)
                            }
                            
                            ctx.fillText(label, x, y);
                            ctx.restore();
                        });
                    }
                }]
            });
            // Monthly Contribution Breakdown (Waterfall) Chart
            charts.compare = new Chart(elements.compareChart, {
                type: 'bar',
                data: { 
                    labels: [], 
                    datasets: [{
                        data: [],
                        backgroundColor: [],
                        borderWidth: 0,
                        borderRadius: 6,
                        barPercentage: 0.6,
                        categoryPercentage: 0.8,
                        // Enable floating bars
                        barThickness: 'flex'
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: { 
                            display: true,
                            position: 'bottom',
                            align: 'center',
                            labels: {
                                boxWidth: 12,
                                boxHeight: 12,
                                padding: 15,
                                font: { 
                                    size: 10, 
                                    weight: '500',
                                    family: '-apple-system, BlinkMacSystemFont, "Segoe UI", Roboto'
                                },
                                color: '#94a3b8',
                                usePointStyle: false,
                                generateLabels: (chart) => {
                                    // Create custom legend for waterfall - only show strategy names, not Start/Total
                                    const labels = chart.data.labels || [];
                                    const colors = chart.data.datasets[0].backgroundColor || [];
                                    const legendItems = [];
                                    
                                    // Helper function to add transparency to color
                                    const addTransparency = (color, opacity = 0.7) => {
                                        if (color.startsWith('#')) {
                                            const r = parseInt(color.slice(1, 3), 16);
                                            const g = parseInt(color.slice(3, 5), 16);
                                            const b = parseInt(color.slice(5, 7), 16);
                                            return `rgba(${r}, ${g}, ${b}, ${opacity})`;
                                        }
                                        return color;
                                    };
                                    
                                    labels.forEach((label, i) => {
                                        if (label !== 'Start' && label !== 'Total') {
                                            const originalColor = colors[i] || '#94a3b8';
                                            legendItems.push({
                                                text: label,
                                                fillStyle: addTransparency(originalColor, 0.7),
                                                strokeStyle: 'transparent',
                                                lineWidth: 0,
                                                hidden: false,
                                                fontColor: '#94a3b8'
                                            });
                                        }
                                    });
                                    
                                    return legendItems;
                                }
                            }
                        },
                        tooltip: {
                            backgroundColor: 'white',
                            borderWidth: 2,
                            borderColor: '#e5e7eb',
                            padding: 14,
                            displayColors: false,
                            titleFont: { 
                                size: 12, 
                                weight: '600',
                                family: '-apple-system, BlinkMacSystemFont, "Segoe UI", Roboto'
                            },
                            bodyFont: { 
                                size: 14, 
                                weight: '700',
                                family: '-apple-system, BlinkMacSystemFont, "Segoe UI", Roboto'
                            },
                            cornerRadius: 8,
                            caretSize: 6,
                            titleColor: '#64748b',
                            bodyColor: '#1e293b',
                            callbacks: {
                                title: ctx => ctx[0].label,
                                label: ctx => {
                                    // Use stored contribution if available, otherwise calculate
                                    let value;
                                    let total;
                                    if (charts.compare && charts.compare._contributions) {
                                        value = charts.compare._contributions[ctx.dataIndex];
                                        total = charts.compare._totalValue;
                                    } else {
                                        value = Array.isArray(ctx.parsed.y) 
                                            ? ctx.parsed.y[1] - ctx.parsed.y[0]
                                            : ctx.parsed.y;
                                        total = value; // Fallback
                                    }
                                    
                                    if (displayTypes.waterfall === 'percentage') {
                                        // Calculate percentage of total
                                        if (!total || total === 0) {
                                            return '0.00%';
                                        }
                                        const percentValue = (value / Math.abs(total)) * 100;
                                        const sign = percentValue < 0 ? '-' : '';
                                        return `${sign}${Math.abs(percentValue).toFixed(2)}%`;
                                    }
                                    const sign = value < 0 ? '-' : '';
                                    return `${sign}₹${formatIndianNumber(Math.abs(value), 2)}`;
                                }
                            }
                        }
                    },
                    scales: {
                        y: {
                            display: true,
                            position: 'right',
                            beginAtZero: true,
                            grid: { 
                                color: 'rgba(148, 163, 184, 0.08)',
                                lineWidth: 1,
                                drawBorder: false,
                                drawTicks: false
                            },
                            border: {
                                display: false
                            },
                            ticks: {
                                font: { 
                                    size: 10, 
                                    weight: '500',
                                    family: '-apple-system, BlinkMacSystemFont, "Segoe UI", Roboto' 
                                },
                                color: '#94a3b8',
                                padding: 8,
                                maxTicksLimit: 8,
                                callback: value => {
                                    if (displayTypes.waterfall === 'percentage') {
                                        return value.toFixed(1) + '%';
                                    }
                                    if (value === 0) return '₹0';
                                    if (Math.abs(value) >= 100000) return `₹${Math.round(value / 100000)}L`;
                                    if (Math.abs(value) >= 1000) return `₹${Math.round(value / 1000)}K`;
                                    return `₹${Math.round(value)}`;
                                }
                            }
                        },
                        x: {
                            display: true,
                            grid: { 
                                display: false,
                                drawBorder: false
                            },
                            border: {
                                display: false
                            },
                            ticks: {
                                font: { 
                                    size: 10, 
                                    weight: '500',
                                    family: '-apple-system, BlinkMacSystemFont, "Segoe UI", Roboto'
                                },
                                color: '#94a3b8',
                                padding: 6
                            }
                        }
                    },
                    interaction: { 
                        intersect: false, 
                        mode: 'index' 
                    }
                },
                plugins: [{
                    id: 'waterfallLabels',
                    afterDatasetsDraw(chart) {
                        // Only show labels if showValues.waterfall is true
                        if (!showValues.waterfall) {
                            return;
                        }
                        
                        const { ctx, data, scales } = chart;
                        const meta = chart.getDatasetMeta(0);
                        
                        meta.data.forEach((bar, index) => {
                            // Get the actual value from stored contributions
                            let value;
                            if (charts.compare && charts.compare._contributions) {
                                value = charts.compare._contributions[index];
                            } else {
                                const dataValue = data.datasets[0].data[index];
                                value = Array.isArray(dataValue) 
                                    ? dataValue[1] - dataValue[0]
                                    : dataValue;
                            }
                            
                            // Format value based on display type
                            let label;
                            if (displayTypes.waterfall === 'percentage') {
                                const total = charts.compare._totalValue || 1;
                                const percentValue = (value / Math.abs(total)) * 100;
                                label = percentValue.toFixed(1) + '%';
                            } else {
                                label = formatIndianShort(value);
                            }
                            
                            // Style
                            ctx.save();
                            ctx.font = '600 11px -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto';
                            ctx.fillStyle = value >= 0 ? '#10b981' : '#c2410c';
                            ctx.textAlign = 'center';
                            
                            // Position label based on value
                            const x = bar.x;
                            let y;
                            
                            // Get the bar data array [min, max]
                            const barData = data.datasets[0].data[index];
                            const yScale = scales.y;
                            
                            if (Array.isArray(barData)) {
                                // Floating bar - use the max value (top of bar)
                                const topValue = Math.max(barData[0], barData[1]);
                                const bottomValue = Math.min(barData[0], barData[1]);
                                
                                if (value >= 0) {
                                    // Positive: label above the bar (above topValue)
                                    ctx.textBaseline = 'bottom';
                                    y = yScale.getPixelForValue(topValue) - 5;
                                } else {
                                    // Negative: label below the bar (below bottomValue)
                                    ctx.textBaseline = 'top';
                                    y = yScale.getPixelForValue(bottomValue) + 5;
                                }
                            } else {
                                // Regular bar
                                if (value >= 0) {
                                    ctx.textBaseline = 'bottom';
                                    y = bar.y - 5;
                                } else {
                                    ctx.textBaseline = 'top';
                                    y = bar.y + 5;
                                }
                            }
                            
                            ctx.fillText(label, x, y);
                            ctx.restore();
                        });
                    }
                }]
            });
        }

        function createGradient(canvas, color) {
            const ctx = canvas.getContext('2d');
            const gradient = ctx.createLinearGradient(0, 0, 0, 400);
            
            if (color === '#059669' || color === '#10b981') {
                gradient.addColorStop(0, 'rgba(5, 150, 105, 0.15)');
                gradient.addColorStop(1, 'rgba(5, 150, 105, 0)');
            } else if (color === '#dc2626') {
                gradient.addColorStop(0, 'rgba(220, 38, 38, 0.15)');
                gradient.addColorStop(1, 'rgba(220, 38, 38, 0)');
            }
            
            return gradient;
        }

        // Update functions
        function updateAllCharts() {
            if (allTrades.length === 0) {
                return;
            }
            
            // Auto-select best period for PNL bar chart and Strategy Comparison
            autoSelectPnlBarPeriod();
            autoSelectComparePeriod();
            
            updateChart('pnl');
            updateChart('drawdown');
            updateChart('pnlbar');
            updateChart('compare');
        }
        
        function autoSelectPnlBarPeriod() {
            // Try month first
            const monthData = aggregateByPeriod(allTrades, 'month');
            if (monthData.length >= 4) {
                activePeriods.pnlbar = 'month';
                updatePeriodButtons('pnlbar', 'month');
                return;
            }
            
            // Try week if month has < 4 candles
            const weekData = aggregateByPeriod(allTrades, 'week');
            if (weekData.length >= 4) {
                activePeriods.pnlbar = 'week';
                updatePeriodButtons('pnlbar', 'week');
                return;
            }
            
            // Default to day if week also has < 4 candles
            activePeriods.pnlbar = 'day';
            updatePeriodButtons('pnlbar', 'day');
        }
        
        function autoSelectComparePeriod() {
            // Try month first
            const monthData = aggregateByPeriod(allTrades, 'month');
            if (monthData.length >= 4) {
                activePeriods.compare = 'month';
                updatePeriodButtons('compare', 'month');
                return;
            }
            
            // Try week if month has < 4 candles
            const weekData = aggregateByPeriod(allTrades, 'week');
            if (weekData.length >= 4) {
                activePeriods.compare = 'week';
                updatePeriodButtons('compare', 'week');
                return;
            }
            
            // Default to day if week also has < 4 candles
            activePeriods.compare = 'day';
            updatePeriodButtons('compare', 'day');
        }
        
        function updatePeriodButtons(chartType, period) {
            // Update button states
            const buttons = document.querySelectorAll(`[data-chart="${chartType}"][data-period]`);
            buttons.forEach(btn => {
                if (btn.dataset.period === period) {
                    btn.classList.add('active');
                } else {
                    btn.classList.remove('active');
                }
            });
        }

        function updateChart(chartType) {
            if (!charts[chartType]) {
                return;
            }
            
            if (allTrades.length === 0) {
                charts[chartType].data.labels = [];
                charts[chartType].data.datasets.forEach(dataset => {
                    dataset.data = [];
                });
                charts[chartType].update('none');
                return;
            }
            
            const period = activePeriods[chartType];
            const aggregatedData = aggregateByPeriod(allTrades, period);
            
            const labels = aggregatedData.map(d => formatLabel(d.date, period));
            
            if (chartType === 'pnl') {
                const displayType = displayTypes.pnl || 'value';
                let data;
                
                if (displayType === 'percentage') {
                    // Calculate NET PNL% = (cumPnl / startingCapital) * 100
                    // Use starting capital for all periods (Day/Week/Month)
                    
                    let startingCapital = 0;
                    if (allTrades.length > 0) {
                        const brokerDates = {};
                        
                        allTrades.forEach(trade => {
                            if (trade.strategyDetails) {
                                Object.keys(trade.strategyDetails).forEach(strategyName => {
                                    const cleanName = strategyName.replace(/\s+/g, '');
                                    const brokerMatch = cleanName.match(/^(.+?)PRO/);
                                    
                                    if (brokerMatch) {
                                        const brokerCode = brokerMatch[1];
                                        const margin = trade.strategyDetails[strategyName]?.margin || 0;
                                        
                                        if (margin > 0) {
                                            if (!brokerDates[brokerCode]) {
                                                brokerDates[brokerCode] = [];
                                            }
                                            if (!brokerDates[brokerCode].includes(trade.date)) {
                                                brokerDates[brokerCode].push(trade.date);
                                            }
                                        }
                                    }
                                });
                            }
                        });
                        
                        Object.keys(brokerDates).forEach(brokerCode => {
                            const dates = brokerDates[brokerCode].sort((a, b) => compareDates(a, b));
                            const brokerFirstDate = dates[0];
                            
                            const brokerMargins = [];
                            allTrades.filter(t => t.date === brokerFirstDate).forEach(trade => {
                                if (trade.strategyDetails) {
                                    Object.keys(trade.strategyDetails).forEach(strategyName => {
                                        const cleanName = strategyName.replace(/\s+/g, '');
                                        const brokerMatch = cleanName.match(/^(.+?)PRO/);
                                        
                                        if (brokerMatch && brokerMatch[1] === brokerCode) {
                                            const margin = trade.strategyDetails[strategyName]?.margin || 0;
                                            if (margin > 0) {
                                                brokerMargins.push(margin);
                                            }
                                        }
                                    });
                                }
                            });
                            
                            if (brokerMargins.length > 0) {
                                startingCapital += Math.max(...brokerMargins);
                            }
                        });
                    }
                    
                    console.log('Cumulative P&L - Starting Capital:', startingCapital);
                    
                    data = aggregatedData.map(d => {
                        if (startingCapital === 0) return 0;
                        return ((d.cumPnl / startingCapital) * 100);
                    });
                } else {
                    data = aggregatedData.map(d => d.cumPnl);
                }
                
                charts.pnl.data.labels = labels;
                charts.pnl.data.datasets[0].data = data;
                
                // Update color based on final value
                const isProfit = data[data.length - 1] >= 0;
                charts.pnl.data.datasets[0].borderColor = isProfit ? '#059669' : '#dc2626';
                charts.pnl.data.datasets[0].backgroundColor = createGradient(elements.pnlChart, isProfit ? '#059669' : '#dc2626');
                charts.pnl.data.datasets[0].pointHoverBackgroundColor = isProfit ? '#059669' : '#dc2626';
                
                // Update y-axis to show % or value
                charts.pnl.options.scales.y.ticks.callback = function(value) {
                    if (displayTypes.pnl === 'percentage') {
                        return value.toFixed(2) + '%';
                    }
                    return '₹' + formatIndianNumber(value);
                };
                
                // Update tooltip callback
                charts.pnl.options.plugins.tooltip.callbacks.label = function(ctx) {
                    if (displayTypes.pnl === 'percentage') {
                        return ctx.parsed.y.toFixed(2) + '%';
                    }
                    return `₹${formatIndianNumber(ctx.parsed.y, 2)}`;
                };
                
                charts.pnl.update('none');
            } else if (chartType === 'drawdown') {
                const displayType = displayTypes.drawdown || 'value';
                let data;
                
                if (displayType === 'percentage') {
                    // Calculate Drawdown% = (drawdown / peakMargin) * 100
                    // peakMargin = startingCapital + peak cumPnl at that point
                    
                    // Get starting capital
                    let startingCapital = 0;
                    if (allTrades.length > 0) {
                        const brokerDates = {};
                        
                        allTrades.forEach(trade => {
                            if (trade.strategyDetails) {
                                Object.keys(trade.strategyDetails).forEach(strategyName => {
                                    const cleanName = strategyName.replace(/\s+/g, '');
                                    const brokerMatch = cleanName.match(/^(.+?)PRO/);
                                    
                                    if (brokerMatch) {
                                        const brokerCode = brokerMatch[1];
                                        const margin = trade.strategyDetails[strategyName]?.margin || 0;
                                        
                                        if (margin > 0) {
                                            if (!brokerDates[brokerCode]) {
                                                brokerDates[brokerCode] = [];
                                            }
                                            if (!brokerDates[brokerCode].includes(trade.date)) {
                                                brokerDates[brokerCode].push(trade.date);
                                            }
                                        }
                                    }
                                });
                            }
                        });
                        
                        Object.keys(brokerDates).forEach(brokerCode => {
                            const dates = brokerDates[brokerCode].sort((a, b) => compareDates(a, b));
                            const brokerFirstDate = dates[0];
                            
                            const brokerMargins = [];
                            allTrades.filter(t => t.date === brokerFirstDate).forEach(trade => {
                                if (trade.strategyDetails) {
                                    Object.keys(trade.strategyDetails).forEach(strategyName => {
                                        const cleanName = strategyName.replace(/\s+/g, '');
                                        const brokerMatch = cleanName.match(/^(.+?)PRO/);
                                        
                                        if (brokerMatch && brokerMatch[1] === brokerCode) {
                                            const margin = trade.strategyDetails[strategyName]?.margin || 0;
                                            if (margin > 0) {
                                                brokerMargins.push(margin);
                                            }
                                        }
                                    });
                                }
                            });
                            
                            if (brokerMargins.length > 0) {
                                startingCapital += Math.max(...brokerMargins);
                            }
                        });
                    }
                    
                    console.log('Drawdown - Starting Capital:', startingCapital);
                    
                    data = aggregatedData.map(d => {
                        // peakMargin = startingCapital + peak cumPnl
                        const peakMargin = startingCapital + d.peak;
                        if (peakMargin === 0) return 0;
                        return ((d.drawdown / peakMargin) * 100);
                    });
                } else {
                    data = aggregatedData.map(d => d.drawdown);
                }
                
                charts.drawdown.data.labels = labels;
                charts.drawdown.data.datasets[0].data = data;
                
                // Update y-axis to show % or value
                charts.drawdown.options.scales.y.ticks.callback = function(value) {
                    if (displayTypes.drawdown === 'percentage') {
                        return value.toFixed(2) + '%';
                    }
                    return '₹' + formatIndianNumber(value);
                };
                
                // Update tooltip callback
                charts.drawdown.options.plugins.tooltip.callbacks.label = function(ctx) {
                    if (displayTypes.drawdown === 'percentage') {
                        return ctx.parsed.y.toFixed(2) + '%';
                    }
                    return `₹${formatIndianNumber(ctx.parsed.y, 2)}`;
                };
                
                charts.drawdown.update('none');
            } else if (chartType === 'pnlbar') {
                const displayType = displayTypes.pnlbar || 'value';
                let profitData;
                
                if (displayType === 'percentage') {
                    const period = activePeriods[chartType];
                    console.log('=== Percentage Calculation ===');
                    console.log('Period:', period);
                    console.log('First 3 items:', aggregatedData.slice(0, 3).map(d => ({
                        date: d.date,
                        cumMargin: d.cumMargin,
                        periodProfit: d.periodProfit,
                        cumPnl: d.cumPnl,
                        percent: d.cumMargin > 0 ? ((d.periodProfit / d.cumMargin) * 100).toFixed(2) + '%' : '0%'
                    })));
                    
                    if (period === 'day') {
                        // Build month boundaries
                        const monthLastDayMargins = new Map();
                        let currentMonth = null;
                        let currentMonthDays = [];
                        let firstMonthStartMargin = 0;
                        
                        aggregatedData.forEach((d, index) => {
                            const dateParts = d.date.split('/');
                            const month = dateParts.length >= 2 ? (dateParts[1] + '/' + dateParts[2]) : d.date;
                            
                            if (month !== currentMonth) {
                                if (currentMonth !== null && currentMonthDays.length > 0) {
                                    const lastDay = currentMonthDays[currentMonthDays.length - 1];
                                    monthLastDayMargins.set(currentMonth, lastDay.cumMargin || 0);
                                }
                                currentMonth = month;
                                currentMonthDays = [];
                                
                                // Store first month's starting margin
                                if (index === 0) {
                                    firstMonthStartMargin = d.cumMargin - (d.cumPnl || 0);
                                }
                            }
                            
                            currentMonthDays.push(d);
                            
                            if (index === aggregatedData.length - 1 && currentMonthDays.length > 0) {
                                const lastDay = currentMonthDays[currentMonthDays.length - 1];
                                monthLastDayMargins.set(currentMonth, lastDay.cumMargin || 0);
                            }
                        });
                        
                        // Calculate percentages - matching Strategy Performance % logic exactly
                        // First day of month: use month's starting margin
                        // Subsequent days: use previous day's cumMargin
                        
                        currentMonth = null; // Reset the existing variable
                        let monthStartMargin = 0;
                        
                        profitData = aggregatedData.map((d, index) => {
                            const dateParts = d.date.split('/');
                            const month = dateParts.length >= 2 ? (dateParts[1] + '/' + dateParts[2]) : d.date;
                            
                            // Check if this is the first day of a new month
                            const isFirstDayOfMonth = (month !== currentMonth);
                            
                            if (isFirstDayOfMonth) {
                                // First day of month: use starting margin
                                currentMonth = month;
                                if (index === 0) {
                                    // Very first day in dataset: starting capital
                                    monthStartMargin = (d.cumMargin || 0) - (d.cumPnl || 0);
                                } else {
                                    // First day of subsequent month: use previous day's cumMargin (which is previous month's ending)
                                    const prevDay = aggregatedData[index - 1];
                                    monthStartMargin = prevDay.cumMargin || 0;
                                }
                                
                                if (monthStartMargin === 0) {
                                    return 0;
                                } else {
                                    return ((d.periodProfit || 0) / monthStartMargin) * 100;
                                }
                            } else {
                                // Subsequent days in month: use previous day's cumMargin
                                const prevDay = aggregatedData[index - 1];
                                const previousDayMargin = prevDay.cumMargin || 0;
                                
                                if (previousDayMargin === 0) {
                                    return 0;
                                } else {
                                    return ((d.periodProfit || 0) / previousDayMargin) * 100;
                                }
                            }
                        });
                    } else if (period === 'week' || period === 'month') {
                        profitData = aggregatedData.map((d, index) => {
                            if (index === 0) {
                                // First period: use starting capital = cumMargin - cumPnl
                                const startingCapital = (d.cumMargin || 0) - (d.cumPnl || 0);
                                if (startingCapital === 0) {
                                    return 0;
                                } else {
                                    return ((d.periodProfit || 0) / startingCapital) * 100;
                                }
                            } else {
                                // Subsequent periods: use previous period's cumMargin
                                const prevPeriod = aggregatedData[index - 1];
                                const previousMargin = prevPeriod.cumMargin || 0;
                                if (previousMargin === 0) {
                                    return 0;
                                } else {
                                    return ((d.periodProfit || 0) / previousMargin) * 100;
                                }
                            }
                        });
                    }
                } else {
                    profitData = aggregatedData.map(d => d.periodProfit || 0);
                }
                
                // Create color array - green for positive, brown for negative
                const colors = profitData.map(val => val >= 0 ? '#10b981' : '#c2410c');
                
                charts.pnlbar.data.labels = labels;
                charts.pnlbar.data.datasets[0].data = profitData;
                charts.pnlbar.data.datasets[0].backgroundColor = colors;
                
                // Update y-axis to show % or value
                charts.pnlbar.options.scales.y.ticks.callback = function(value) {
                    if (displayTypes.pnlbar === 'percentage') {
                        return value.toFixed(2) + '%';
                    }
                    return '₹' + formatIndianNumber(value);
                };
                
                // Update tooltip callback
                charts.pnlbar.options.plugins.tooltip.callbacks.label = function(ctx) {
                    if (displayTypes.pnlbar === 'percentage') {
                        return ctx.parsed.y.toFixed(2) + '%';
                    }
                    return `₹${formatIndianNumber(ctx.parsed.y, 2)}`;
                };
                
                charts.pnlbar.update('none');
            } else if (chartType === 'compare') {
                // Waterfall Chart Logic
                const isMonthly = !window.waterfallView || window.waterfallView === 'monthly';
                
                // Get all unique months from trades
                const monthsSet = new Set();
                allTrades.forEach(trade => {
                    if (trade.date) {
                        const parts = trade.date.split('/');
                        if (parts.length >= 3) {
                            const monthNames = ['', 'JAN', 'FEB', 'MAR', 'APR', 'MAY', 'JUN', 
                                              'JUL', 'AUG', 'SEP', 'OCT', 'NOV', 'DEC'];
                            const monthNum = parseInt(parts[1]);
                            const year = parts[2].slice(-2); // Last 2 digits of year
                            const monthName = monthNames[monthNum];
                            const displayMonth = `${monthName}-${year}`;
                            monthsSet.add(displayMonth);
                        }
                    }
                });
                
                availableMonths = Array.from(monthsSet).sort((a, b) => {
                    // Sort by date
                    const [aMonth, aYear] = a.split('-');
                    const [bMonth, bYear] = b.split('-');
                    const monthNames = ['JAN', 'FEB', 'MAR', 'APR', 'MAY', 'JUN', 
                                      'JUL', 'AUG', 'SEP', 'OCT', 'NOV', 'DEC'];
                    const aMonthIdx = monthNames.indexOf(aMonth);
                    const bMonthIdx = monthNames.indexOf(bMonth);
                    return parseInt(aYear) === parseInt(bYear) ? aMonthIdx - bMonthIdx : parseInt(aYear) - parseInt(bYear);
                });
                
                // Set current month to latest if not set
                if (availableMonths.length > 0 && currentMonthIndex >= availableMonths.length) {
                    currentMonthIndex = availableMonths.length - 1;
                }
                
                updateMonthDisplay();
                
                let labels = [];
                let data = [];
                let colors = [];
                let strategyContributions = {};
                
                if (isMonthly && availableMonths.length > 0) {
                    // Monthly view - show contributions for selected month
                    const selectedMonth = availableMonths[currentMonthIndex];
                    const [monthName, year] = selectedMonth.split('-');
                    const monthNames = ['JAN', 'FEB', 'MAR', 'APR', 'MAY', 'JUN', 
                                      'JUL', 'AUG', 'SEP', 'OCT', 'NOV', 'DEC'];
                    const monthNum = monthNames.indexOf(monthName) + 1;
                    const fullYear = '20' + year; // Convert 25 to 2025
                    
                    // Get trades for this month
                    const monthTrades = allTrades.filter(trade => {
                        if (!trade.date) return false;
                        const parts = trade.date.split('/');
                        if (parts.length < 3) return false;
                        return parseInt(parts[1]) === monthNum && parts[2] === fullYear;
                    });
                    
                    // Calculate strategy contributions for the month
                    monthTrades.forEach(trade => {
                        if (trade.strategyPnlTax) {
                            Object.entries(trade.strategyPnlTax).forEach(([stratName, pnl]) => {
                                if (!stratName.startsWith('A.PRO')) {
                                    if (!strategyContributions[stratName]) {
                                        strategyContributions[stratName] = 0;
                                    }
                                    strategyContributions[stratName] += pnl;
                                }
                            });
                        }
                    });
                } else {
                    // Overall view - show contributions across all time
                    allTrades.forEach(trade => {
                        if (trade.strategyPnlTax) {
                            Object.entries(trade.strategyPnlTax).forEach(([stratName, pnl]) => {
                                if (!stratName.startsWith('A.PRO')) {
                                    if (!strategyContributions[stratName]) {
                                        strategyContributions[stratName] = 0;
                                    }
                                    strategyContributions[stratName] += pnl;
                                }
                            });
                        }
                    });
                }
                
                // Sort strategies by broker code and PRO number
                // Filter out strategies with zero contribution
                const sortedStrategies = Object.entries(strategyContributions)
                    .filter(([stratName, contribution]) => contribution !== 0) // Exclude zero contributions
                    .sort((a, b) => {
                        // Extract broker code and PRO number from strategy names
                        const extractParts = (name) => {
                            const match = name.match(/([A-Z0-9]+)\s*PRO\s*(\d+)/i);
                            if (match) {
                                return {
                                    broker: match[1],
                                    pro: parseInt(match[2])
                                };
                            }
                            return { broker: name, pro: 0 };
                        };
                        
                        const partsA = extractParts(a[0]);
                        const partsB = extractParts(b[0]);
                        
                        // Sort by broker code first
                        if (partsA.broker !== partsB.broker) {
                            return partsA.broker.localeCompare(partsB.broker);
                        }
                        
                        // Then by PRO number
                        return partsA.pro - partsB.pro;
                    })
                    .slice(0, 10); // Top 10 strategies
                
                // Modern Vibrant color palette (green reserved for Total)
                const strategyColors = {
                    'PRO 4': '#3b82f6',
                    'PRO 5': '#ec4899',
                    'PRO 8': '#8b5cf6',
                    'PRO 6': '#06b6d4',
                    'PRO 7': '#f59e0b'
                };
                const defaultColors = ['#3b82f6', '#ec4899', '#8b5cf6', '#06b6d4', '#f59e0b'];
                
                // Helper function to extract PRO number for color matching
                const getColorForStrategy = (stratName) => {
                    const match = stratName.match(/PRO\s*(\d+)/i);
                    if (match) {
                        const proKey = `PRO ${match[1]}`;
                        return strategyColors[proKey];
                    }
                    return null;
                };
                
                // Calculate total first for percentage calculations
                const totalValue = sortedStrategies.reduce((sum, [, contrib]) => sum + contrib, 0);
                const isPercentageMode = displayTypes.waterfall === 'percentage';
                
                // Build waterfall data with floating bars [start, end]
                // Start from 0, no "Start" bar needed
                
                let cumulative = 0;
                const contributions = []; // Store actual contribution values for tooltips
                
                sortedStrategies.forEach(([stratName, contribution], index) => {
                    labels.push(formatStrategyName(stratName));
                    contributions.push(contribution); // Always store actual value for tooltip
                    
                    // Calculate display value (percentage or actual)
                    let displayValue = contribution;
                    if (isPercentageMode && totalValue !== 0) {
                        displayValue = (contribution / Math.abs(totalValue)) * 100;
                    }
                    
                    const start = cumulative;
                    const end = cumulative + displayValue;
                    
                    // For floating bars, always use [min, max] for proper display
                    data.push([Math.min(start, end), Math.max(start, end)]);
                    
                    // Color based on positive/negative contribution
                    if (contribution < 0) {
                        // Use red/brown only for negative values
                        colors.push('#c2410c');
                    } else {
                        // Use predefined or default colors for positive values
                        const baseColor = getColorForStrategy(stratName) || defaultColors[index % defaultColors.length];
                        colors.push(baseColor);
                    }
                    
                    cumulative += displayValue;
                });
                
                // Add Total
                labels.push('Total');
                contributions.push(totalValue); // Store actual total value
                
                // Total bar display value
                const totalDisplayValue = isPercentageMode ? (totalValue >= 0 ? 100 : -100) : totalValue;
                
                // Total bar from 0 to cumulative (can be negative)
                if (totalDisplayValue >= 0) {
                    data.push([0, totalDisplayValue]);
                } else {
                    data.push([totalDisplayValue, 0]);
                }
                // Use red/brown for negative total, green for positive
                colors.push(totalValue < 0 ? '#c2410c' : '#10b981');
                
                // Update chart
                charts.compare.data.labels = labels;
                charts.compare.data.datasets[0].data = data;
                charts.compare.data.datasets[0].backgroundColor = colors;
                
                // Store contributions and total for tooltip access
                charts.compare._contributions = contributions;
                charts.compare._totalValue = totalValue;
                
                // Update tooltip callbacks
                charts.compare.options.plugins.tooltip.callbacks.label = function(ctx) {
                    // Use stored contribution value instead of calculating from bar
                    const value = charts.compare._contributions[ctx.dataIndex];
                    const total = charts.compare._totalValue;
                    
                    if (displayTypes.waterfall === 'percentage') {
                        // Calculate percentage of total
                        if (total === 0) {
                            return '0.00%';
                        }
                        const percentValue = (value / Math.abs(total)) * 100;
                        const sign = percentValue < 0 ? '-' : '';
                        return `${sign}${Math.abs(percentValue).toFixed(2)}%`;
                    }
                    const sign = value < 0 ? '-' : '';
                    return `${sign}₹${formatIndianNumber(Math.abs(value), 2)}`;
                };
                
                charts.compare.update('none');
            }
        }
    </script>
</body>
</html>
