<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Chart Analysis</title>
    <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.0/dist/chart.umd.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-datalabels@2.2.0/dist/chartjs-plugin-datalabels.min.js"></script>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        html, body { width: 100%; height: 100%; }
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            background: #f8fafc;
            color: #1e293b;
        }
        .main-content {
            padding: 20px 32px 32px 32px;
            background: #f8fafc;
            width: 100%;
        }
        .page-header { 
            margin-bottom: 20px; 
            display: flex; 
            justify-content: space-between; 
            align-items: center; 
            gap: 20px;
            flex-wrap: wrap;
        }
        .page-title { font-size: 20px; font-weight: 700; color: #111827; margin-bottom: 4px; letter-spacing: -0.5px; }
        .page-subtitle { font-size: 12px; color: #6b7280; font-weight: 400; }
        
        /* Charts Grid */
        .charts-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
        }
        
        .chart-card {
            background: white;
            border-radius: 12px;
            padding: 20px;
            box-shadow: 0 1px 3px rgba(0,0,0,0.06), 0 1px 2px rgba(0,0,0,0.04);
            border: 1px solid #f1f5f9;
            display: flex;
            flex-direction: column;
            transition: box-shadow 0.2s ease;
            overflow: hidden;
            height: 400px;
        }
        
        /* Specific height for Amibroker and LOT PNLTAX charts (5th and 6th cards) */
        .chart-card:nth-child(5),
        .chart-card:nth-child(6) {
            height: 450px;
        }
        
        .chart-card:hover { 
            box-shadow: 0 4px 6px rgba(0,0,0,0.07), 0 2px 4px rgba(0,0,0,0.05); 
        }
        
        .chart-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 16px;
        }
        
        .chart-title {
            font-size: 14px;
            font-weight: 600;
            color: #374151;
            letter-spacing: 0.3px;
        }
        
        /* Date Range Selector */
        .date-range-selector {
            display: flex;
            gap: 8px;
            align-items: center;
            background: #f1f5f9;
            padding: 4px;
            border-radius: 8px;
        }
        
        .date-range-btn {
            padding: 6px 12px;
            font-size: 11px;
            font-weight: 600;
            color: #64748b;
            background: transparent;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.2s ease;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            white-space: nowrap;
        }
        
        .date-range-btn:hover {
            color: #475569;
        }
        
        .date-range-btn.active {
            background: white;
            color: #1e40af;
            box-shadow: 0 1px 3px rgba(0,0,0,0.1);
        }
        
        /* Custom Date Range Picker */
        .custom-date-range {
            display: flex;
            gap: 4px;
            align-items: center;
            padding: 4px 8px;
            background: transparent;
            border-radius: 6px;
        }
        
        .custom-date-range.active {
            box-shadow: 0 1px 3px rgba(0,0,0,0.1);
        }
        
        .custom-date-range label {
            font-size: 9px;
            font-weight: 600;
            color: #64748b;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }
        
        .custom-date-range input[type="date"] {
            padding: 4px 6px;
            font-size: 10px;
            border: 1px solid #e5e7eb;
            border-radius: 4px;
            font-family: inherit;
            color: #475569;
            cursor: pointer;
            background: transparent;
        }
        
        .custom-date-range input[type="date"]:focus {
            outline: none;
            border-color: #3b82f6;
        }
        
        .chart-title {
            font-size: 14px;
            font-weight: 600;
            color: #374151;
            letter-spacing: 0.3px;
        }
        
        .chart-toggles {
            display: flex;
            gap: 6px;
            background: #f1f5f9;
            padding: 3px;
            border-radius: 8px;
        }
        
        .chart-controls {
            display: flex;
            gap: 8px;
            align-items: center;
        }
        
        .toggle-btn {
            padding: 6px 12px;
            font-size: 10px;
            font-weight: 600;
            color: #64748b;
            background: transparent;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.2s ease;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }
        
        .toggle-btn:hover {
            color: #475569;
        }
        
        .toggle-btn.active {
            background: white;
            color: #1e40af;
            box-shadow: 0 1px 3px rgba(0,0,0,0.1);
        }
        
        .month-navigation {
            display: flex;
            gap: 8px;
            align-items: center;
            background: #f1f5f9;
            padding: 4px 8px;
            border-radius: 8px;
        }
        
        /* Date Range Selector */
        .date-range-selector {
            display: flex;
            gap: 4px;
            background: #f1f5f9;
            padding: 4px;
            border-radius: 8px;
        }
        
        .date-range-btn {
            padding: 6px 10px;
            font-size: 10px;
            font-weight: 600;
            color: #475569;
            background: transparent;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.2s ease;
            white-space: nowrap;
        }
        
        .date-range-btn:hover {
            background: white;
            color: #1e40af;
        }
        
        .date-range-btn.active {
            background: white;
            color: #1e40af;
            box-shadow: 0 1px 3px rgba(0,0,0,0.1);
        }
        
        .nav-btn {
            padding: 6px 10px;
            font-size: 10px;
            font-weight: 600;
            color: #475569;
            background: white;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.2s ease;
            box-shadow: 0 1px 2px rgba(0,0,0,0.05);
        }
        
        .nav-btn:hover {
            background: #f8fafc;
            color: #1e40af;
        }
        
        .nav-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }
        
        .current-month {
            font-size: 11px;
            font-weight: 600;
            color: #1e293b;
            padding: 0 8px;
            min-width: 65px;
            text-align: center;
        }
        
        .chart-container {
            flex: 1;
            position: relative;
            min-height: 0;
        }
        
        .chart-container canvas {
            width: 100% !important;
            height: 100% !important;
        }
        
        /* Loading State */
        .loading-state {
            display: none;
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            z-index: 10;
        }
        
        .loading-state.active {
            display: block;
        }
        
        .loading-spinner {
            width: 40px;
            height: 40px;
            border: 3px solid #e5e7eb;
            border-top: 3px solid #1e40af;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin: 0 auto 12px;
        }
        
        .loading-message {
            color: #64748b;
            font-size: 13px;
            font-weight: 500;
        }
        
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        
        /* Tablet Responsive */
        @media (max-width: 1024px) {
            .charts-grid {
                grid-template-columns: 1fr;
                gap: 16px;
            }
        }
        
        /* Mobile Responsive */
        @media (max-width: 768px) {
            .charts-grid {
                grid-template-columns: 1fr;
                gap: 16px;
            }
            
            .chart-card {
                height: 350px;
            }
            
            /* Specific height for Amibroker and LOT PNLTAX charts on mobile */
            .chart-card:nth-child(5),
            .chart-card:nth-child(6) {
                height: 370px;
            }
            
            .chart-header {
                flex-direction: column;
                align-items: flex-start;
                gap: 10px;
            }
            
            .chart-controls {
                width: 100%;
                flex-wrap: wrap;
                gap: 6px;
            }
            
            .chart-toggles {
                flex-shrink: 0;
            }
            
            .month-navigation {
                width: 100%;
                justify-content: center;
            }
            
            .main-content {
                padding: 16px;
            }
            
            .page-header {
                flex-direction: column;
                align-items: flex-start;
                gap: 12px;
            }
            
            .page-title {
                font-size: 18px;
            }
            
            .page-subtitle {
                font-size: 11px;
            }
            
            .date-range-selector {
                width: 100%;
                justify-content: flex-start;
                flex-wrap: wrap;
            }
            
            .date-range-btn {
                font-size: 9px;
                padding: 5px 8px;
            }
            
            .custom-date-range {
                width: 100%;
                flex-wrap: wrap;
                gap: 6px;
            }
            
            .custom-date-range input[type="date"] {
                flex: 1;
                min-width: 100px;
            }
            
            .chart-title {
                font-size: 13px;
            }
            
            .toggle-btn {
                padding: 5px 10px;
                font-size: 10px;
            }
            
            .nav-btn {
                padding: 5px 8px;
                font-size: 10px;
            }
            
            .current-month {
                font-size: 11px;
                min-width: 70px;
            }
        }
    </style>
</head>
<body>
    <div class="main-content">
        <div class="page-header">
            <div>
                <div class="page-title">Advanced Chart Analysis</div>
                <div class="page-subtitle">Comprehensive performance visualization across multiple metrics</div>
            </div>
            
            <!-- Date Range Selector -->
            <div class="date-range-selector">
                <div class="custom-date-range" id="customDateRange">
                    <label>From:</label>
                    <input type="date" id="fromDate" onchange="applyCustomDateRange()">
                    <label>To:</label>
                    <input type="date" id="toDate" onchange="applyCustomDateRange()">
                </div>
                <button class="date-range-btn" data-range="3" onclick="selectDateRange(3)">Last 3M</button>
                <button class="date-range-btn" data-range="ytd" onclick="selectDateRange('ytd')">YTD</button>
                <button class="date-range-btn active" data-range="all" onclick="selectDateRange('all')">All Time</button>
            </div>
        </div>
        
        <div class="charts-grid">
            <!-- Cumulative P&L Chart -->
            <div class="chart-card">
                <div class="chart-header">
                    <div class="chart-title">Cumulative P&L</div>
                    <div class="chart-controls">
                        <div class="chart-toggles">
                            <button class="toggle-btn active" data-chart="pnl" data-type="value">Value</button>
                            <button class="toggle-btn" data-chart="pnl" data-type="percentage">%</button>
                        </div>
                        <div class="chart-toggles">
                            <button class="toggle-btn active" data-chart="pnl" data-period="day">Day</button>
                            <button class="toggle-btn" data-chart="pnl" data-period="week">Week</button>
                            <button class="toggle-btn" data-chart="pnl" data-period="month">Month</button>
                        </div>
                    </div>
                </div>
                <div class="chart-container">
                    <canvas id="pnlChart"></canvas>
                </div>
            </div>
            
            <!-- Drawdown Chart -->
            <div class="chart-card">
                <div class="chart-header">
                    <div class="chart-title">Drawdown</div>
                    <div class="chart-controls">
                        <div class="chart-toggles">
                            <button class="toggle-btn active" data-chart="drawdown" data-type="value">Value</button>
                            <button class="toggle-btn" data-chart="drawdown" data-type="percentage">%</button>
                        </div>
                        <div class="chart-toggles">
                            <button class="toggle-btn active" data-chart="drawdown" data-period="day">Day</button>
                            <button class="toggle-btn" data-chart="drawdown" data-period="week">Week</button>
                            <button class="toggle-btn" data-chart="drawdown" data-period="month">Month</button>
                        </div>
                    </div>
                </div>
                <div class="chart-container">
                    <canvas id="drawdownChart"></canvas>
                </div>
            </div>
            
            <!-- Periodic Returns Chart -->
            <div class="chart-card">
                <div class="chart-header">
                    <div class="chart-title">Periodic Returns</div>
                    <div class="chart-controls">
                        <div class="chart-toggles">
                            <button class="toggle-btn" id="showPnlBarValues">Show</button>
                            <button class="toggle-btn active" id="hidePnlBarValues">Hide</button>
                        </div>
                        <div class="chart-toggles">
                            <button class="toggle-btn active" data-chart="pnlbar" data-type="value">Value</button>
                            <button class="toggle-btn" data-chart="pnlbar" data-type="percentage">%</button>
                        </div>
                        <div class="chart-toggles">
                            <button class="toggle-btn" data-chart="pnlbar" data-period="day">Day</button>
                            <button class="toggle-btn" data-chart="pnlbar" data-period="week">Week</button>
                            <button class="toggle-btn active" data-chart="pnlbar" data-period="month">Month</button>
                        </div>
                    </div>
                </div>
                <div class="chart-container">
                    <canvas id="pnlBarChart"></canvas>
                </div>
            </div>
            
            <!-- Breakdown (Waterfall) -->
            <div class="chart-card">
                <div class="chart-header">
                    <div class="chart-title">Breakdown</div>
                    <div class="chart-controls">
                        <div class="chart-toggles">
                            <button class="toggle-btn" id="showWaterfallValues">Show</button>
                            <button class="toggle-btn active" id="hideWaterfallValues">Hide</button>
                        </div>
                        <div class="chart-toggles">
                            <button class="toggle-btn active" data-chart="compare" data-type="value">Value</button>
                            <button class="toggle-btn" data-chart="compare" data-type="percentage">%</button>
                        </div>
                        <div class="chart-toggles">
                            <button class="toggle-btn active" data-chart="compare" data-view="monthly">Month</button>
                            <button class="toggle-btn" data-chart="compare" data-view="overall">All</button>
                        </div>
                        <div class="month-navigation">
                            <button class="nav-btn" id="prevMonth">◄</button>
                            <span class="current-month" id="currentMonth">JAN-26</span>
                            <button class="nav-btn" id="nextMonth">►</button>
                        </div>
                    </div>
                </div>
                <div class="chart-container">
                    <canvas id="compareChart"></canvas>
                </div>
            </div>
            
            <!-- Amibroker Lot P&L -->
            <div class="chart-card">
                <div class="chart-header">
                    <div class="chart-title">Amibroker Lot P&L</div>
                    <div class="chart-controls">
                        <div class="chart-toggles">
                            <button class="toggle-btn" id="showAmibrokerValues">Show</button>
                            <button class="toggle-btn active" id="hideAmibrokerValues">Hide</button>
                        </div>
                        <div class="chart-toggles">
                            <button class="toggle-btn active" data-chart="amibroker" data-type="value">Value</button>
                            <button class="toggle-btn" data-chart="amibroker" data-type="percentage">%</button>
                        </div>
                        <div class="chart-toggles">
                            <button class="toggle-btn active" data-chart="amibroker" data-view="monthly">Month</button>
                            <button class="toggle-btn" data-chart="amibroker" data-view="overall">All</button>
                        </div>
                        <div class="month-navigation">
                            <button class="nav-btn" id="prevMonthAmibroker">◄</button>
                            <span class="current-month" id="currentMonthAmibroker">JAN-26</span>
                            <button class="nav-btn" id="nextMonthAmibroker">►</button>
                        </div>
                    </div>
                </div>
                <div class="chart-container">
                    <canvas id="amibrokerChart"></canvas>
                </div>
            </div>
            
            <!-- P&L per Lot -->
            <div class="chart-card">
                <div class="chart-header">
                    <div class="chart-title">P&L per Lot</div>
                    <div class="chart-controls">
                        <div class="chart-toggles">
                            <button class="toggle-btn" id="showLotpnltaxValues">Show</button>
                            <button class="toggle-btn active" id="hideLotpnltaxValues">Hide</button>
                        </div>
                        <div class="chart-toggles">
                            <button class="toggle-btn active" data-chart="lotpnltax" data-type="value">Value</button>
                            <button class="toggle-btn" data-chart="lotpnltax" data-type="percentage">%</button>
                        </div>
                        <div class="chart-toggles">
                            <button class="toggle-btn active" data-chart="lotpnltax" data-view="monthly">Month</button>
                            <button class="toggle-btn" data-chart="lotpnltax" data-view="overall">All</button>
                        </div>
                        <div class="month-navigation">
                            <button class="nav-btn" id="prevMonthLotpnltax">◄</button>
                            <span class="current-month" id="currentMonthLotpnltax">JAN-26</span>
                            <button class="nav-btn" id="nextMonthLotpnltax">►</button>
                        </div>
                    </div>
                </div>
                <div class="chart-container">
                    <canvas id="lotpnltaxChart"></canvas>
                </div>
            </div>
        </div>
        
        <div class="loading-state" id="loadingState">
            <div class="loading-spinner"></div>
            <div class="loading-message">Loading chart data...</div>
        </div>
    </div>

    <script>
        // Indian Number Formatting Function
        function formatIndianNumber(num, decimals = 0) {
            const isNegative = num < 0;
            const absNum = Math.abs(num);
            
            // Round to specified decimals
            const rounded = decimals > 0 ? absNum.toFixed(decimals) : Math.round(absNum).toString();
            const parts = rounded.split('.');
            let intPart = parts[0];
            const decPart = parts[1];
            
            // Indian formatting: x,xx,xxx
            let formatted = '';
            if (intPart.length <= 3) {
                formatted = intPart;
            } else {
                const lastThree = intPart.substring(intPart.length - 3);
                const remaining = intPart.substring(0, intPart.length - 3);
                
                // Add commas every 2 digits for remaining part
                formatted = remaining.replace(/\B(?=(\d{2})+(?!\d))/g, ',') + ',' + lastThree;
            }
            
            // Add decimal part if exists
            if (decPart) {
                formatted += '.' + decPart;
            }
            
            return (isNegative ? '-' : '') + formatted;
        }
        
        // Short Indian Number Format (5L, 50K, 2.5Cr)
        function formatIndianShort(num) {
            const isNegative = num < 0;
            const absNum = Math.abs(num);
            
            if (absNum >= 10000000) {
                // Crores
                return (isNegative ? '-' : '') + (absNum / 10000000).toFixed(1) + 'Cr';
            } else if (absNum >= 100000) {
                // Lakhs
                return (isNegative ? '-' : '') + (absNum / 100000).toFixed(1) + 'L';
            } else if (absNum >= 1000) {
                // Thousands
                return (isNegative ? '-' : '') + (absNum / 1000).toFixed(1) + 'K';
            } else {
                return (isNegative ? '-' : '') + absNum.toFixed(0);
            }
        }
        
        // Format strategy name with space before PRO
        function formatStrategyName(name) {
            // Add space before PRO if not already present
            return name.replace(/([A-Z0-9]+)(PRO\s*\d+)/i, '$1 $2').trim();
        }
        
        // Global state
        let allTrades = [];
        const charts = {
            pnl: null,
            drawdown: null,
            pnlbar: null,
            compare: null,
            amibroker: null,
            lotpnltax: null
        };
        const activePeriods = {
            pnl: 'day',
            drawdown: 'day',
            pnlbar: 'month',
            compare: 'month',
            amibroker: 'month',
            lotpnltax: 'month'
        };
        
        const displayTypes = {
            pnl: 'value',
            drawdown: 'value',
            pnlbar: 'value',
            compare: 'value',
            amibroker: 'value',
            lotpnltax: 'value'
        };
        
        const showValues = {
            pnlbar: false,
            compare: false,
            amibroker: false,
            lotpnltax: false
        };
        
        window.waterfallView = 'monthly'; // 'monthly' or 'overall'
        let currentMonthIndex = 0;
        let availableMonths = [];
        let selectedDateRange = 'all'; // 'all', 'ytd', '3', 'custom'
        let filteredTrades = []; // Trades after date range filter
        let customFromDate = null; // Custom date range from
        let customToDate = null; // Custom date range to
        
        // Track hidden strategies for legend filtering
        const hiddenStrategies = {
            compare: new Set(),
            amibroker: new Set(),
            lotpnltax: new Set()
        };

        // Elements
        const elements = {
            loadingState: document.getElementById('loadingState'),
            pnlChart: document.getElementById('pnlChart'),
            drawdownChart: document.getElementById('drawdownChart'),
            pnlBarChart: document.getElementById('pnlBarChart'),
            compareChart: document.getElementById('compareChart'),
            amibrokerChart: document.getElementById('amibrokerChart'),
            lotpnltaxChart: document.getElementById('lotpnltaxChart')
        };

        // Date Range Selector Function
        function selectDateRange(range) {
            selectedDateRange = range;
            
            // Update button active states
            document.querySelectorAll('.date-range-btn').forEach(btn => {
                if (btn.dataset.range == range) {
                    btn.classList.add('active');
                } else {
                    btn.classList.remove('active');
                }
            });
            
            // Remove custom date range active state
            document.getElementById('customDateRange').classList.remove('active');
            
            // Filter trades based on selected range
            filterTradesByDateRange();
            
            // Refresh all charts with filtered data
            refreshAllCharts();
        }
        
        function filterTradesByDateRange() {
            if (selectedDateRange === 'all') {
                filteredTrades = allTrades;
                return;
            }
            
            if (allTrades.length === 0) {
                filteredTrades = [];
                return;
            }
            
            const today = new Date();
            let startDate;
            let endDate = today;
            
            if (selectedDateRange === 'custom') {
                // Use custom date range
                if (!customFromDate || !customToDate) {
                    filteredTrades = allTrades;
                    return;
                }
                startDate = customFromDate;
                endDate = customToDate;
            } else if (selectedDateRange === 'ytd') {
                // Year to date - from January 1st of current year
                startDate = new Date(today.getFullYear(), 0, 1);
            } else {
                // Last N months
                const months = parseInt(selectedDateRange);
                startDate = new Date(today);
                startDate.setMonth(today.getMonth() - months);
            }
            
            // Filter trades
            filteredTrades = allTrades.filter(trade => {
                if (!trade.date) return false;
                
                // Parse date (format: DD/MM/YYYY)
                const parts = trade.date.split('/');
                if (parts.length !== 3) return false;
                
                const day = parseInt(parts[0]);
                const month = parseInt(parts[1]) - 1; // JS months are 0-indexed
                const year = parseInt(parts[2]);
                const fullYear = year < 100 ? (year > 50 ? 1900 + year : 2000 + year) : year;
                
                const tradeDate = new Date(fullYear, month, day);
                
                return tradeDate >= startDate && tradeDate <= endDate;
            });
        }

        // Initialize
        (function init() {
            loadStoredData();
            setupEventListeners();
            initializeCharts();
            window.addEventListener('message', handleParentMessage);
            
            // Listen for storage changes (when parent updates localStorage)
            window.addEventListener('storage', function(e) {
                if (e.key === 'dashboardData' && e.newValue) {
                    try {
                        const data = JSON.parse(e.newValue);
                        allTrades = data.tradesData || data || [];
                        if (allTrades.length > 0) {
                            refreshAllCharts();
                        }
                    } catch (err) {
                        // Ignore parse errors
                    }
                }
            });
            
            // Periodic check for data changes (every 2 seconds)
            let lastDataLength = allTrades.length;
            let lastDataChecksum = getDataChecksum(allTrades);
            
            setInterval(() => {
                try {
                    const stored = localStorage.getItem('dashboardData');
                    if (stored) {
                        const data = JSON.parse(stored);
                        const newTrades = data.tradesData || data || [];
                        const newChecksum = getDataChecksum(newTrades);
                        
                        // Check if data has changed
                        if (newTrades.length !== lastDataLength || newChecksum !== lastDataChecksum) {
                            allTrades = newTrades;
                            lastDataLength = newTrades.length;
                            lastDataChecksum = newChecksum;
                            refreshAllCharts();
                        }
                    }
                } catch (e) {
                    // Ignore errors
                }
            }, 2000);
            
            // Request data from parent on load
            setTimeout(() => {
                window.parent.postMessage({ type: 'REQUEST_DATA_REFRESH' }, '*');
            }, 100);
        })();
        
        // Simple checksum function to detect data changes
        function getDataChecksum(trades) {
            if (!trades || trades.length === 0) return 0;
            let sum = 0;
            for (let i = 0; i < Math.min(trades.length, 10); i++) {
                const trade = trades[i];
                sum += (trade.profit || 0) + (trade.cumPnl || 0);
            }
            return sum;
        }

        function setupEventListeners() {
            // Toggle button listeners
            document.querySelectorAll('.toggle-btn').forEach(btn => {
                btn.addEventListener('click', function() {
                    const chartType = this.dataset.chart;
                    const period = this.dataset.period;
                    const type = this.dataset.type;
                    const view = this.dataset.view;
                    
                    // Handle period toggle
                    if (period) {
                        // Update active state for period toggles
                        document.querySelectorAll(`.toggle-btn[data-chart="${chartType}"][data-period]`).forEach(b => {
                            b.classList.remove('active');
                        });
                        this.classList.add('active');
                        
                        // Update period and refresh chart
                        activePeriods[chartType] = period;
                        updateChart(chartType);
                    }
                    
                    // Handle display type toggle
                    if (type) {
                        // Update active state for type toggles
                        document.querySelectorAll(`.toggle-btn[data-chart="${chartType}"][data-type]`).forEach(b => {
                            b.classList.remove('active');
                        });
                        this.classList.add('active');
                        
                        // Update display type and refresh chart
                        displayTypes[chartType] = type;
                        updateChart(chartType);
                    }
                    
                    // Handle view toggle (for waterfall)
                    if (view) {
                        // Update active state for view toggles
                        document.querySelectorAll(`.toggle-btn[data-chart="${chartType}"][data-view]`).forEach(b => {
                            b.classList.remove('active');
                        });
                        this.classList.add('active');
                        
                        // Update view and refresh chart
                        if (chartType === 'compare') {
                            window.waterfallView = view;
                            updateChart('compare');
                        } else if (chartType === 'amibroker') {
                            window.amibrokerView = view;
                            updateChart('amibroker');
                        } else if (chartType === 'lotpnltax') {
                            window.lotpnltaxView = view;
                            updateChart('lotpnltax');
                        }
                    }
                });
            });
            
            // Month navigation listeners
            const prevBtn = document.getElementById('prevMonth');
            const nextBtn = document.getElementById('nextMonth');
            
            if (prevBtn) {
                prevBtn.addEventListener('click', () => {
                    if (currentMonthIndex > 0) {
                        currentMonthIndex--;
                        updateMonthDisplay();
                        updateChart('compare');
                    }
                });
            }
            
            if (nextBtn) {
                nextBtn.addEventListener('click', () => {
                    if (currentMonthIndex < availableMonths.length - 1) {
                        currentMonthIndex++;
                        updateMonthDisplay();
                        updateChart('compare');
                    }
                });
            }
            
            // Amibroker Month navigation listeners
            const prevBtnAmibroker = document.getElementById('prevMonthAmibroker');
            const nextBtnAmibroker = document.getElementById('nextMonthAmibroker');
            
            if (prevBtnAmibroker) {
                prevBtnAmibroker.addEventListener('click', () => {
                    if (currentMonthIndex > 0) {
                        currentMonthIndex--;
                        updateMonthDisplay();
                        updateChart('amibroker');
                    }
                });
            }
            
            if (nextBtnAmibroker) {
                nextBtnAmibroker.addEventListener('click', () => {
                    if (currentMonthIndex < availableMonths.length - 1) {
                        currentMonthIndex++;
                        updateMonthDisplay();
                        updateChart('amibroker');
                    }
                });
            }
            
            // LOT PNLTAX Month navigation listeners
            const prevBtnLotpnltax = document.getElementById('prevMonthLotpnltax');
            const nextBtnLotpnltax = document.getElementById('nextMonthLotpnltax');
            
            if (prevBtnLotpnltax) {
                prevBtnLotpnltax.addEventListener('click', () => {
                    if (currentMonthIndex > 0) {
                        currentMonthIndex--;
                        updateMonthDisplay();
                        updateChart('lotpnltax');
                    }
                });
            }
            
            if (nextBtnLotpnltax) {
                nextBtnLotpnltax.addEventListener('click', () => {
                    if (currentMonthIndex < availableMonths.length - 1) {
                        currentMonthIndex++;
                        updateMonthDisplay();
                        updateChart('lotpnltax');
                    }
                });
            }
            
            // Show/Hide Values toggle buttons
            const showPnlBarValues = document.getElementById('showPnlBarValues');
            const hidePnlBarValues = document.getElementById('hidePnlBarValues');
            const showWaterfallValues = document.getElementById('showWaterfallValues');
            const hideWaterfallValues = document.getElementById('hideWaterfallValues');
            const showAmibrokerValues = document.getElementById('showAmibrokerValues');
            const hideAmibrokerValues = document.getElementById('hideAmibrokerValues');
            const showLotpnltaxValues = document.getElementById('showLotpnltaxValues');
            const hideLotpnltaxValues = document.getElementById('hideLotpnltaxValues');
            
            if (showPnlBarValues && hidePnlBarValues) {
                showPnlBarValues.addEventListener('click', () => {
                    showValues.pnlbar = true;
                    showPnlBarValues.classList.add('active');
                    hidePnlBarValues.classList.remove('active');
                    updateChart('pnlbar');
                });
                
                hidePnlBarValues.addEventListener('click', () => {
                    showValues.pnlbar = false;
                    hidePnlBarValues.classList.add('active');
                    showPnlBarValues.classList.remove('active');
                    updateChart('pnlbar');
                });
            }
            
            if (showWaterfallValues && hideWaterfallValues) {
                showWaterfallValues.addEventListener('click', () => {
                    showValues.compare = true;
                    showWaterfallValues.classList.add('active');
                    hideWaterfallValues.classList.remove('active');
                    updateChart('compare');
                });
                
                hideWaterfallValues.addEventListener('click', () => {
                    showValues.compare = false;
                    hideWaterfallValues.classList.add('active');
                    showWaterfallValues.classList.remove('active');
                    updateChart('compare');
                });
            }
            
            if (showAmibrokerValues && hideAmibrokerValues) {
                showAmibrokerValues.addEventListener('click', () => {
                    showValues.amibroker = true;
                    showAmibrokerValues.classList.add('active');
                    hideAmibrokerValues.classList.remove('active');
                    updateChart('amibroker');
                });
                
                hideAmibrokerValues.addEventListener('click', () => {
                    showValues.amibroker = false;
                    hideAmibrokerValues.classList.add('active');
                    showAmibrokerValues.classList.remove('active');
                    updateChart('amibroker');
                });
            }
            
            if (showLotpnltaxValues && hideLotpnltaxValues) {
                showLotpnltaxValues.addEventListener('click', () => {
                    showValues.lotpnltax = true;
                    showLotpnltaxValues.classList.add('active');
                    hideLotpnltaxValues.classList.remove('active');
                    updateChart('lotpnltax');
                });
                
                hideLotpnltaxValues.addEventListener('click', () => {
                    showValues.lotpnltax = false;
                    hideLotpnltaxValues.classList.add('active');
                    showLotpnltaxValues.classList.remove('active');
                    updateChart('lotpnltax');
                });
            }
        }
        
        function updateMonthDisplay() {
            const monthDisplay = document.getElementById('currentMonth');
            const prevBtn = document.getElementById('prevMonth');
            const nextBtn = document.getElementById('nextMonth');
            
            if (monthDisplay && availableMonths.length > 0) {
                const currentMonth = availableMonths[currentMonthIndex];
                monthDisplay.textContent = currentMonth;
            }
            
            // Enable/disable navigation buttons
            if (prevBtn) {
                prevBtn.disabled = currentMonthIndex <= 0;
            }
            if (nextBtn) {
                nextBtn.disabled = currentMonthIndex >= availableMonths.length - 1;
            }
        }

        function handleParentMessage(event) {
            const { type, data } = event.data;
            
            if (type === 'TRADES_DATA' && data) {
                allTrades = data;
                // Store updated data
                try {
                    localStorage.setItem('dashboardData', JSON.stringify({ tradesData: allTrades }));
                } catch (e) {
                    // Ignore storage errors
                }
                // Initialize date pickers with new data
                initializeDatePickers();
                // Force refresh all charts
                refreshAllCharts();
            } else if (type === 'UPDATE_DATA' && data) {
                allTrades = data.tradesData || [];
                // Store updated data
                try {
                    localStorage.setItem('dashboardData', JSON.stringify({ tradesData: allTrades }));
                } catch (e) {
                    // Ignore storage errors
                }
                // Initialize date pickers with new data
                initializeDatePickers();
                // Force refresh all charts
                refreshAllCharts();
            }
        }
        
        function refreshAllCharts() {
            // Clear any cached data in charts
            if (charts.compare) {
                charts.compare._cacheKey = null;
                charts.compare._cachedStrategies = null;
                charts.compare._cachedTotalValue = null;
            }
            if (charts.amibroker) {
                charts.amibroker._cacheKey = null;
                charts.amibroker._cachedStrategies = null;
                charts.amibroker._cachedTotalValue = null;
            }
            if (charts.lotpnltax) {
                charts.lotpnltax._cacheKey = null;
                charts.lotpnltax._cachedStrategies = null;
                charts.lotpnltax._cachedTotalValue = null;
            }
            
            // Reset available months for waterfall chart
            availableMonths = [];
            currentMonthIndex = 0;
            
            // Update all charts
            updateAllCharts();
        }

        function loadStoredData() {
            try {
                const stored = localStorage.getItem('dashboardData');
                if (stored) {
                    const data = JSON.parse(stored);
                    allTrades = data.tradesData || data || [];
                    filterTradesByDateRange(); // Initialize filtered trades
                    if (allTrades.length > 0) {
                        initializeDatePickers(); // Set date picker min/max from trades
                        refreshAllCharts();
                    }
                }
            } catch (e) {
                // Ignore parse errors
            }
        }
        
        // Helper function to get the active trades based on date range selection
        function getActiveTrades() {
            return selectedDateRange === 'all' ? allTrades : filteredTrades;
        }
        
        // Initialize date range pickers with available dates from trades
        function initializeDatePickers() {
            if (allTrades.length === 0) return;
            
            let minDate = null;
            let maxDate = null;
            
            allTrades.forEach(trade => {
                if (!trade.date) return;
                
                const parts = trade.date.split('/');
                if (parts.length !== 3) return;
                
                const day = parseInt(parts[0]);
                const month = parseInt(parts[1]) - 1;
                const year = parseInt(parts[2]);
                const fullYear = year < 100 ? (year > 50 ? 1900 + year : 2000 + year) : year;
                
                const tradeDate = new Date(fullYear, month, day);
                
                if (!minDate || tradeDate < minDate) {
                    minDate = tradeDate;
                }
                if (!maxDate || tradeDate > maxDate) {
                    maxDate = tradeDate;
                }
            });
            
            if (minDate && maxDate) {
                const fromInput = document.getElementById('fromDate');
                const toInput = document.getElementById('toDate');
                
                // Format dates as YYYY-MM-DD
                const formatDate = (date) => {
                    const year = date.getFullYear();
                    const month = String(date.getMonth() + 1).padStart(2, '0');
                    const day = String(date.getDate()).padStart(2, '0');
                    return `${year}-${month}-${day}`;
                };
                
                fromInput.min = formatDate(minDate);
                fromInput.max = formatDate(maxDate);
                toInput.min = formatDate(minDate);
                toInput.max = formatDate(maxDate);
                
                // Set default values
                fromInput.value = formatDate(minDate);
                toInput.value = formatDate(maxDate);
            }
        }
        
        // Apply custom date range filter
        function applyCustomDateRange() {
            const fromInput = document.getElementById('fromDate');
            const toInput = document.getElementById('toDate');
            
            if (!fromInput.value || !toInput.value) return;
            
            customFromDate = new Date(fromInput.value);
            customToDate = new Date(toInput.value);
            
            // Validate that from date is before to date
            if (customFromDate > customToDate) {
                alert('Start date must be before end date');
                return;
            }
            
            selectedDateRange = 'custom';
            
            // Update button active states
            document.querySelectorAll('.date-range-btn').forEach(btn => {
                btn.classList.remove('active');
            });
            document.getElementById('customDateRange').classList.add('active');
            
            // Filter and refresh
            filterTradesByDateRange();
            refreshAllCharts();
        }

        // Calculate daily total margins using the exact same logic as Strategy Performance
        function calculateDailyTotalMargins(sortedTrades, allStrategiesParam) {
            const result = {};
            const tradesByDate = {};
            sortedTrades.forEach(trade => {
                const dateKey = trade.date;
                if (!tradesByDate[dateKey]) {
                    tradesByDate[dateKey] = [];
                }
                tradesByDate[dateKey].push(trade);
            });
            const sortedDates = Object.keys(tradesByDate).sort((a, b) => {
                const dateA = a.split('/').reverse().join('');
                const dateB = b.split('/').reverse().join('');
                return dateA.localeCompare(dateB);
            });
            const brokerPnlTaxByDate = {};
            sortedTrades.forEach(trade => {
                const tradeDate = trade.date;
                if (!brokerPnlTaxByDate[tradeDate]) {
                    brokerPnlTaxByDate[tradeDate] = {};
                }
                if (trade && trade.strategyPnlTax) {
                    Object.entries(trade.strategyPnlTax).forEach(([stratName, pnlTax]) => {
                        if (!stratName.startsWith('A.PRO')) {
                            const cleanName = stratName.replace(/\s+/g, '');
                            const brokerMatch = cleanName.match(/^(.+?)PRO/);
                            if (brokerMatch) {
                                const brokerCode = brokerMatch[1];
                                if (!brokerPnlTaxByDate[tradeDate][brokerCode]) {
                                    brokerPnlTaxByDate[tradeDate][brokerCode] = {};
                                }
                                if (!brokerPnlTaxByDate[tradeDate][brokerCode][stratName]) {
                                    brokerPnlTaxByDate[tradeDate][brokerCode][stratName] = 0;
                                }
                                brokerPnlTaxByDate[tradeDate][brokerCode][stratName] += pnlTax;
                            }
                        }
                    });
                }
            });
            let previousDayBrokerMaxMargins = {};
            const brokerMarginDates = {}; // Track which date each broker's margin comes from
            sortedDates.forEach((dateKey, dateIndex) => {
                const dayTrades = tradesByDate[dateKey];
                const dayBrokerMargins = {};
                dayTrades.forEach(trade => {
                    if (trade.strategyDetails) {
                        Object.entries(trade.strategyDetails).forEach(([stratName, details]) => {
                            if (!stratName.startsWith('A.PRO')) {
                                const margin = details.margin || 0, cleanName = stratName.replace(/\s+/g, '');
                                const brokerMatch = cleanName.match(/^(.+?)PRO/);
                                if (brokerMatch) {
                                    const brokerCode = brokerMatch[1];
                                    if (!dayBrokerMargins[brokerCode]) {
                                        dayBrokerMargins[brokerCode] = {};
                                    }
                                    if (!dayBrokerMargins[brokerCode][stratName] || margin > dayBrokerMargins[brokerCode][stratName]) {
                                        dayBrokerMargins[brokerCode][stratName] = margin;
                                    }
                                }
                            }
                        });
                    }
                });
                const currentDayBrokerMaxMargins = {};
                let dayTotalMargin = 0;
                const allBrokers = new Set([...Object.keys(dayBrokerMargins), ...Object.keys(previousDayBrokerMaxMargins)]);
                allBrokers.forEach(brokerCode => {
                    let brokerMaxMargin = 0;
                    let marginDate = dateKey;
                    if (dayBrokerMargins[brokerCode]) {
                        const margins = Object.values(dayBrokerMargins[brokerCode]);
                        if (margins.length > 0) {
                            brokerMaxMargin = Math.max(...margins);
                        }
                    }
                    if (brokerMaxMargin === 0 && previousDayBrokerMaxMargins[brokerCode]) {
                        brokerMaxMargin = previousDayBrokerMaxMargins[brokerCode];
                        marginDate = brokerMarginDates[brokerCode] || dateKey;
                    }
                    currentDayBrokerMaxMargins[brokerCode] = brokerMaxMargin;
                    brokerMarginDates[brokerCode] = marginDate;
                    dayTotalMargin += brokerMaxMargin;
                });
                let dayPnlTax = 0;
                allBrokers.forEach(brokerCode => {
                    const marginDate = brokerMarginDates[brokerCode];
                    const marginDateIndex = sortedDates.indexOf(marginDate);
                    for (let i = marginDateIndex; i <= dateIndex; i++) {
                        const checkDate = sortedDates[i];
                        if (brokerPnlTaxByDate[checkDate] && brokerPnlTaxByDate[checkDate][brokerCode]) {
                            Object.values(brokerPnlTaxByDate[checkDate][brokerCode]).forEach(pnlTax => {
                                dayPnlTax += pnlTax;
                            });
                        }
                    }
                });
                result[dateKey] = dayTotalMargin + dayPnlTax;
                previousDayBrokerMaxMargins = { ...currentDayBrokerMaxMargins };
            });
            return result;
        }

        // Data aggregation functions
        function aggregateByPeriod(trades, period) {
            if (!trades || trades.length === 0) {
                return [];
            }
            
            const sortedTrades = [...trades].sort((a, b) => {
                return compareDates(a.date, b.date);
            });
            
            // Calculate daily total margins using the same logic as Strategy Performance
            const dailyTotalMargins = calculateDailyTotalMargins(sortedTrades, []);
            
            const aggregated = new Map();
            
            sortedTrades.forEach((trade, idx) => {
                const key = getAggregationKey(trade.date, period);
                if (!aggregated.has(key)) {
                    aggregated.set(key, {
                        date: key,
                        profit: 0,
                        cumPnl: 0,
                        drawdown: 0,
                        peak: 0,
                        trades: [],
                        lastCumPnl: 0,
                        lastTradeIndex: -1,
                        totalMargin: 0,
                        lastMargin: 0
                    });
                }
                
                const agg = aggregated.get(key);
                agg.profit += trade.profit || 0;
                agg.trades.push(trade);
                
                // Keep track of the last trade (by index, since we sorted)
                agg.lastTradeIndex = idx;
                agg.lastCumPnl = trade.cumPnl !== undefined ? trade.cumPnl : 0;
                
                // Use pre-calculated daily total margin from Strategy Performance logic
                const tradeDate = trade.date;
                if (dailyTotalMargins[tradeDate]) {
                    agg.totalMargin = dailyTotalMargins[tradeDate];
                    agg.lastMargin = dailyTotalMargins[tradeDate];
                }
            });
            
            let result = Array.from(aggregated.values()).sort((a, b) => {
                return compareDates(a.date, b.date);
            });
            
            // For week and month views, fill in ALL periods from the first trade date to last trade date
            if ((period === 'week' || period === 'month') && result.length > 0) {
                result = fillMissingPeriods(result, period, sortedTrades[0].date, sortedTrades[sortedTrades.length - 1].date);
            }
            
            let peak = 0;
            let prevCumPnl = 0;
            let startingCapital = 0;  // Will be set from first period
            let cumulativeExpenses = 0;  // Track expenses/withdrawals (negative of margin additions)
            
            result.forEach((item, index) => {
                // Use the lastCumPnl from the last trade in this period
                if (item.trades.length > 0) {
                    if (item.lastCumPnl !== undefined) {
                        item.cumPnl = item.lastCumPnl;
                    } else {
                        item.cumPnl = prevCumPnl + item.profit;
                    }
                } else {
                    item.cumPnl = prevCumPnl;
                }
                
                // The totalMargin from trades already includes cumPnl (see calculateDailyTotalMargins line 1679)
                // So we need to extract the base margin WITHOUT cumPnl
                const totalMarginWithPnl = item.totalMargin || item.lastMargin || 0;
                
                if (index === 0) {
                    // First period: extract starting capital = totalMargin - cumPnl
                    startingCapital = totalMarginWithPnl - (item.cumPnl || 0);
                    cumulativeExpenses = 0;
                } else {
                    // Calculate expected total margin = startingCapital + cumPnl - cumulativeExpenses
                    const expectedTotalMargin = startingCapital + (item.cumPnl || 0) - cumulativeExpenses;
                    
                    // Calculate expenses for this period = expectedTotalMargin - actualTotalMargin
                    const periodExpense = expectedTotalMargin - totalMarginWithPnl;
                    cumulativeExpenses += periodExpense;
                }
                
                // cumMargin is simply the totalMargin (which already includes cumPnl)
                item.cumMargin = totalMarginWithPnl;
                
                // For the first period with actual trades, periodProfit should equal cumPnl
                // since there's no previous period to subtract from
                if (index === 0 && item.trades.length > 0) {
                    item.periodProfit = item.cumPnl;
                } else {
                    item.periodProfit = item.cumPnl - prevCumPnl;
                }
                
                prevCumPnl = item.cumPnl;
                
                if (item.cumPnl > peak) {
                    peak = item.cumPnl;
                }
                item.peak = peak;
                item.drawdown = item.cumPnl - peak;
            });
            
            // Filter out leading empty periods (periods with no trades at the start)
            let firstNonEmptyIndex = result.findIndex(item => item.trades.length > 0);
            if (firstNonEmptyIndex > 0) {
                result = result.slice(firstNonEmptyIndex);
                // Recalculate periodProfit for the new first period
                if (result.length > 0 && result[0].trades.length > 0) {
                    result[0].periodProfit = result[0].cumPnl;
                }
            }
            
            return result;
        }

        function fillMissingPeriods(aggregatedData, period, firstTradeDate, lastTradeDate) {
            if (aggregatedData.length === 0) return [];
            
            // Use the first and last periods from aggregated data (where trades exist)
            // not the first/last trade dates (which might be in the middle of a period)
            const firstPeriodKey = aggregatedData[0].date;
            const lastPeriodKey = aggregatedData[aggregatedData.length - 1].date;
            
            // Convert period key back to date for iteration
            const periodToDate = (periodStr) => {
                if (periodStr.startsWith('W')) {
                    // Week format: W23-23 or W23-2023 (ISO week-year format)
                    const parts = periodStr.substring(1).split('-');
                    const week = parseInt(parts[0]);
                    const year = parseInt(parts[1]);
                    const fullYear = year < 100 ? 2000 + year : year;
                    return getISOWeekDate(fullYear, week);
                } else if (periodStr.includes('-')) {
                    // Month format: Jan-23 or Jan-2023
                    const monthNames = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];
                    const parts = periodStr.split('-');
                    const monthStr = parts[0];
                    const year = parseInt(parts[1]);
                    const month = monthNames.indexOf(monthStr);
                    const fullYear = year < 100 ? 2000 + year : year;
                    return new Date(fullYear, month, 1);
                }
                return null;
            };
            
            const existingMap = new Map(aggregatedData.map(item => [item.date, item]));
            const allPeriods = [];
            
            // Generate all periods from first aggregated period to last aggregated period
            let currentDate = periodToDate(firstPeriodKey);
            const endDate = periodToDate(lastPeriodKey);
            
            if (!currentDate || !endDate) return aggregatedData;
            
            while (currentDate <= endDate) {
                // Create a dummy date string to get the period key
                const year = currentDate.getFullYear();
                const month = currentDate.getMonth() + 1;
                const day = currentDate.getDate();
                const dummyDateStr = `${day}/${month}/${year}`;
                const periodKey = getAggregationKey(dummyDateStr, period);
                
                if (existingMap.has(periodKey)) {
                    allPeriods.push(existingMap.get(periodKey));
                } else {
                    // Create empty period with no trades
                    allPeriods.push({
                        date: periodKey,
                        profit: 0,
                        cumPnl: 0,
                        drawdown: 0,
                        peak: 0,
                        trades: [],
                        lastCumPnl: 0,
                        lastTradeIndex: -1,
                        totalMargin: 0,
                        lastMargin: 0,
                        periodProfit: 0
                    });
                }
                
                // Increment by period
                if (period === 'week') {
                    currentDate.setDate(currentDate.getDate() + 7);
                } else if (period === 'month') {
                    currentDate.setMonth(currentDate.getMonth() + 1);
                }
            }
            
            return allPeriods;
        }

        function getAggregationKey(dateStr, period) {
            if (!dateStr) return '';
            
            const [day, month, year] = dateStr.split('/').map(Number);
            // Handle both 2-digit (23) and 4-digit (2023) years
            const fullYear = year < 100 ? 2000 + year : year;
            const date = new Date(fullYear, month - 1, day);
            
            if (period === 'day') {
                return dateStr; // Keep original format
            } else if (period === 'week') {
                // Get week number and the ISO week-year
                const { weekNum, weekYear } = getWeekNumberAndYear(date);
                // Format year consistently (2-digit)
                const yearSuffix = String(weekYear).slice(-2);
                return `W${weekNum}-${yearSuffix}`;
            } else if (period === 'month') {
                const monthNames = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];
                const yearSuffix = year < 100 ? String(year).padStart(2, '0') : String(year).slice(-2);
                return `${monthNames[month - 1]}-${yearSuffix}`;
            }
            
            return dateStr;
        }

        function getWeekNumber(date) {
            const result = getWeekNumberAndYear(date);
            return result.weekNum;
        }
        
        function getWeekNumberAndYear(date) {
            const d = new Date(Date.UTC(date.getFullYear(), date.getMonth(), date.getDate()));
            const dayNum = d.getUTCDay() || 7;
            d.setUTCDate(d.getUTCDate() + 4 - dayNum);
            const weekYear = d.getUTCFullYear(); // This is the ISO week-year
            const yearStart = new Date(Date.UTC(weekYear, 0, 1));
            const weekNum = Math.ceil((((d - yearStart) / 86400000) + 1) / 7);
            return { weekNum, weekYear };
        }
        
        function getISOWeekDate(year, week) {
            // Get the Thursday of week 1 (which defines week 1)
            const jan4 = new Date(Date.UTC(year, 0, 4));
            const jan4Day = jan4.getUTCDay() || 7; // Monday=1, Sunday=7
            // Get Monday of week 1
            const week1Monday = new Date(jan4);
            week1Monday.setUTCDate(jan4.getUTCDate() - jan4Day + 1);
            // Add weeks to get to target week
            const targetMonday = new Date(week1Monday);
            targetMonday.setUTCDate(week1Monday.getUTCDate() + (week - 1) * 7);
            return new Date(targetMonday.getUTCFullYear(), targetMonday.getUTCMonth(), targetMonday.getUTCDate());
        }

        function compareDates(dateStr1, dateStr2) {
            // Handle different formats
            const parseDate = (str) => {
                if (str.startsWith('W')) {
                    // Week format: W23-23 or W23-2023 (ISO week-year format)
                    const [week, year] = str.substring(1).split('-').map(Number);
                    const fullYear = year < 100 ? 2000 + year : year;
                    // Get the Monday of this ISO week
                    return getISOWeekDate(fullYear, week);
                } else if (str.includes('-') && str.length <= 10) {
                    // Month format: Jan-23 or Jan-2023
                    const monthNames = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];
                    const [monthStr, year] = str.split('-');
                    const month = monthNames.indexOf(monthStr);
                    const fullYear = parseInt(year) < 100 ? 2000 + parseInt(year) : parseInt(year);
                    return new Date(fullYear, month, 1);
                } else {
                    // Day format: 15/05/23 or 15/05/2023
                    const [day, month, year] = str.split('/').map(Number);
                    const fullYear = year < 100 ? 2000 + year : year;
                    return new Date(fullYear, month - 1, day);
                }
            };
            
            return parseDate(dateStr1) - parseDate(dateStr2);
        }

        // Aggregate trades by strategy and period for comparison chart
        function aggregateByStrategyAndPeriod(trades, period) {
            if (!trades || trades.length === 0) {
                return { labels: [], strategies: {} };
            }
            
            const sortedTrades = [...trades].sort((a, b) => {
                return compareDates(a.date, b.date);
            });
            
            // Get unique strategies
            const strategies = {};
            const periodKeys = new Set();
            
            // Group trades by strategy and period
            sortedTrades.forEach(trade => {
                const strategy = trade.strategy || 'Unknown';
                const periodKey = getAggregationKey(trade.date, period);
                
                if (!strategies[strategy]) {
                    strategies[strategy] = new Map();
                }
                
                if (!strategies[strategy].has(periodKey)) {
                    strategies[strategy].set(periodKey, {
                        date: periodKey,
                        profit: 0,
                        trades: [],
                        lastCumPnl: 0
                    });
                }
                
                const agg = strategies[strategy].get(periodKey);
                agg.profit += trade.profit || 0;
                agg.trades.push(trade);
                agg.lastCumPnl = trade.cumPnl !== undefined ? trade.cumPnl : 0;
                
                periodKeys.add(periodKey);
            });
            
            // Convert to sorted arrays and calculate cumulative values per strategy
            const sortedPeriods = Array.from(periodKeys).sort((a, b) => compareDates(a, b));
            
            const result = { labels: sortedPeriods, strategies: {} };
            
            for (const [strategyName, periodMap] of Object.entries(strategies)) {
                const strategyData = [];
                let strategyCumPnl = 0;
                
                sortedPeriods.forEach(periodKey => {
                    if (periodMap.has(periodKey)) {
                        const periodData = periodMap.get(periodKey);
                        // Add the profit from this period to strategy cumulative
                        strategyCumPnl += periodData.profit;
                        strategyData.push(strategyCumPnl);
                    } else {
                        // No trades in this period for this strategy
                        if (period === 'day') {
                            // For day view: carry forward the previous value (line continues)
                            strategyData.push(strategyCumPnl);
                        } else {
                            // For week/month view: create a gap in the line
                            strategyData.push(null);
                        }
                    }
                });
                
                result.strategies[strategyName] = strategyData;
            }
            
            return result;
        }

        function formatLabel(dateStr, period) {
            if (period === 'day') {
                const [day, month] = dateStr.split('/');
                const monthNames = ['JAN', 'FEB', 'MAR', 'APR', 'MAY', 'JUN', 'JUL', 'AUG', 'SEP', 'OCT', 'NOV', 'DEC'];
                return `${day.padStart(2, '0')}-${monthNames[parseInt(month) - 1] || ''}`;
            } else if (period === 'week') {
                return dateStr; // Already formatted as W23-23
            } else {
                return dateStr; // Already formatted as Jan-23
            }
        }

        // Chart initialization
        function initializeCharts() {
            const commonOptions = {
                responsive: true,
                maintainAspectRatio: false,
                plugins: {
                    legend: { display: false },
                    tooltip: {
                        backgroundColor: 'white',
                        borderWidth: 2,
                        padding: 14,
                        displayColors: false,
                        titleFont: { size: 12, weight: '600', family: '-apple-system, BlinkMacSystemFont, "Segoe UI", Roboto' },
                        bodyFont: { size: 14, weight: '700', family: '-apple-system, BlinkMacSystemFont, "Segoe UI", Roboto' },
                        cornerRadius: 8,
                        caretSize: 6,
                        titleColor: '#64748b',
                        bodyColor: '#1e293b'
                    }
                },
                scales: {
                    y: {
                        display: true,
                        position: 'right',
                        grid: { 
                            color: 'rgba(148, 163, 184, 0.08)',
                            lineWidth: 1,
                            drawBorder: false,
                            drawTicks: false
                        },
                        border: { display: false },
                        ticks: {
                            font: { size: 10, weight: '500', family: '-apple-system, BlinkMacSystemFont, "Segoe UI", Roboto' },
                            color: '#94a3b8',
                            padding: 8,
                            maxTicksLimit: 8,
                            callback: value => {
                                if (value === 0) return '₹0';
                                if (Math.abs(value) >= 100000) return `₹${Math.round(value / 100000)}L`;
                                if (Math.abs(value) >= 1000) return `₹${Math.round(value / 1000)}K`;
                                return `₹${Math.round(value)}`;
                            }
                        }
                    },
                    x: {
                        display: true,
                        grid: { display: false, drawBorder: false },
                        border: { display: false },
                        ticks: {
                            font: { size: 10, weight: '500', family: '-apple-system, BlinkMacSystemFont, "Segoe UI", Roboto' },
                            color: '#94a3b8',
                            maxTicksLimit: 10,
                            padding: 6
                        }
                    }
                },
                interaction: { intersect: false, mode: 'index' },
                elements: {
                    line: {
                        borderCapStyle: 'round',
                        borderJoinStyle: 'round'
                    }
                }
            };

            // Cumulative P&L Chart
            charts.pnl = new Chart(elements.pnlChart, {
                type: 'line',
                data: { labels: [], datasets: [{ data: [], borderColor: '#059669', backgroundColor: createGradient(elements.pnlChart, '#059669'), borderWidth: 3, pointRadius: 0, pointHoverRadius: 6, pointHoverBackgroundColor: '#059669', pointHoverBorderColor: '#fff', pointHoverBorderWidth: 2, fill: true, tension: 0.4 }] },
                options: {
                    ...commonOptions,
                    plugins: {
                        ...commonOptions.plugins,
                        tooltip: {
                            ...commonOptions.plugins.tooltip,
                            borderColor: '#059669',
                            callbacks: {
                                title: ctx => ctx[0].label,
                                label: ctx => `₹${formatIndianNumber(ctx.parsed.y, 2)}`
                            }
                        }
                    }
                }
            });

            // Drawdown Chart
            charts.drawdown = new Chart(elements.drawdownChart, {
                type: 'line',
                data: { labels: [], datasets: [{ data: [], borderColor: '#dc2626', backgroundColor: createGradient(elements.drawdownChart, '#dc2626'), borderWidth: 3, pointRadius: 0, pointHoverRadius: 6, pointHoverBackgroundColor: '#dc2626', pointHoverBorderColor: '#fff', pointHoverBorderWidth: 2, fill: true, tension: 0.4 }] },
                options: {
                    ...commonOptions,
                    plugins: {
                        ...commonOptions.plugins,
                        tooltip: {
                            ...commonOptions.plugins.tooltip,
                            borderColor: '#dc2626',
                            callbacks: {
                                title: ctx => ctx[0].label,
                                label: ctx => `₹${formatIndianNumber(ctx.parsed.y, 2)}`
                            }
                        }
                    }
                }
            });

            // Periodic Returns Chart
            charts.pnlbar = new Chart(elements.pnlBarChart, {
                type: 'bar',
                data: { 
                    labels: [], 
                    datasets: [{ 
                        data: [], 
                        backgroundColor: [],
                        borderWidth: 0,
                        borderRadius: 6,
                        barPercentage: 0.7,
                        categoryPercentage: 0.8
                    }] 
                },
                options: {
                    ...commonOptions,
                    plugins: {
                        ...commonOptions.plugins,
                        tooltip: {
                            ...commonOptions.plugins.tooltip,
                            borderColor: '#059669',
                            callbacks: {
                                title: ctx => ctx[0].label,
                                label: ctx => `₹${formatIndianNumber(ctx.parsed.y, 2)}`
                            }
                        }
                    },
                    scales: {
                        ...commonOptions.scales,
                        y: {
                            ...commonOptions.scales.y,
                            beginAtZero: true,
                            grace: '5%'
                        }
                    }
                },
                plugins: [{
                    id: 'barLabels',
                    afterDatasetsDraw(chart) {
                        // Only show labels if showValues.pnlbar is true
                        if (!showValues.pnlbar) {
                            return;
                        }
                        
                        const { ctx, data } = chart;
                        chart.getDatasetMeta(0).data.forEach((bar, index) => {
                            const value = data.datasets[0].data[index];
                            
                            // Format value based on display type
                            let label;
                            if (displayTypes.pnlbar === 'percentage') {
                                label = value.toFixed(2) + '%';
                            } else {
                                label = formatIndianShort(value);
                            }
                            
                            // Style
                            ctx.save();
                            ctx.font = '600 11px -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto';
                            ctx.fillStyle = value >= 0 ? '#059669' : '#c2410c';
                            ctx.textAlign = 'center';
                            
                            // Position above bar for positive, below bar for negative
                            const x = bar.x;
                            let y;
                            if (value >= 0) {
                                ctx.textBaseline = 'bottom';
                                y = bar.y - 5; // Above the bar
                            } else {
                                ctx.textBaseline = 'top';
                                y = bar.y + 5; // Below the bar (bar.y is at top of negative bar)
                            }
                            
                            ctx.fillText(label, x, y);
                            ctx.restore();
                        });
                    }
                }]
            });
            // Monthly Contribution Breakdown (Waterfall) Chart
            charts.compare = new Chart(elements.compareChart, {
                type: 'bar',
                data: { 
                    labels: [], 
                    datasets: [{
                        data: [],
                        backgroundColor: [],
                        borderWidth: 0,
                        borderRadius: 6,
                        barPercentage: 0.6,
                        categoryPercentage: 0.8,
                        // Enable floating bars
                        barThickness: 'flex'
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: { 
                            display: true,
                            position: 'bottom',
                            align: 'center',
                            onClick: (e, legendItem, legend) => {
                                // Interactive legend - toggle strategy visibility
                                const strategyName = legendItem.text;
                                const chart = legend.chart;
                                
                                if (hiddenStrategies.compare.has(strategyName)) {
                                    hiddenStrategies.compare.delete(strategyName);
                                } else {
                                    hiddenStrategies.compare.add(strategyName);
                                }
                                
                                // Update the chart with filtered data
                                updateChart('compare');
                            },
                            labels: {
                                boxWidth: 12,
                                boxHeight: 12,
                                padding: 15,
                                font: { 
                                    size: 10, 
                                    weight: '500',
                                    family: '-apple-system, BlinkMacSystemFont, "Segoe UI", Roboto'
                                },
                                color: '#94a3b8',
                                usePointStyle: false,
                                generateLabels: (chart) => {
                                    // Create custom legend for waterfall - show ALL strategies including hidden ones
                                    const allStrategies = chart._allStrategies || [];
                                    const allColors = chart._allColors || [];
                                    const legendItems = [];
                                    
                                    // Helper function to add transparency to color
                                    const addTransparency = (color, opacity = 0.7) => {
                                        if (color.startsWith('#')) {
                                            const r = parseInt(color.slice(1, 3), 16);
                                            const g = parseInt(color.slice(3, 5), 16);
                                            const b = parseInt(color.slice(5, 7), 16);
                                            return `rgba(${r}, ${g}, ${b}, ${opacity})`;
                                        }
                                        return color;
                                    };
                                    
                                    allStrategies.forEach((stratName, i) => {
                                        const originalColor = allColors[i] || '#94a3b8';
                                        const isHidden = hiddenStrategies.compare.has(stratName);
                                        legendItems.push({
                                            text: stratName,
                                            fillStyle: isHidden ? addTransparency(originalColor, 0.3) : addTransparency(originalColor, 0.7),
                                            strokeStyle: isHidden ? '#cbd5e1' : 'transparent',
                                            lineWidth: isHidden ? 1 : 0,
                                            hidden: false,
                                            fontColor: isHidden ? '#cbd5e1' : '#94a3b8',
                                            datasetIndex: 0,
                                            index: i
                                        });
                                    });
                                    
                                    return legendItems;
                                }
                            }
                        },
                        tooltip: {
                            backgroundColor: 'white',
                            borderWidth: 2,
                            borderColor: '#e5e7eb',
                            padding: 14,
                            displayColors: false,
                            titleFont: { 
                                size: 12, 
                                weight: '600',
                                family: '-apple-system, BlinkMacSystemFont, "Segoe UI", Roboto'
                            },
                            bodyFont: { 
                                size: 14, 
                                weight: '700',
                                family: '-apple-system, BlinkMacSystemFont, "Segoe UI", Roboto'
                            },
                            cornerRadius: 8,
                            caretSize: 6,
                            titleColor: '#64748b',
                            bodyColor: '#1e293b',
                            callbacks: {
                                title: ctx => ctx[0].label,
                                label: ctx => {
                                    // Use stored contribution if available, otherwise calculate
                                    let value;
                                    let total;
                                    if (charts.compare && charts.compare._contributions) {
                                        value = charts.compare._contributions[ctx.dataIndex];
                                        total = charts.compare._totalValue;
                                    } else {
                                        value = Array.isArray(ctx.parsed.y) 
                                            ? ctx.parsed.y[1] - ctx.parsed.y[0]
                                            : ctx.parsed.y;
                                        total = value; // Fallback
                                    }
                                    
                                    if (displayTypes.compare === 'percentage') {
                                        // Calculate percentage of total
                                        if (!total || total === 0) {
                                            return '0.00%';
                                        }
                                        const percentValue = (value / Math.abs(total)) * 100;
                                        const sign = percentValue < 0 ? '-' : '';
                                        return `${sign}${Math.abs(percentValue).toFixed(2)}%`;
                                    }
                                    const sign = value < 0 ? '-' : '';
                                    return `${sign}₹${formatIndianNumber(Math.abs(value), 2)}`;
                                }
                            }
                        }
                    },
                    scales: {
                        y: {
                            display: true,
                            position: 'right',
                            beginAtZero: true,
                            grid: { 
                                color: 'rgba(148, 163, 184, 0.08)',
                                lineWidth: 1,
                                drawBorder: false,
                                drawTicks: false
                            },
                            border: {
                                display: false
                            },
                            ticks: {
                                font: { 
                                    size: 10, 
                                    weight: '500',
                                    family: '-apple-system, BlinkMacSystemFont, "Segoe UI", Roboto' 
                                },
                                color: '#94a3b8',
                                padding: 8,
                                maxTicksLimit: 8,
                                callback: value => {
                                    if (displayTypes.compare === 'percentage') {
                                        return value.toFixed(1) + '%';
                                    }
                                    if (value === 0) return '₹0';
                                    if (Math.abs(value) >= 100000) return `₹${Math.round(value / 100000)}L`;
                                    if (Math.abs(value) >= 1000) return `₹${Math.round(value / 1000)}K`;
                                    return `₹${Math.round(value)}`;
                                }
                            }
                        },
                        x: {
                            display: true,
                            grid: { 
                                display: false,
                                drawBorder: false
                            },
                            border: {
                                display: false
                            },
                            ticks: {
                                font: { 
                                    size: 10, 
                                    weight: '500',
                                    family: '-apple-system, BlinkMacSystemFont, "Segoe UI", Roboto'
                                },
                                color: '#94a3b8',
                                padding: 6
                            }
                        }
                    },
                    interaction: { 
                        intersect: false, 
                        mode: 'index' 
                    }
                },
                plugins: [{
                    id: 'waterfallLabels',
                    afterDatasetsDraw(chart) {
                        // Only show labels if showValues.compare is true
                        if (!showValues.compare) {
                            return;
                        }
                        
                        const { ctx, data, scales } = chart;
                        const meta = chart.getDatasetMeta(0);
                        const yScale = scales.y;
                        
                        // Use pre-calculated labels if available
                        const labels = chart._preCalculatedLabels || [];
                        
                        meta.data.forEach((bar, index) => {
                            if (!labels[index]) return;
                            
                            const { label, value } = labels[index];
                            
                            // Style
                            ctx.save();
                            ctx.font = '600 11px -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto';
                            ctx.fillStyle = value >= 0 ? '#10b981' : '#c2410c';
                            ctx.textAlign = 'center';
                            
                            // Position label based on value
                            const x = bar.x;
                            let y;
                            
                            // Get the bar data array [min, max]
                            const barData = data.datasets[0].data[index];
                            
                            if (Array.isArray(barData)) {
                                // Floating bar - use the max value (top of bar)
                                const topValue = Math.max(barData[0], barData[1]);
                                const bottomValue = Math.min(barData[0], barData[1]);
                                
                                if (value >= 0) {
                                    // Positive: label above the bar (above topValue)
                                    ctx.textBaseline = 'bottom';
                                    y = yScale.getPixelForValue(topValue) - 5;
                                } else {
                                    // Negative: label below the bar (below bottomValue)
                                    ctx.textBaseline = 'top';
                                    y = yScale.getPixelForValue(bottomValue) + 5;
                                }
                            } else {
                                // Regular bar
                                if (value >= 0) {
                                    ctx.textBaseline = 'bottom';
                                    y = bar.y - 5;
                                } else {
                                    ctx.textBaseline = 'top';
                                    y = bar.y + 5;
                                }
                            }
                            
                            ctx.fillText(label, x, y);
                            ctx.restore();
                        });
                    }
                }]
            });
            
            // Amibroker strategy PNL Chart
            charts.amibroker = new Chart(elements.amibrokerChart, {
                type: 'bar',
                data: { 
                    labels: [], 
                    datasets: [{
                        data: [],
                        backgroundColor: [],
                        borderWidth: 0,
                        borderRadius: 6,
                        barPercentage: 0.6,
                        categoryPercentage: 0.8,
                        barThickness: 'flex'
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: { 
                            display: true,
                            position: 'bottom',
                            align: 'center',
                            onClick: (e, legendItem, legend) => {
                                // Interactive legend - toggle strategy visibility
                                const strategyName = legendItem.text;
                                const chart = legend.chart;
                                
                                if (hiddenStrategies.amibroker.has(strategyName)) {
                                    hiddenStrategies.amibroker.delete(strategyName);
                                } else {
                                    hiddenStrategies.amibroker.add(strategyName);
                                }
                                
                                // Update the chart with filtered data
                                updateChart('amibroker');
                            },
                            labels: {
                                boxWidth: 12,
                                boxHeight: 12,
                                padding: 15,
                                font: { 
                                    size: 10, 
                                    weight: '500',
                                    family: '-apple-system, BlinkMacSystemFont, "Segoe UI", Roboto'
                                },
                                color: '#94a3b8',
                                usePointStyle: false,
                                generateLabels: (chart) => {
                                    // Show ALL strategies including hidden ones
                                    const allStrategies = chart._allStrategies || [];
                                    const allColors = chart._allColors || [];
                                    const legendItems = [];
                                    
                                    const addTransparency = (color, opacity = 0.7) => {
                                        if (color.startsWith('#')) {
                                            const r = parseInt(color.slice(1, 3), 16);
                                            const g = parseInt(color.slice(3, 5), 16);
                                            const b = parseInt(color.slice(5, 7), 16);
                                            return `rgba(${r}, ${g}, ${b}, ${opacity})`;
                                        }
                                        return color;
                                    };
                                    
                                    allStrategies.forEach((stratName, i) => {
                                        const originalColor = allColors[i] || '#94a3b8';
                                        const isHidden = hiddenStrategies.amibroker.has(stratName);
                                        legendItems.push({
                                            text: stratName,
                                            fillStyle: isHidden ? addTransparency(originalColor, 0.3) : addTransparency(originalColor, 0.7),
                                            strokeStyle: isHidden ? '#cbd5e1' : 'transparent',
                                            lineWidth: isHidden ? 1 : 0,
                                            hidden: false,
                                            fontColor: isHidden ? '#cbd5e1' : '#94a3b8',
                                            datasetIndex: 0,
                                            index: i
                                        });
                                    });
                                    
                                    return legendItems;
                                }
                            }
                        },
                        tooltip: {
                            backgroundColor: 'white',
                            borderWidth: 2,
                            borderColor: '#e5e7eb',
                            padding: 14,
                            displayColors: false,
                            titleFont: { 
                                size: 12, 
                                weight: '600',
                                family: '-apple-system, BlinkMacSystemFont, "Segoe UI", Roboto'
                            },
                            bodyFont: { 
                                size: 14, 
                                weight: '700',
                                family: '-apple-system, BlinkMacSystemFont, "Segoe UI", Roboto'
                            },
                            cornerRadius: 8,
                            caretSize: 6,
                            titleColor: '#64748b',
                            bodyColor: '#1e293b',
                            callbacks: {
                                title: ctx => ctx[0].label,
                                label: ctx => {
                                    let value;
                                    let total;
                                    if (charts.amibroker && charts.amibroker._contributions) {
                                        value = charts.amibroker._contributions[ctx.dataIndex];
                                        total = charts.amibroker._totalValue;
                                    } else {
                                        value = Array.isArray(ctx.parsed.y) 
                                            ? ctx.parsed.y[1] - ctx.parsed.y[0]
                                            : ctx.parsed.y;
                                        total = value;
                                    }
                                    
                                    if (displayTypes.amibroker === 'percentage') {
                                        if (!total || total === 0) {
                                            return '0.00%';
                                        }
                                        const percentValue = (value / Math.abs(total)) * 100;
                                        const sign = percentValue < 0 ? '-' : '';
                                        return `${sign}${Math.abs(percentValue).toFixed(2)}%`;
                                    }
                                    const sign = value < 0 ? '-' : '';
                                    return `${sign}₹${formatIndianNumber(Math.abs(value), 2)}`;
                                }
                            }
                        }
                    },
                    scales: {
                        y: {
                            display: true,
                            position: 'right',
                            beginAtZero: true,
                            grid: { 
                                color: 'rgba(148, 163, 184, 0.08)',
                                lineWidth: 1,
                                drawBorder: false,
                                drawTicks: false
                            },
                            border: {
                                display: false
                            },
                            ticks: {
                                font: { 
                                    size: 10, 
                                    weight: '500',
                                    family: '-apple-system, BlinkMacSystemFont, "Segoe UI", Roboto' 
                                },
                                color: '#94a3b8',
                                padding: 8,
                                maxTicksLimit: 8,
                                callback: value => {
                                    if (displayTypes.amibroker === 'percentage') {
                                        return value.toFixed(1) + '%';
                                    }
                                    if (value === 0) return '₹0';
                                    if (Math.abs(value) >= 100000) return `₹${Math.round(value / 100000)}L`;
                                    if (Math.abs(value) >= 1000) return `₹${Math.round(value / 1000)}K`;
                                    return `₹${Math.round(value)}`;
                                }
                            }
                        },
                        x: {
                            display: true,
                            grid: { 
                                display: false,
                                drawBorder: false
                            },
                            border: {
                                display: false
                            },
                            ticks: {
                                font: { 
                                    size: 10, 
                                    weight: '500',
                                    family: '-apple-system, BlinkMacSystemFont, "Segoe UI", Roboto'
                                },
                                color: '#94a3b8',
                                padding: 6
                            }
                        }
                    },
                    interaction: { 
                        intersect: false, 
                        mode: 'index' 
                    }
                },
                plugins: [{
                    id: 'amibrokerLabels',
                    afterDatasetsDraw(chart) {
                        if (!showValues.amibroker) {
                            return;
                        }
                        
                        const { ctx, data, scales } = chart;
                        const meta = chart.getDatasetMeta(0);
                        const yScale = scales.y;
                        
                        const labels = chart._preCalculatedLabels || [];
                        
                        meta.data.forEach((bar, index) => {
                            if (!labels[index]) return;
                            
                            const { label, value } = labels[index];
                            
                            ctx.save();
                            ctx.font = '600 11px -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto';
                            ctx.fillStyle = value >= 0 ? '#10b981' : '#c2410c';
                            ctx.textAlign = 'center';
                            
                            const x = bar.x;
                            let y;
                            
                            const barData = data.datasets[0].data[index];
                            
                            if (Array.isArray(barData)) {
                                const topValue = Math.max(barData[0], barData[1]);
                                const bottomValue = Math.min(barData[0], barData[1]);
                                
                                if (value >= 0) {
                                    ctx.textBaseline = 'bottom';
                                    y = yScale.getPixelForValue(topValue) - 5;
                                } else {
                                    ctx.textBaseline = 'top';
                                    y = yScale.getPixelForValue(bottomValue) + 5;
                                }
                            } else {
                                if (value >= 0) {
                                    ctx.textBaseline = 'bottom';
                                    y = bar.y - 5;
                                } else {
                                    ctx.textBaseline = 'top';
                                    y = bar.y + 5;
                                }
                            }
                            
                            ctx.fillText(label, x, y);
                            ctx.restore();
                        });
                    }
                }]
            });
            
            // LOT PNLTAX Chart
            charts.lotpnltax = new Chart(elements.lotpnltaxChart, {
                type: 'bar',
                data: { 
                    labels: [], 
                    datasets: [{
                        data: [],
                        backgroundColor: [],
                        borderWidth: 0,
                        borderRadius: 6,
                        barPercentage: 0.6,
                        categoryPercentage: 0.8,
                        barThickness: 'flex'
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: { 
                            display: true,
                            position: 'bottom',
                            align: 'center',
                            onClick: (e, legendItem, legend) => {
                                // Interactive legend - toggle strategy visibility
                                const strategyName = legendItem.text;
                                const chart = legend.chart;
                                
                                if (hiddenStrategies.lotpnltax.has(strategyName)) {
                                    hiddenStrategies.lotpnltax.delete(strategyName);
                                } else {
                                    hiddenStrategies.lotpnltax.add(strategyName);
                                }
                                
                                // Update the chart with filtered data
                                updateChart('lotpnltax');
                            },
                            labels: {
                                boxWidth: 12,
                                boxHeight: 12,
                                padding: 15,
                                font: { 
                                    size: 10, 
                                    weight: '500',
                                    family: '-apple-system, BlinkMacSystemFont, "Segoe UI", Roboto'
                                },
                                color: '#94a3b8',
                                usePointStyle: false,
                                generateLabels: (chart) => {
                                    // Show ALL strategies including hidden ones
                                    const allStrategies = chart._allStrategies || [];
                                    const allColors = chart._allColors || [];
                                    const legendItems = [];
                                    
                                    const addTransparency = (color, opacity = 0.7) => {
                                        if (color.startsWith('#')) {
                                            const r = parseInt(color.slice(1, 3), 16);
                                            const g = parseInt(color.slice(3, 5), 16);
                                            const b = parseInt(color.slice(5, 7), 16);
                                            return `rgba(${r}, ${g}, ${b}, ${opacity})`;
                                        }
                                        return color;
                                    };
                                    
                                    allStrategies.forEach((stratName, i) => {
                                        const originalColor = allColors[i] || '#94a3b8';
                                        const isHidden = hiddenStrategies.lotpnltax.has(stratName);
                                        legendItems.push({
                                            text: stratName,
                                            fillStyle: isHidden ? addTransparency(originalColor, 0.3) : addTransparency(originalColor, 0.7),
                                            strokeStyle: isHidden ? '#cbd5e1' : 'transparent',
                                            lineWidth: isHidden ? 1 : 0,
                                            hidden: false,
                                            fontColor: isHidden ? '#cbd5e1' : '#94a3b8',
                                            datasetIndex: 0,
                                            index: i
                                        });
                                    });
                                    
                                    return legendItems;
                                }
                            }
                        },
                        tooltip: {
                            backgroundColor: 'white',
                            borderWidth: 2,
                            borderColor: '#e5e7eb',
                            padding: 14,
                            displayColors: false,
                            titleFont: { 
                                size: 12, 
                                weight: '600',
                                family: '-apple-system, BlinkMacSystemFont, "Segoe UI", Roboto'
                            },
                            bodyFont: { 
                                size: 14, 
                                weight: '700',
                                family: '-apple-system, BlinkMacSystemFont, "Segoe UI", Roboto'
                            },
                            cornerRadius: 8,
                            caretSize: 6,
                            titleColor: '#64748b',
                            bodyColor: '#1e293b',
                            callbacks: {
                                title: ctx => ctx[0].label,
                                label: ctx => {
                                    let value;
                                    let total;
                                    if (charts.lotpnltax && charts.lotpnltax._contributions) {
                                        value = charts.lotpnltax._contributions[ctx.dataIndex];
                                        total = charts.lotpnltax._totalValue;
                                    } else {
                                        value = Array.isArray(ctx.parsed.y) 
                                            ? ctx.parsed.y[1] - ctx.parsed.y[0]
                                            : ctx.parsed.y;
                                        total = value;
                                    }
                                    
                                    if (displayTypes.lotpnltax === 'percentage') {
                                        if (!total || total === 0) {
                                            return '0.00%';
                                        }
                                        const percentValue = (value / Math.abs(total)) * 100;
                                        const sign = percentValue < 0 ? '-' : '';
                                        return `${sign}${Math.abs(percentValue).toFixed(2)}%`;
                                    }
                                    const sign = value < 0 ? '-' : '';
                                    return `${sign}₹${formatIndianNumber(Math.abs(value), 2)}`;
                                }
                            }
                        }
                    },
                    scales: {
                        y: {
                            display: true,
                            position: 'right',
                            beginAtZero: true,
                            grid: { 
                                color: 'rgba(148, 163, 184, 0.08)',
                                lineWidth: 1,
                                drawBorder: false,
                                drawTicks: false
                            },
                            border: {
                                display: false
                            },
                            ticks: {
                                font: { 
                                    size: 10, 
                                    weight: '500',
                                    family: '-apple-system, BlinkMacSystemFont, "Segoe UI", Roboto' 
                                },
                                color: '#94a3b8',
                                padding: 8,
                                maxTicksLimit: 8,
                                callback: value => {
                                    if (displayTypes.lotpnltax === 'percentage') {
                                        return value.toFixed(1) + '%';
                                    }
                                    if (value === 0) return '₹0';
                                    if (Math.abs(value) >= 100000) return `₹${Math.round(value / 100000)}L`;
                                    if (Math.abs(value) >= 1000) return `₹${Math.round(value / 1000)}K`;
                                    return `₹${Math.round(value)}`;
                                }
                            }
                        },
                        x: {
                            display: true,
                            grid: { 
                                display: false,
                                drawBorder: false
                            },
                            border: {
                                display: false
                            },
                            ticks: {
                                font: { 
                                    size: 10, 
                                    weight: '500',
                                    family: '-apple-system, BlinkMacSystemFont, "Segoe UI", Roboto'
                                },
                                color: '#94a3b8',
                                padding: 6
                            }
                        }
                    },
                    interaction: { 
                        intersect: false, 
                        mode: 'index' 
                    }
                },
                plugins: [{
                    id: 'lotpnltaxLabels',
                    afterDatasetsDraw(chart) {
                        if (!showValues.lotpnltax) {
                            return;
                        }
                        
                        const { ctx, data, scales } = chart;
                        const meta = chart.getDatasetMeta(0);
                        const yScale = scales.y;
                        
                        const labels = chart._preCalculatedLabels || [];
                        
                        meta.data.forEach((bar, index) => {
                            if (!labels[index]) return;
                            
                            const { label, value } = labels[index];
                            
                            ctx.save();
                            ctx.font = '600 11px -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto';
                            ctx.fillStyle = value >= 0 ? '#10b981' : '#c2410c';
                            ctx.textAlign = 'center';
                            
                            const x = bar.x;
                            let y;
                            
                            const barData = data.datasets[0].data[index];
                            
                            if (Array.isArray(barData)) {
                                const topValue = Math.max(barData[0], barData[1]);
                                const bottomValue = Math.min(barData[0], barData[1]);
                                
                                if (value >= 0) {
                                    ctx.textBaseline = 'bottom';
                                    y = yScale.getPixelForValue(topValue) - 5;
                                } else {
                                    ctx.textBaseline = 'top';
                                    y = yScale.getPixelForValue(bottomValue) + 5;
                                }
                            } else {
                                if (value >= 0) {
                                    ctx.textBaseline = 'bottom';
                                    y = bar.y - 5;
                                } else {
                                    ctx.textBaseline = 'top';
                                    y = bar.y + 5;
                                }
                            }
                            
                            ctx.fillText(label, x, y);
                            ctx.restore();
                        });
                    }
                }]
            });
        }

        function createGradient(canvas, color) {
            const ctx = canvas.getContext('2d');
            const gradient = ctx.createLinearGradient(0, 0, 0, 400);
            
            if (color === '#059669' || color === '#10b981') {
                gradient.addColorStop(0, 'rgba(5, 150, 105, 0.15)');
                gradient.addColorStop(1, 'rgba(5, 150, 105, 0)');
            } else if (color === '#dc2626') {
                gradient.addColorStop(0, 'rgba(220, 38, 38, 0.15)');
                gradient.addColorStop(1, 'rgba(220, 38, 38, 0)');
            }
            
            return gradient;
        }

        // Update functions
        function updateAllCharts() {
            if (allTrades.length === 0) {
                return;
            }
            
            // Auto-select best period for PNL bar chart and Strategy Comparison
            autoSelectPnlBarPeriod();
            autoSelectComparePeriod();
            
            updateChart('pnl');
            updateChart('drawdown');
            updateChart('pnlbar');
            updateChart('compare');
            updateChart('amibroker');
            updateChart('lotpnltax');
        }
        
        function autoSelectPnlBarPeriod() {
            // Try month first
            const monthData = aggregateByPeriod(allTrades, 'month');
            if (monthData.length >= 4) {
                activePeriods.pnlbar = 'month';
                updatePeriodButtons('pnlbar', 'month');
                return;
            }
            
            // Try week if month has < 4 candles
            const weekData = aggregateByPeriod(allTrades, 'week');
            if (weekData.length >= 4) {
                activePeriods.pnlbar = 'week';
                updatePeriodButtons('pnlbar', 'week');
                return;
            }
            
            // Default to day if week also has < 4 candles
            activePeriods.pnlbar = 'day';
            updatePeriodButtons('pnlbar', 'day');
        }
        
        function autoSelectComparePeriod() {
            // Try month first
            const monthData = aggregateByPeriod(allTrades, 'month');
            if (monthData.length >= 4) {
                activePeriods.compare = 'month';
                updatePeriodButtons('compare', 'month');
                return;
            }
            
            // Try week if month has < 4 candles
            const weekData = aggregateByPeriod(allTrades, 'week');
            if (weekData.length >= 4) {
                activePeriods.compare = 'week';
                updatePeriodButtons('compare', 'week');
                return;
            }
            
            // Default to day if week also has < 4 candles
            activePeriods.compare = 'day';
            updatePeriodButtons('compare', 'day');
        }
        
        function updatePeriodButtons(chartType, period) {
            // Update button states
            const buttons = document.querySelectorAll(`[data-chart="${chartType}"][data-period]`);
            buttons.forEach(btn => {
                if (btn.dataset.period === period) {
                    btn.classList.add('active');
                } else {
                    btn.classList.remove('active');
                }
            });
        }

        function updateChart(chartType) {
            if (!charts[chartType]) {
                return;
            }
            
            if (allTrades.length === 0) {
                charts[chartType].data.labels = [];
                charts[chartType].data.datasets.forEach(dataset => {
                    dataset.data = [];
                });
                charts[chartType].update('none');
                return;
            }
            
            // Use filtered trades based on date range selection
            const activeTrades = getActiveTrades();
            
            const period = activePeriods[chartType];
            const aggregatedData = aggregateByPeriod(activeTrades, period);
            
            const labels = aggregatedData.map(d => formatLabel(d.date, period));
            
            if (chartType === 'pnl') {
                const displayType = displayTypes.pnl || 'value';
                let data;
                
                if (displayType === 'percentage') {
                    // Calculate NET PNL% = (cumPnl / startingCapital) * 100
                    // Use starting capital for all periods (Day/Week/Month)
                    
                    let startingCapital = 0;
                    if (allTrades.length > 0) {
                        const brokerDates = {};
                        
                        allTrades.forEach(trade => {
                            if (trade.strategyDetails) {
                                Object.keys(trade.strategyDetails).forEach(strategyName => {
                                    const cleanName = strategyName.replace(/\s+/g, '');
                                    const brokerMatch = cleanName.match(/^(.+?)PRO/);
                                    
                                    if (brokerMatch) {
                                        const brokerCode = brokerMatch[1];
                                        const margin = trade.strategyDetails[strategyName]?.margin || 0;
                                        
                                        if (margin > 0) {
                                            if (!brokerDates[brokerCode]) {
                                                brokerDates[brokerCode] = [];
                                            }
                                            if (!brokerDates[brokerCode].includes(trade.date)) {
                                                brokerDates[brokerCode].push(trade.date);
                                            }
                                        }
                                    }
                                });
                            }
                        });
                        
                        Object.keys(brokerDates).forEach(brokerCode => {
                            const dates = brokerDates[brokerCode].sort((a, b) => compareDates(a, b));
                            const brokerFirstDate = dates[0];
                            
                            const brokerMargins = [];
                            allTrades.filter(t => t.date === brokerFirstDate).forEach(trade => {
                                if (trade.strategyDetails) {
                                    Object.keys(trade.strategyDetails).forEach(strategyName => {
                                        const cleanName = strategyName.replace(/\s+/g, '');
                                        const brokerMatch = cleanName.match(/^(.+?)PRO/);
                                        
                                        if (brokerMatch && brokerMatch[1] === brokerCode) {
                                            const margin = trade.strategyDetails[strategyName]?.margin || 0;
                                            if (margin > 0) {
                                                brokerMargins.push(margin);
                                            }
                                        }
                                    });
                                }
                            });
                            
                            if (brokerMargins.length > 0) {
                                startingCapital += Math.max(...brokerMargins);
                            }
                        });
                    }
                    
                    data = aggregatedData.map(d => {
                        if (startingCapital === 0) return 0;
                        return ((d.cumPnl / startingCapital) * 100);
                    });
                } else {
                    data = aggregatedData.map(d => d.cumPnl);
                }
                
                charts.pnl.data.labels = labels;
                charts.pnl.data.datasets[0].data = data;
                
                // Update color based on final value
                const isProfit = data[data.length - 1] >= 0;
                charts.pnl.data.datasets[0].borderColor = isProfit ? '#059669' : '#dc2626';
                charts.pnl.data.datasets[0].backgroundColor = createGradient(elements.pnlChart, isProfit ? '#059669' : '#dc2626');
                charts.pnl.data.datasets[0].pointHoverBackgroundColor = isProfit ? '#059669' : '#dc2626';
                
                // Update y-axis to show % or value
                charts.pnl.options.scales.y.ticks.callback = function(value) {
                    if (displayTypes.pnl === 'percentage') {
                        return value.toFixed(2) + '%';
                    }
                    return '₹' + formatIndianNumber(value);
                };
                
                // Update tooltip callback
                charts.pnl.options.plugins.tooltip.callbacks.label = function(ctx) {
                    if (displayTypes.pnl === 'percentage') {
                        return ctx.parsed.y.toFixed(2) + '%';
                    }
                    return `₹${formatIndianNumber(ctx.parsed.y, 2)}`;
                };
                
                charts.pnl.update('none');
            } else if (chartType === 'drawdown') {
                const displayType = displayTypes.drawdown || 'value';
                let data;
                
                if (displayType === 'percentage') {
                    // Calculate Drawdown% = (drawdown / peakMargin) * 100
                    // peakMargin = startingCapital + peak cumPnl at that point
                    
                    // Get starting capital
                    let startingCapital = 0;
                    if (allTrades.length > 0) {
                        const brokerDates = {};
                        
                        allTrades.forEach(trade => {
                            if (trade.strategyDetails) {
                                Object.keys(trade.strategyDetails).forEach(strategyName => {
                                    const cleanName = strategyName.replace(/\s+/g, '');
                                    const brokerMatch = cleanName.match(/^(.+?)PRO/);
                                    
                                    if (brokerMatch) {
                                        const brokerCode = brokerMatch[1];
                                        const margin = trade.strategyDetails[strategyName]?.margin || 0;
                                        
                                        if (margin > 0) {
                                            if (!brokerDates[brokerCode]) {
                                                brokerDates[brokerCode] = [];
                                            }
                                            if (!brokerDates[brokerCode].includes(trade.date)) {
                                                brokerDates[brokerCode].push(trade.date);
                                            }
                                        }
                                    }
                                });
                            }
                        });
                        
                        Object.keys(brokerDates).forEach(brokerCode => {
                            const dates = brokerDates[brokerCode].sort((a, b) => compareDates(a, b));
                            const brokerFirstDate = dates[0];
                            
                            const brokerMargins = [];
                            allTrades.filter(t => t.date === brokerFirstDate).forEach(trade => {
                                if (trade.strategyDetails) {
                                    Object.keys(trade.strategyDetails).forEach(strategyName => {
                                        const cleanName = strategyName.replace(/\s+/g, '');
                                        const brokerMatch = cleanName.match(/^(.+?)PRO/);
                                        
                                        if (brokerMatch && brokerMatch[1] === brokerCode) {
                                            const margin = trade.strategyDetails[strategyName]?.margin || 0;
                                            if (margin > 0) {
                                                brokerMargins.push(margin);
                                            }
                                        }
                                    });
                                }
                            });
                            
                            if (brokerMargins.length > 0) {
                                startingCapital += Math.max(...brokerMargins);
                            }
                        });
                    }
                    
                    data = aggregatedData.map(d => {
                        // peakMargin = startingCapital + peak cumPnl
                        const peakMargin = startingCapital + d.peak;
                        if (peakMargin === 0) return 0;
                        return ((d.drawdown / peakMargin) * 100);
                    });
                } else {
                    data = aggregatedData.map(d => d.drawdown);
                }
                
                charts.drawdown.data.labels = labels;
                charts.drawdown.data.datasets[0].data = data;
                
                // Update y-axis to show % or value
                charts.drawdown.options.scales.y.ticks.callback = function(value) {
                    if (displayTypes.drawdown === 'percentage') {
                        return value.toFixed(2) + '%';
                    }
                    return '₹' + formatIndianNumber(value);
                };
                
                // Update tooltip callback
                charts.drawdown.options.plugins.tooltip.callbacks.label = function(ctx) {
                    if (displayTypes.drawdown === 'percentage') {
                        return ctx.parsed.y.toFixed(2) + '%';
                    }
                    return `₹${formatIndianNumber(ctx.parsed.y, 2)}`;
                };
                
                charts.drawdown.update('none');
            } else if (chartType === 'pnlbar') {
                const displayType = displayTypes.pnlbar || 'value';
                let profitData;
                
                if (displayType === 'percentage') {
                    const period = activePeriods[chartType];
                    
                    if (period === 'day') {
                        // Build month boundaries
                        const monthLastDayMargins = new Map();
                        let currentMonth = null;
                        let currentMonthDays = [];
                        let firstMonthStartMargin = 0;
                        
                        aggregatedData.forEach((d, index) => {
                            const dateParts = d.date.split('/');
                            const month = dateParts.length >= 2 ? (dateParts[1] + '/' + dateParts[2]) : d.date;
                            
                            if (month !== currentMonth) {
                                if (currentMonth !== null && currentMonthDays.length > 0) {
                                    const lastDay = currentMonthDays[currentMonthDays.length - 1];
                                    monthLastDayMargins.set(currentMonth, lastDay.cumMargin || 0);
                                }
                                currentMonth = month;
                                currentMonthDays = [];
                                
                                // Store first month's starting margin
                                if (index === 0) {
                                    firstMonthStartMargin = d.cumMargin - (d.cumPnl || 0);
                                }
                            }
                            
                            currentMonthDays.push(d);
                            
                            if (index === aggregatedData.length - 1 && currentMonthDays.length > 0) {
                                const lastDay = currentMonthDays[currentMonthDays.length - 1];
                                monthLastDayMargins.set(currentMonth, lastDay.cumMargin || 0);
                            }
                        });
                        
                        // Calculate percentages - matching Strategy Performance % logic exactly
                        // First day of month: use month's starting margin
                        // Subsequent days: use previous day's cumMargin
                        
                        currentMonth = null; // Reset the existing variable
                        let monthStartMargin = 0;
                        
                        profitData = aggregatedData.map((d, index) => {
                            const dateParts = d.date.split('/');
                            const month = dateParts.length >= 2 ? (dateParts[1] + '/' + dateParts[2]) : d.date;
                            
                            // Check if this is the first day of a new month
                            const isFirstDayOfMonth = (month !== currentMonth);
                            
                            if (isFirstDayOfMonth) {
                                // First day of month: use starting margin
                                currentMonth = month;
                                if (index === 0) {
                                    // Very first day in dataset: starting capital
                                    monthStartMargin = (d.cumMargin || 0) - (d.cumPnl || 0);
                                } else {
                                    // First day of subsequent month: use previous day's cumMargin (which is previous month's ending)
                                    const prevDay = aggregatedData[index - 1];
                                    monthStartMargin = prevDay.cumMargin || 0;
                                }
                                
                                if (monthStartMargin === 0) {
                                    return 0;
                                } else {
                                    return ((d.periodProfit || 0) / monthStartMargin) * 100;
                                }
                            } else {
                                // Subsequent days in month: use previous day's cumMargin
                                const prevDay = aggregatedData[index - 1];
                                const previousDayMargin = prevDay.cumMargin || 0;
                                
                                if (previousDayMargin === 0) {
                                    return 0;
                                } else {
                                    return ((d.periodProfit || 0) / previousDayMargin) * 100;
                                }
                            }
                        });
                    } else if (period === 'week' || period === 'month') {
                        // Calculate starting capital same way as Cumulative P&L
                        let startingCapital = 0;
                        if (allTrades.length > 0) {
                            const brokerDates = {};
                            
                            allTrades.forEach(trade => {
                                if (trade.strategyDetails) {
                                    Object.keys(trade.strategyDetails).forEach(strategyName => {
                                        const cleanName = strategyName.replace(/\s+/g, '');
                                        const brokerMatch = cleanName.match(/^(.+?)PRO/);
                                        
                                        if (brokerMatch) {
                                            const brokerCode = brokerMatch[1];
                                            const margin = trade.strategyDetails[strategyName]?.margin || 0;
                                            
                                            if (margin > 0) {
                                                if (!brokerDates[brokerCode]) {
                                                    brokerDates[brokerCode] = [];
                                                }
                                                if (!brokerDates[brokerCode].includes(trade.date)) {
                                                    brokerDates[brokerCode].push(trade.date);
                                                }
                                            }
                                        }
                                    });
                                }
                            });
                            
                            Object.keys(brokerDates).forEach(brokerCode => {
                                const dates = brokerDates[brokerCode].sort((a, b) => compareDates(a, b));
                                const brokerFirstDate = dates[0];
                                
                                const brokerMargins = [];
                                allTrades.filter(t => t.date === brokerFirstDate).forEach(trade => {
                                    if (trade.strategyDetails) {
                                        Object.keys(trade.strategyDetails).forEach(strategyName => {
                                            const cleanName = strategyName.replace(/\s+/g, '');
                                            const brokerMatch = cleanName.match(/^(.+?)PRO/);
                                            
                                            if (brokerMatch && brokerMatch[1] === brokerCode) {
                                                const margin = trade.strategyDetails[strategyName]?.margin || 0;
                                                if (margin > 0) {
                                                    brokerMargins.push(margin);
                                                }
                                            }
                                        });
                                    }
                                });
                                
                                if (brokerMargins.length > 0) {
                                    startingCapital += Math.max(...brokerMargins);
                                }
                            });
                        }
                        
                        profitData = aggregatedData.map((d, index) => {
                            if (index === 0) {
                                // First period: use starting capital (same as Cumulative P&L)
                                if (startingCapital === 0) {
                                    return 0;
                                } else {
                                    return ((d.periodProfit || 0) / startingCapital) * 100;
                                }
                            } else {
                                // Subsequent periods: use previous period's cumMargin
                                const prevPeriod = aggregatedData[index - 1];
                                const previousMargin = prevPeriod.cumMargin || 0;
                                if (previousMargin === 0) {
                                    return 0;
                                } else {
                                    return ((d.periodProfit || 0) / previousMargin) * 100;
                                }
                            }
                        });
                    }
                } else {
                    profitData = aggregatedData.map(d => d.periodProfit || 0);
                }
                
                // Create color array - green for positive, brown for negative
                const colors = profitData.map(val => val >= 0 ? '#10b981' : '#c2410c');
                
                charts.pnlbar.data.labels = labels;
                charts.pnlbar.data.datasets[0].data = profitData;
                charts.pnlbar.data.datasets[0].backgroundColor = colors;
                
                // Update y-axis to show % or value
                charts.pnlbar.options.scales.y.ticks.callback = function(value) {
                    if (displayTypes.pnlbar === 'percentage') {
                        return value.toFixed(2) + '%';
                    }
                    return '₹' + formatIndianNumber(value);
                };
                
                // Update tooltip callback
                charts.pnlbar.options.plugins.tooltip.callbacks.label = function(ctx) {
                    if (displayTypes.pnlbar === 'percentage') {
                        return ctx.parsed.y.toFixed(2) + '%';
                    }
                    return `₹${formatIndianNumber(ctx.parsed.y, 2)}`;
                };
                
                // Update with immediate rendering
                charts.pnlbar.update('none');
                charts.pnlbar.render();
            } else if (chartType === 'compare') {
                // Waterfall Chart Logic
                const activeTrades = getActiveTrades(); // Use filtered trades based on date range
                const isMonthly = !window.waterfallView || window.waterfallView === 'monthly';
                
                // Check if we have cached data and only display type changed
                const cacheKey = `${isMonthly ? 'monthly' : 'overall'}_${currentMonthIndex}_${selectedDateRange}_${Array.from(hiddenStrategies.compare).join(',')}`;
                const useCache = charts.compare._cacheKey === cacheKey && 
                                charts.compare._cachedStrategies && 
                                charts.compare._cachedTotalValue !== undefined;
                
                let sortedStrategies, totalValue;
                
                if (useCache) {
                    // Use cached calculations
                    sortedStrategies = charts.compare._cachedStrategies;
                    totalValue = charts.compare._cachedTotalValue;
                } else {
                    // Perform full calculation
                    // Get all unique months from trades (only if needed)
                    if (!isMonthly || availableMonths.length === 0) {
                        const monthsSet = new Set();
                        activeTrades.forEach(trade => {
                            if (trade.date) {
                                const parts = trade.date.split('/');
                                if (parts.length >= 3) {
                                    const monthNames = ['', 'JAN', 'FEB', 'MAR', 'APR', 'MAY', 'JUN', 
                                                      'JUL', 'AUG', 'SEP', 'OCT', 'NOV', 'DEC'];
                                    const monthNum = parseInt(parts[1]);
                                    const year = parts[2].slice(-2);
                                    const monthName = monthNames[monthNum];
                                    const displayMonth = `${monthName}-${year}`;
                                    monthsSet.add(displayMonth);
                                }
                            }
                        });
                        
                        availableMonths = Array.from(monthsSet).sort((a, b) => {
                            const [aMonth, aYear] = a.split('-');
                            const [bMonth, bYear] = b.split('-');
                            const monthNames = ['JAN', 'FEB', 'MAR', 'APR', 'MAY', 'JUN', 
                                              'JUL', 'AUG', 'SEP', 'OCT', 'NOV', 'DEC'];
                            const aMonthIdx = monthNames.indexOf(aMonth);
                            const bMonthIdx = monthNames.indexOf(bMonth);
                            return parseInt(aYear) === parseInt(bYear) ? aMonthIdx - bMonthIdx : parseInt(aYear) - parseInt(bYear);
                        });
                        
                        if (availableMonths.length > 0 && currentMonthIndex >= availableMonths.length) {
                            currentMonthIndex = availableMonths.length - 1;
                        }
                    }
                    
                    // Only update month display if not using cache
                    if (!useCache) {
                        updateMonthDisplay();
                    }
                    
                    let strategyContributions = {};
                    
                    if (isMonthly && availableMonths.length > 0) {
                    // Monthly view - show contributions for selected month
                    const selectedMonth = availableMonths[currentMonthIndex];
                    const [monthName, year] = selectedMonth.split('-');
                    const monthNames = ['JAN', 'FEB', 'MAR', 'APR', 'MAY', 'JUN', 
                                      'JUL', 'AUG', 'SEP', 'OCT', 'NOV', 'DEC'];
                    const monthNum = monthNames.indexOf(monthName) + 1;
                    const fullYear = '20' + year; // Convert 25 to 2025
                    
                    // Get trades for this month
                    const monthTrades = activeTrades.filter(trade => {
                        if (!trade.date) return false;
                        const parts = trade.date.split('/');
                        if (parts.length < 3) return false;
                        return parseInt(parts[1]) === monthNum && parts[2] === fullYear;
                    });
                    
                    // Calculate strategy contributions for the month
                    monthTrades.forEach(trade => {
                        if (trade.strategyPnlTax) {
                            Object.entries(trade.strategyPnlTax).forEach(([stratName, pnl]) => {
                                if (!stratName.startsWith('A.PRO')) {
                                    if (!strategyContributions[stratName]) {
                                        strategyContributions[stratName] = 0;
                                    }
                                    strategyContributions[stratName] += pnl;
                                }
                            });
                        }
                    });
                } else {
                    // Overall view - show contributions across all time
                    activeTrades.forEach(trade => {
                        if (trade.strategyPnlTax) {
                            Object.entries(trade.strategyPnlTax).forEach(([stratName, pnl]) => {
                                if (!stratName.startsWith('A.PRO')) {
                                    if (!strategyContributions[stratName]) {
                                        strategyContributions[stratName] = 0;
                                    }
                                    strategyContributions[stratName] += pnl;
                                }
                            });
                        }
                    });
                }
                
                // Sort strategies by broker code and PRO number
                // Filter out strategies with zero contribution
                sortedStrategies = Object.entries(strategyContributions)
                    .filter(([stratName, contribution]) => {
                        return contribution !== 0; // Keep all non-zero strategies
                    })
                    .sort((a, b) => {
                        const extractParts = (name) => {
                            const match = name.match(/([A-Z0-9]+)\s*PRO\s*(\d+)/i);
                            if (match) {
                                return {
                                    broker: match[1],
                                    pro: parseInt(match[2])
                                };
                            }
                            return { broker: name, pro: 0 };
                        };
                        
                        const partsA = extractParts(a[0]);
                        const partsB = extractParts(b[0]);
                        
                        if (partsA.broker !== partsB.broker) {
                            return partsA.broker.localeCompare(partsB.broker);
                        }
                        
                        return partsA.pro - partsB.pro;
                    })
                    .slice(0, 10);
                
                // Calculate total only from visible (non-hidden) strategies
                totalValue = sortedStrategies.reduce((sum, [stratName, contrib]) => {
                    if (!hiddenStrategies.compare.has(formatStrategyName(stratName))) {
                        return sum + contrib;
                    }
                    return sum;
                }, 0);
                
                // Cache the calculated values
                charts.compare._cacheKey = cacheKey;
                charts.compare._cachedStrategies = sortedStrategies;
                charts.compare._cachedTotalValue = totalValue;
            }
                
                // Now build display data (this is fast)
                let labels = [];
                let data = [];
                let colors = [];
                
                // Modern Vibrant color palette (green reserved for Total)
                const strategyColors = {
                    'PRO 4': '#3b82f6',
                    'PRO 5': '#ec4899',
                    'PRO 8': '#8b5cf6',
                    'PRO 6': '#06b6d4',
                    'PRO 7': '#f59e0b'
                };
                const defaultColors = ['#3b82f6', '#ec4899', '#8b5cf6', '#06b6d4', '#f59e0b'];
                
                // Helper function to extract PRO number for color matching
                const getColorForStrategy = (stratName) => {
                    const match = stratName.match(/PRO\s*(\d+)/i);
                    if (match) {
                        const proKey = `PRO ${match[1]}`;
                        return strategyColors[proKey];
                    }
                    return null;
                };
                
                // Use cached or calculated totalValue
                const isPercentageMode = displayTypes.compare === 'percentage';
                
                // Build waterfall data with floating bars [start, end]
                // Start from 0, no "Start" bar needed
                
                let cumulative = 0;
                const contributions = []; // Store actual contribution values for tooltips
                
                // Filter to only visible strategies for the chart
                const visibleStrategies = sortedStrategies.filter(([stratName]) => 
                    !hiddenStrategies.compare.has(formatStrategyName(stratName))
                );
                
                visibleStrategies.forEach(([stratName, contribution], index) => {
                    labels.push(formatStrategyName(stratName));
                    contributions.push(contribution);
                    
                    let displayValue = contribution;
                    if (isPercentageMode && totalValue !== 0) {
                        displayValue = (contribution / Math.abs(totalValue)) * 100;
                    }
                    
                    const start = cumulative;
                    const end = cumulative + displayValue;
                    
                    // For floating bars, always use [min, max] for proper display
                    data.push([Math.min(start, end), Math.max(start, end)]);
                    
                    cumulative += displayValue;
                    
                    // Color based on positive/negative contribution
                    if (contribution < 0) {
                        // Use red/brown only for negative values
                        colors.push('#c2410c');
                    } else {
                        // Use predefined or default colors for positive values
                        const baseColor = getColorForStrategy(stratName) || defaultColors[index % defaultColors.length];
                        colors.push(baseColor);
                    }
                });
                
                // Add Total
                labels.push('Total');
                contributions.push(totalValue); // Store actual total value
                
                // Total bar display value
                const totalDisplayValue = isPercentageMode ? (totalValue >= 0 ? 100 : -100) : totalValue;
                
                // Total bar from 0 to cumulative (can be negative)
                if (totalDisplayValue >= 0) {
                    data.push([0, totalDisplayValue]);
                } else {
                    data.push([totalDisplayValue, 0]);
                }
                // Use red/brown for negative total, green for positive
                colors.push(totalValue < 0 ? '#c2410c' : '#10b981');
                
                // Update chart
                charts.compare.data.labels = labels;
                charts.compare.data.datasets[0].data = data;
                charts.compare.data.datasets[0].backgroundColor = colors;
                
                // Store all strategies (including hidden) for legend generation
                charts.compare._allStrategies = sortedStrategies.map(([name]) => formatStrategyName(name));
                charts.compare._allColors = sortedStrategies.map(([name, contrib], index) => {
                    const strategyColors = {
                        'PRO 4': '#3b82f6',
                        'PRO 5': '#ec4899',
                        'PRO 8': '#8b5cf6',
                        'PRO 6': '#06b6d4',
                        'PRO 7': '#f59e0b'
                    };
                    const defaultColors = ['#3b82f6', '#ec4899', '#8b5cf6', '#06b6d4', '#f59e0b'];
                    const getColorForStrategy = (stratName) => {
                        const match = stratName.match(/PRO\s*(\d+)/i);
                        if (match) {
                            const proKey = `PRO ${match[1]}`;
                            return strategyColors[proKey];
                        }
                        return null;
                    };
                    if (contrib < 0) {
                        return '#c2410c';
                    } else {
                        return getColorForStrategy(name) || defaultColors[index % defaultColors.length];
                    }
                });
                
                // Store contributions and total for tooltip access
                charts.compare._contributions = contributions;
                charts.compare._totalValue = totalValue;
                
                // Pre-calculate labels for fast rendering
                charts.compare._preCalculatedLabels = contributions.map(value => {
                    let label;
                    if (displayTypes.compare === 'percentage') {
                        const percentValue = (value / Math.abs(totalValue || 1)) * 100;
                        label = percentValue.toFixed(1) + '%';
                    } else {
                        label = formatIndianShort(value);
                    }
                    return { label, value };
                });
                
                // Update tooltip callbacks
                charts.compare.options.plugins.tooltip.callbacks.label = function(ctx) {
                    // Use stored contribution value instead of calculating from bar
                    const value = charts.compare._contributions[ctx.dataIndex];
                    const total = charts.compare._totalValue;
                    
                    if (displayTypes.compare === 'percentage') {
                        // Calculate percentage of total
                        if (total === 0) {
                            return '0.00%';
                        }
                        const percentValue = (value / Math.abs(total)) * 100;
                        const sign = percentValue < 0 ? '-' : '';
                        return `${sign}${Math.abs(percentValue).toFixed(2)}%`;
                    }
                    const sign = value < 0 ? '-' : '';
                    return `${sign}₹${formatIndianNumber(Math.abs(value), 2)}`;
                };
                
                // Force scale reset for proper percentage/value switching
                charts.compare.options.scales.y.min = undefined;
                charts.compare.options.scales.y.max = undefined;
                
                // Force legend to regenerate
                charts.compare.options.plugins.legend.labels.generateLabels = charts.compare.options.plugins.legend.labels.generateLabels;
                
                // Update with scale recalculation
                charts.compare.update('none');
                
                charts.compare.render();
            } else if (chartType === 'amibroker') {
                // Amibroker Waterfall Chart Logic (A.PRO strategies)
                const activeTrades = getActiveTrades(); // Use filtered trades based on date range
                const isMonthly = !window.amibrokerView || window.amibrokerView === 'monthly';
                
                const cacheKey = `${isMonthly ? 'monthly' : 'overall'}_${currentMonthIndex}_${selectedDateRange}_${Array.from(hiddenStrategies.amibroker).join(',')}`;
                const useCache = charts.amibroker._cacheKey === cacheKey && 
                                charts.amibroker._cachedStrategies && 
                                charts.amibroker._cachedTotalValue !== undefined;
                
                let sortedStrategies, totalValue;
                
                if (useCache) {
                    sortedStrategies = charts.amibroker._cachedStrategies;
                    totalValue = charts.amibroker._cachedTotalValue;
                } else {
                    const strategyContributions = {};
                    
                    if (isMonthly) {
                        if (availableMonths.length === 0) {
                            const monthsSet = new Set();
                            activeTrades.forEach(trade => {
                                if (trade.date) {
                                    const parts = trade.date.split('/');
                                    if (parts.length >= 3) {
                                        const monthNames = ['', 'JAN', 'FEB', 'MAR', 'APR', 'MAY', 'JUN', 
                                                          'JUL', 'AUG', 'SEP', 'OCT', 'NOV', 'DEC'];
                                        const monthNum = parseInt(parts[1]);
                                        const year = parts[2].slice(-2);
                                        const monthName = monthNames[monthNum];
                                        const displayMonth = `${monthName}-${year}`;
                                        monthsSet.add(displayMonth);
                                    }
                                }
                            });
                            
                            availableMonths = Array.from(monthsSet).sort((a, b) => {
                                const [aMonth, aYear] = a.split('-');
                                const [bMonth, bYear] = b.split('-');
                                const monthNames = ['JAN', 'FEB', 'MAR', 'APR', 'MAY', 'JUN', 
                                                  'JUL', 'AUG', 'SEP', 'OCT', 'NOV', 'DEC'];
                                const aMonthIdx = monthNames.indexOf(aMonth);
                                const bMonthIdx = monthNames.indexOf(bMonth);
                                return parseInt(aYear) === parseInt(bYear) ? aMonthIdx - bMonthIdx : parseInt(aYear) - parseInt(bYear);
                            });
                        }
                        
                        const monthString = availableMonths[currentMonthIndex];
                        document.getElementById('currentMonthAmibroker').textContent = monthString;
                        
                        const [monthName, year] = monthString.split('-');
                        const monthNames = ['JAN', 'FEB', 'MAR', 'APR', 'MAY', 'JUN', 'JUL', 'AUG', 'SEP', 'OCT', 'NOV', 'DEC'];
                        const monthNum = monthNames.indexOf(monthName) + 1;
                        const fullYear = '20' + year;
                        
                        const monthTrades = activeTrades.filter(trade => {
                            if (!trade.date) return false;
                            const parts = trade.date.split('/');
                            if (parts.length < 3) return false;
                            return parseInt(parts[1]) === monthNum && parts[2] === fullYear;
                        });
                        
                        monthTrades.forEach(trade => {
                            if (trade.strategyPnlTax) {
                                Object.entries(trade.strategyPnlTax).forEach(([stratName, pnl]) => {
                                    if (stratName.startsWith('A.PRO')) {
                                        if (!strategyContributions[stratName]) {
                                            strategyContributions[stratName] = 0;
                                        }
                                        strategyContributions[stratName] += pnl;
                                    }
                                });
                            }
                        });
                    } else {
                        activeTrades.forEach(trade => {
                            if (trade.strategyPnlTax) {
                                Object.entries(trade.strategyPnlTax).forEach(([stratName, pnl]) => {
                                    if (stratName.startsWith('A.PRO')) {
                                        if (!strategyContributions[stratName]) {
                                            strategyContributions[stratName] = 0;
                                        }
                                        strategyContributions[stratName] += pnl;
                                    }
                                });
                            }
                        });
                    }
                    
                    sortedStrategies = Object.entries(strategyContributions)
                        .filter(([stratName, contribution]) => {
                            return contribution !== 0; // Keep all non-zero strategies
                        })
                        .sort((a, b) => {
                            const extractParts = (name) => {
                                const match = name.match(/([A-Z0-9.]+)\s*PRO\s*(\d+)/i);
                                if (match) {
                                    return {
                                        broker: match[1],
                                        pro: parseInt(match[2])
                                    };
                                }
                                return { broker: name, pro: 0 };
                            };
                            
                            const partsA = extractParts(a[0]);
                            const partsB = extractParts(b[0]);
                            
                            if (partsA.broker !== partsB.broker) {
                                return partsA.broker.localeCompare(partsB.broker);
                            }
                            
                            return partsA.pro - partsB.pro;
                        })
                        .slice(0, 10);
                    
                    // Calculate total only from visible (non-hidden) strategies
                    totalValue = sortedStrategies.reduce((sum, [stratName, contrib]) => {
                        if (!hiddenStrategies.amibroker.has(formatStrategyName(stratName))) {
                            return sum + contrib;
                        }
                        return sum;
                    }, 0);
                    
                    charts.amibroker._cacheKey = cacheKey;
                    charts.amibroker._cachedStrategies = sortedStrategies;
                    charts.amibroker._cachedTotalValue = totalValue;
                }
                    
                let labels = [];
                let data = [];
                let colors = [];
                
                // Warm earthy color palette for Amibroker
                const strategyColors = {
                    'PRO 4': '#f97316',
                    'PRO 5': '#eab308',
                    'PRO 8': '#84cc16',
                    'PRO 6': '#14b8a6',
                    'PRO 7': '#0ea5e9'
                };
                const defaultColors = ['#f97316', '#eab308', '#84cc16', '#14b8a6', '#0ea5e9'];
                
                const getColorForStrategy = (stratName) => {
                    const match = stratName.match(/PRO\s*(\d+)/i);
                    if (match) {
                        const proKey = `PRO ${match[1]}`;
                        return strategyColors[proKey];
                    }
                    return null;
                };
                
                const isPercentageMode = displayTypes.amibroker === 'percentage';
                
                let cumulative = 0;
                const contributions = [];
                
                // Filter to only visible strategies for the chart
                const visibleStrategies = sortedStrategies.filter(([stratName]) => 
                    !hiddenStrategies.amibroker.has(formatStrategyName(stratName))
                );
                
                visibleStrategies.forEach(([stratName, contribution], index) => {
                    labels.push(formatStrategyName(stratName));
                    contributions.push(contribution);
                    
                    let displayValue = contribution;
                    if (isPercentageMode && totalValue !== 0) {
                        displayValue = (contribution / Math.abs(totalValue)) * 100;
                    }
                    
                    const start = cumulative;
                    const end = cumulative + displayValue;
                    
                    data.push([Math.min(start, end), Math.max(start, end)]);
                    
                    cumulative += displayValue;
                    
                    if (contribution < 0) {
                        colors.push('#c2410c');
                    } else {
                        const baseColor = getColorForStrategy(stratName) || defaultColors[index % defaultColors.length];
                        colors.push(baseColor);
                    }
                });
                
                labels.push('Total');
                contributions.push(totalValue);
                
                const totalDisplayValue = isPercentageMode ? (totalValue >= 0 ? 100 : -100) : totalValue;
                
                if (totalDisplayValue >= 0) {
                    data.push([0, totalDisplayValue]);
                } else {
                    data.push([totalDisplayValue, 0]);
                }
                colors.push(totalValue < 0 ? '#c2410c' : '#10b981');
                
                charts.amibroker.data.labels = labels;
                charts.amibroker.data.datasets[0].data = data;
                charts.amibroker.data.datasets[0].backgroundColor = colors;
                
                // Store all strategies (including hidden) for legend generation
                charts.amibroker._allStrategies = sortedStrategies.map(([name]) => formatStrategyName(name));
                charts.amibroker._allColors = sortedStrategies.map(([name, contrib], index) => {
                    const strategyColors = {
                        'PRO 4': '#f97316',
                        'PRO 5': '#eab308',
                        'PRO 8': '#84cc16',
                        'PRO 6': '#14b8a6',
                        'PRO 7': '#0ea5e9'
                    };
                    const defaultColors = ['#f97316', '#eab308', '#84cc16', '#14b8a6', '#0ea5e9'];
                    const getColorForStrategy = (stratName) => {
                        const match = stratName.match(/PRO\s*(\d+)/i);
                        if (match) {
                            const proKey = `PRO ${match[1]}`;
                            return strategyColors[proKey];
                        }
                        return null;
                    };
                    if (contrib < 0) {
                        return '#c2410c';
                    } else {
                        return getColorForStrategy(name) || defaultColors[index % defaultColors.length];
                    }
                });
                
                charts.amibroker._contributions = contributions;
                charts.amibroker._totalValue = totalValue;
                
                charts.amibroker._preCalculatedLabels = contributions.map(value => {
                    let label;
                    if (displayTypes.amibroker === 'percentage') {
                        const percentValue = (value / Math.abs(totalValue || 1)) * 100;
                        label = percentValue.toFixed(1) + '%';
                    } else {
                        label = formatIndianShort(value);
                    }
                    return { label, value };
                });
                
                charts.amibroker.options.plugins.tooltip.callbacks.label = function(ctx) {
                    const value = charts.amibroker._contributions[ctx.dataIndex];
                    const total = charts.amibroker._totalValue;
                    
                    if (displayTypes.amibroker === 'percentage') {
                        if (total === 0) {
                            return '0.00%';
                        }
                        const percentValue = (value / Math.abs(total)) * 100;
                        const sign = percentValue < 0 ? '-' : '';
                        return `${sign}${Math.abs(percentValue).toFixed(2)}%`;
                    }
                    const sign = value < 0 ? '-' : '';
                    return `${sign}₹${formatIndianNumber(Math.abs(value), 2)}`;
                };
                
                charts.amibroker.options.scales.y.min = undefined;
                charts.amibroker.options.scales.y.max = undefined;
                
                // Force legend to regenerate
                charts.amibroker.options.plugins.legend.labels.generateLabels = charts.amibroker.options.plugins.legend.labels.generateLabels;
                
                charts.amibroker.update('none');
                charts.amibroker.render();
            } else if (chartType === 'lotpnltax') {
                // LOT PNLTAX Waterfall Chart Logic
                const activeTrades = getActiveTrades(); // Use filtered trades based on date range
                const isMonthly = !window.lotpnltaxView || window.lotpnltaxView === 'monthly';
                
                const cacheKey = `${isMonthly ? 'monthly' : 'overall'}_${currentMonthIndex}_${selectedDateRange}_${Array.from(hiddenStrategies.lotpnltax).join(',')}`;
                const useCache = charts.lotpnltax._cacheKey === cacheKey && 
                                charts.lotpnltax._cachedStrategies && 
                                charts.lotpnltax._cachedTotalValue !== undefined;
                
                let sortedStrategies, totalValue;
                
                if (useCache) {
                    sortedStrategies = charts.lotpnltax._cachedStrategies;
                    totalValue = charts.lotpnltax._cachedTotalValue;
                } else {
                    const strategyData = {}; // Store net, lotSum, lotCount for each strategy
                    
                    if (isMonthly) {
                        if (availableMonths.length === 0) {
                            const monthsSet = new Set();
                            activeTrades.forEach(trade => {
                                if (trade.date) {
                                    const parts = trade.date.split('/');
                                    if (parts.length >= 3) {
                                        const monthNames = ['', 'JAN', 'FEB', 'MAR', 'APR', 'MAY', 'JUN', 
                                                          'JUL', 'AUG', 'SEP', 'OCT', 'NOV', 'DEC'];
                                        const monthNum = parseInt(parts[1]);
                                        const year = parts[2].slice(-2);
                                        const monthName = monthNames[monthNum];
                                        const displayMonth = `${monthName}-${year}`;
                                        monthsSet.add(displayMonth);
                                    }
                                }
                            });
                            
                            availableMonths = Array.from(monthsSet).sort((a, b) => {
                                const [aMonth, aYear] = a.split('-');
                                const [bMonth, bYear] = b.split('-');
                                const monthNames = ['JAN', 'FEB', 'MAR', 'APR', 'MAY', 'JUN', 
                                                  'JUL', 'AUG', 'SEP', 'OCT', 'NOV', 'DEC'];
                                const aMonthIdx = monthNames.indexOf(aMonth);
                                const bMonthIdx = monthNames.indexOf(bMonth);
                                return parseInt(aYear) === parseInt(bYear) ? aMonthIdx - bMonthIdx : parseInt(aYear) - parseInt(bYear);
                            });
                        }
                        
                        const monthString = availableMonths[currentMonthIndex];
                        document.getElementById('currentMonthLotpnltax').textContent = monthString;
                        
                        const [monthName, year] = monthString.split('-');
                        const monthNames = ['JAN', 'FEB', 'MAR', 'APR', 'MAY', 'JUN', 'JUL', 'AUG', 'SEP', 'OCT', 'NOV', 'DEC'];
                        const monthNum = monthNames.indexOf(monthName) + 1;
                        const fullYear = '20' + year;
                        
                        const monthTrades = activeTrades.filter(trade => {
                            if (!trade.date) return false;
                            const parts = trade.date.split('/');
                            if (parts.length < 3) return false;
                            return parseInt(parts[1]) === monthNum && parts[2] === fullYear;
                        });
                        
                        // Calculate LOT PNL TAX = (PNL TAX / Average Lot) for each strategy
                        monthTrades.forEach(trade => {
                            if (trade.strategyPnlTax && trade.strategyDetails) {
                                Object.entries(trade.strategyPnlTax).forEach(([stratName, pnlTax]) => {
                                    if (!stratName.startsWith('A.PRO')) { // Only non-Amibroker strategies
                                        if (!strategyData[stratName]) {
                                            strategyData[stratName] = { net: 0, lotSum: 0, lotCount: 0 };
                                        }
                                        strategyData[stratName].net += pnlTax;
                                        
                                        // Get lot data from strategyDetails
                                        const stratDetail = trade.strategyDetails[stratName];
                                        if (stratDetail && stratDetail.lot) {
                                            strategyData[stratName].lotSum += stratDetail.lot;
                                            strategyData[stratName].lotCount += 1;
                                        }
                                    }
                                });
                            }
                        });
                    } else {
                        activeTrades.forEach(trade => {
                            if (trade.strategyPnlTax && trade.strategyDetails) {
                                Object.entries(trade.strategyPnlTax).forEach(([stratName, pnlTax]) => {
                                    if (!stratName.startsWith('A.PRO')) { // Only non-Amibroker strategies
                                        if (!strategyData[stratName]) {
                                            strategyData[stratName] = { net: 0, lotSum: 0, lotCount: 0 };
                                        }
                                        strategyData[stratName].net += pnlTax;
                                        
                                        // Get lot data from strategyDetails
                                        const stratDetail = trade.strategyDetails[stratName];
                                        if (stratDetail && stratDetail.lot) {
                                            strategyData[stratName].lotSum += stratDetail.lot;
                                            strategyData[stratName].lotCount += 1;
                                        }
                                    }
                                });
                            }
                        });
                    }
                    
                    // Calculate LOT PNL TAX for each strategy
                    const lotPnlTaxContributions = {};
                    Object.entries(strategyData).forEach(([stratName, data]) => {
                        const avgLot = data.lotCount > 0 ? (data.lotSum / data.lotCount) : 0;
                        const lotPnlTax = avgLot > 0 ? (data.net / avgLot) : 0;
                        if (lotPnlTax !== 0) {
                            lotPnlTaxContributions[stratName] = lotPnlTax;
                        }
                    });
                    
                    sortedStrategies = Object.entries(lotPnlTaxContributions)
                        .filter(([stratName, contribution]) => {
                            return contribution !== 0; // Keep all non-zero strategies
                        })
                        .sort((a, b) => {
                            const extractParts = (name) => {
                                const match = name.match(/([A-Z0-9]+)\s*PRO\s*(\d+)/i);
                                if (match) {
                                    return {
                                        broker: match[1],
                                        pro: parseInt(match[2])
                                    };
                                }
                                return { broker: name, pro: 0 };
                            };
                            
                            const partsA = extractParts(a[0]);
                            const partsB = extractParts(b[0]);
                            
                            if (partsA.broker !== partsB.broker) {
                                return partsA.broker.localeCompare(partsB.broker);
                            }
                            
                            return partsA.pro - partsB.pro;
                        })
                        .slice(0, 10);
                    
                    // Calculate total only from visible (non-hidden) strategies
                    totalValue = sortedStrategies.reduce((sum, [stratName, contrib]) => {
                        if (!hiddenStrategies.lotpnltax.has(formatStrategyName(stratName))) {
                            return sum + contrib;
                        }
                        return sum;
                    }, 0);
                    
                    charts.lotpnltax._cacheKey = cacheKey;
                    charts.lotpnltax._cachedStrategies = sortedStrategies;
                    charts.lotpnltax._cachedTotalValue = totalValue;
                }
                    
                let labels = [];
                let data = [];
                let colors = [];
                
                // Same color palette as Breakdown chart
                const strategyColors = {
                    'PRO 4': '#3b82f6',
                    'PRO 5': '#ec4899',
                    'PRO 8': '#8b5cf6',
                    'PRO 6': '#06b6d4',
                    'PRO 7': '#f59e0b'
                };
                const defaultColors = ['#3b82f6', '#ec4899', '#8b5cf6', '#06b6d4', '#f59e0b'];
                
                // Helper function to match colors by PRO number
                const getColorForStrategy = (stratName) => {
                    const match = stratName.match(/PRO\s*(\d+)/i);
                    if (match) {
                        const proKey = `PRO ${match[1]}`;
                        return strategyColors[proKey];
                    }
                    return null;
                };
                
                const isPercentageMode = displayTypes.lotpnltax === 'percentage';
                
                let cumulative = 0;
                const contributions = [];
                
                // Filter to only visible strategies for the chart
                const visibleStrategies = sortedStrategies.filter(([lotName]) => 
                    !hiddenStrategies.lotpnltax.has(formatStrategyName(lotName))
                );
                
                visibleStrategies.forEach(([lotName, contribution], index) => {
                    labels.push(formatStrategyName(lotName)); // Use formatStrategyName for proper spacing
                    contributions.push(contribution);
                    
                    let displayValue = contribution;
                    if (isPercentageMode && totalValue !== 0) {
                        displayValue = (contribution / Math.abs(totalValue)) * 100;
                    }
                    
                    const start = cumulative;
                    const end = cumulative + displayValue;
                    
                    data.push([Math.min(start, end), Math.max(start, end)]);
                    
                    cumulative += displayValue;
                    
                    if (contribution < 0) {
                        colors.push('#c2410c');
                    } else {
                        // Use color matching by PRO number, same as Breakdown
                        const baseColor = getColorForStrategy(lotName) || defaultColors[index % defaultColors.length];
                        colors.push(baseColor);
                    }
                });
                
                labels.push('Total');
                contributions.push(totalValue);
                
                const totalDisplayValue = isPercentageMode ? (totalValue >= 0 ? 100 : -100) : totalValue;
                
                if (totalDisplayValue >= 0) {
                    data.push([0, totalDisplayValue]);
                } else {
                    data.push([totalDisplayValue, 0]);
                }
                colors.push(totalValue < 0 ? '#c2410c' : '#10b981');
                
                charts.lotpnltax.data.labels = labels;
                charts.lotpnltax.data.datasets[0].data = data;
                charts.lotpnltax.data.datasets[0].backgroundColor = colors;
                
                // Store all strategies (including hidden) for legend generation
                charts.lotpnltax._allStrategies = sortedStrategies.map(([name]) => formatStrategyName(name));
                charts.lotpnltax._allColors = sortedStrategies.map(([name, contrib], index) => {
                    const strategyColors = {
                        'PRO 4': '#3b82f6',
                        'PRO 5': '#ec4899',
                        'PRO 8': '#8b5cf6',
                        'PRO 6': '#06b6d4',
                        'PRO 7': '#f59e0b'
                    };
                    const defaultColors = ['#3b82f6', '#ec4899', '#8b5cf6', '#06b6d4', '#f59e0b'];
                    const getColorForStrategy = (stratName) => {
                        const match = stratName.match(/PRO\s*(\d+)/i);
                        if (match) {
                            const proKey = `PRO ${match[1]}`;
                            return strategyColors[proKey];
                        }
                        return null;
                    };
                    if (contrib < 0) {
                        return '#c2410c';
                    } else {
                        return getColorForStrategy(name) || defaultColors[index % defaultColors.length];
                    }
                });
                
                charts.lotpnltax._contributions = contributions;
                charts.lotpnltax._totalValue = totalValue;
                
                charts.lotpnltax._preCalculatedLabels = contributions.map(value => {
                    let label;
                    if (displayTypes.lotpnltax === 'percentage') {
                        const percentValue = (value / Math.abs(totalValue || 1)) * 100;
                        label = percentValue.toFixed(1) + '%';
                    } else {
                        label = formatIndianShort(value);
                    }
                    return { label, value };
                });
                
                charts.lotpnltax.options.plugins.tooltip.callbacks.label = function(ctx) {
                    const value = charts.lotpnltax._contributions[ctx.dataIndex];
                    const total = charts.lotpnltax._totalValue;
                    
                    if (displayTypes.lotpnltax === 'percentage') {
                        if (total === 0) {
                            return '0.00%';
                        }
                        const percentValue = (value / Math.abs(total)) * 100;
                        const sign = percentValue < 0 ? '-' : '';
                        return `${sign}${Math.abs(percentValue).toFixed(2)}%`;
                    }
                    const sign = value < 0 ? '-' : '';
                    return `${sign}₹${formatIndianNumber(Math.abs(value), 2)}`;
                };
                
                charts.lotpnltax.options.scales.y.min = undefined;
                charts.lotpnltax.options.scales.y.max = undefined;
                
                // Force legend to regenerate
                charts.lotpnltax.options.plugins.legend.labels.generateLabels = charts.lotpnltax.options.plugins.legend.labels.generateLabels;
                
                charts.lotpnltax.update('none');
                charts.lotpnltax.render();
            }
        }
    </script>
</body>
</html>
