<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Detailed Report</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        html, body { width: 100%; height: 100%; }
        body {
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            background: #f8fafc;
            color: #1a1a1a;
            overflow-x: auto;
            -webkit-font-smoothing: antialiased;
            -moz-osx-font-smoothing: grayscale;
        }
        .main-content {
            padding: 16px 32px 32px 32px;
            background: #f8fafc;
            min-width: fit-content;
            overflow-x: auto;
        }
        .loading-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(248, 250, 252, 0.95);
            display: none;
            align-items: center;
            justify-content: center;
            z-index: 10000;
            backdrop-filter: blur(8px);
        }
        .loading-overlay.active { display: flex; }
        .loading-content {
            background: white;
            padding: 36px 52px;
            border-radius: 10px;
            box-shadow: 0 10px 15px rgba(0,0,0,0.1), 0 4px 6px rgba(0,0,0,0.05);
            text-align: center;
            border: 1px solid #e5e7eb;
        }
        .loading-spinner {
            height: 44px;
            border: 4px solid #e5e7eb;
            border-top-color: #1e40af;
            border-radius: 50%;
            animation: spin 0.8s linear infinite;
            margin: 0 auto 18px;
            aspect-ratio: 1;
        }
        @keyframes spin {
            to { transform: rotate(360deg); }
        }
        .loading-text {
            font-size: 14px;
            color: #374151;
            font-weight: 500;
            margin-bottom: 8px;
        }
        .loading-subtext {
            font-size: 12px;
            color: #9ca3af;
        }
        .page-header { margin-bottom: 16px; }
        .page-title { font-size: 20px; font-weight: 700; color: #111827; margin-bottom: 4px; letter-spacing: -0.5px; }
        .page-subtitle { font-size: 11px; color: #6b7280; font-weight: 400; }
        
        .controls-section {
            display: flex;
            gap: 8px;
            margin-bottom: 20px;
            flex-wrap: wrap;
            align-items: center;
        }
        .control-group { 
            display: flex; 
            align-items: center; 
            gap: 8px;
        }
        .control-group:empty {
            display: none;
        }
        .control-group input,
        .control-group select {
            min-width: 80px;
        }
        .control-group button {
            white-space: nowrap;
        }
        #brokerButtonsContainer {
            flex: 0 0 auto;
        }
        .control-label { font-size: 12px; color: #374151; font-weight: 600; letter-spacing: 0.1px; }
        .strategy-filter-container { 
            position: relative;
        }
        .strategy-filter-button {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            padding: 7px 12px;
            border: 1px solid #d1d5db;
            border-radius: 8px;
            font-size: 11px;
            font-weight: 500;
            background: white;
            color: #374151;
            cursor: pointer;
            transition: all 0.15s ease;
            white-space: nowrap;
        }
        .strategy-filter-button:hover { border-color: #9ca3af; background: #f9fafb; }
        .strategy-filter-dropdown {
            position: absolute;
            top: 100%;
            left: 0;
            margin-top: 6px;
            background: #ffffff;
            border: 1px solid #d1d5db;
            border-radius: 10px;
            box-shadow: 0 10px 15px rgba(0,0,0,0.1), 0 4px 6px rgba(0,0,0,0.05);
            width: max-content;
            max-height: 400px;
            overflow-y: auto;
            overflow-x: hidden;
            z-index: 1000;
            display: none;
            transform: translateZ(0);
            will-change: transform;
        }
        .strategy-filter-dropdown.active { display: block; }
        .strategy-filter-dropdown * { pointer-events: auto; }
        .strategy-filter-header {
            padding: 12px 14px;
            border-bottom: 1px solid #e2e8f0;
            display: flex;
            justify-content: space-between;
            align-items: center;
            position: sticky;
            top: 0;
            background: #ffffff;
            z-index: 100;
        }
        .strategy-filter-title { font-size: 12px; font-weight: 600; color: #1e293b; }
        .strategy-filter-actions { display: flex; gap: 8px; }
        .filter-action-btn {
            font-size: 11px;
            color: #1e40af;
            cursor: pointer;
            padding: 4px 8px;
            border-radius: 4px;
            transition: background 0.2s ease;
        }
        .filter-action-btn:hover { background: #eff6ff; }
        .quick-date-btn {
            padding: 6px 10px;
            border: 1px solid #d1d5db;
            border-radius: 6px;
            font-size: 11px;
            font-weight: 500;
            background: white;
            color: #374151;
            cursor: pointer;
            transition: all 0.15s ease;
            text-align: center;
        }
        .quick-date-btn:hover {
            background: #eff6ff;
            border-color: #1e40af;
            color: #1e40af;
        }
        .strategy-filter-list { 
            padding: 8px 0; 
            background: #ffffff;
        }
        .filter-info-note {
            padding: 10px 14px;
            background: #eff6ff;
            border-top: 1px solid #e2e8f0;
            font-size: 11px;
            color: #1e40af;
            line-height: 1.4;
            margin-top: 8px;
        }
        .strategy-filter-item {
            display: flex;
            align-items: center;
            padding: 8px 14px;
            cursor: pointer;
            transition: background 0.2s ease;
            background: #ffffff;
        }
        .strategy-filter-item:hover { background: #f8fafc; }
        .strategy-filter-checkbox { 
            margin-right: 10px; 
            height: 16px; 
            cursor: pointer;
            pointer-events: auto !important;
            position: relative;
            z-index: 10;
            aspect-ratio: 1;
        }
        .strategy-filter-label { 
            font-size: 12px; 
            color: #475569; 
            cursor: pointer; 
            user-select: none; 
            flex: 1;
            pointer-events: none;
        }
        .date-month-item { font-weight: 500; color: #1e293b; }
        .date-day-item { padding-left: 32px; font-size: 12px; }
        .expand-icon {
            display: inline-block;
            height: 18px;
            margin-right: 6px;
            font-size: 11px;
            color: #6b7280;
            text-align: center;
            line-height: 18px;
            transition: transform 0.2s ease;
            cursor: pointer;
            pointer-events: auto;
            position: relative;
            z-index: 10;
            aspect-ratio: 1;
        }
        .expand-icon.expanded { transform: rotate(90deg); }
        .month-children { display: none; }
        .month-children.expanded { display: block; }
        .filter-badge {
            display: inline-block;
            background: #1e40af;
            color: white;
            font-size: 9px;
            padding: 2px 5px;
            border-radius: 10px;
            margin-left: 6px;
            font-weight: 600;
        }
        
        select, input, button {
            padding: 7px 12px;
            border: 1px solid #d1d5db;
            border-radius: 8px;
            font-size: 11px;
            font-weight: 500;
            background: white;
            color: #374151;
            cursor: pointer;
            transition: all 0.15s ease;
            font-family: inherit;
            white-space: nowrap;
        }
        select:hover, input:hover, button:hover { 
            border-color: #9ca3af;
            background: #f9fafb;
        }
        select:focus, input:focus, button:focus {
            outline: none;
            border-color: #0284c7;
            box-shadow: 0 0 0 1px rgba(2, 132, 199, 0.1);
        }
        button.primary { 
            background: #1e40af;
            color: white;
            border-color: #1e40af;
            font-weight: 500;
        }
        button.primary:hover { 
            background: #1e3a8a;
            border-color: #1e3a8a;
        }
        
        /* Make specific buttons extend */
        #toggleBuySellBtn,
        #toggleTimeBtn,
        #toggleLotBtn,
        #applyFiltersBtn,
        #resetFiltersBtn,
        #exportCSVBtn {
            flex: 1;
            min-width: fit-content;
        }
        
        #symbolFilter {
            box-sizing: border-box;
        }
        
        #rowsPerPage {
            box-sizing: border-box;
        }
        
        .table-container {
            background: white;
            border-radius: 10px;
            box-shadow: 0 1px 3px rgba(0,0,0,0.06), 0 1px 2px rgba(0,0,0,0.04);
            border: 1px solid #e5e7eb;
            display: block;
            width: 100%;
            min-width: fit-content;
        }
        .table-wrapper { 
            scrollbar-width: thin;
            scrollbar-color: #d1d5db #f9fafb;
        }
        .table-wrapper::-webkit-scrollbar { width: 8px; height: 8px; }
        .table-wrapper::-webkit-scrollbar-track { background: #f9fafb; }
        .table-wrapper::-webkit-scrollbar-thumb { background: #d1d5db; border-radius: 4px; }
        .table-wrapper::-webkit-scrollbar-thumb:hover { background: #9ca3af; }
        .report-table {
            width: 100%;
            border-collapse: separate;
            border-spacing: 0;
            font-size: 12px;
            font-variant-numeric: tabular-nums;
        }
        .report-table thead { 
            position: sticky; 
            top: 0; 
            z-index: 10; 
            box-shadow: 0 2px 4px rgba(0,0,0,0.06);
        }
        .report-table thead tr.header-row-1, .report-table thead tr.header-row-2, .report-table thead tr.totals-row { height: auto; }
        .report-table thead tr.totals-row th {
            padding: 6px 6px;
            position: sticky;
            top: 0;
            background: linear-gradient(to bottom, #f8fafc 0%, #f1f5f9 100%);
            z-index: 11;
            font-size: 11.5px;
            text-align: center;
            font-weight: 600;
            color: #1e40af;
            border-bottom: 1px solid #94a3b8;
            border-right: 1px solid #d1d5db;
            white-space: nowrap;
            letter-spacing: 0.2px;
        }
        .report-table thead tr.totals-row th.number-col {
            text-align: right;
        }
        .report-table thead tr.totals-row th.positive { color: #15803d; }
        .report-table thead tr.totals-row th.negative { color: #b96060; }
        .report-table thead tr.header-row-1 th {
            padding: 10px 6px 10px 6px;
            position: sticky;
            top: 28px;
            background: linear-gradient(to bottom, #f8fafc 0%, #f1f5f9 100%);
            z-index: 10;
            font-size: 10.5px;
            text-align: center;
            font-weight: 600;
            color: #0f172a;
            border-bottom: 1px solid #cbd5e1;
            border-right: 1px solid #e2e8f0;
            white-space: nowrap;
            text-transform: uppercase;
            letter-spacing: 0.3px;
            transition: background 0.2s ease;
        }
        /* Slightly reduced height for broker strategy group headers */
        .report-table thead tr.header-row-1 th[colspan] {
            padding: 4px 6px 4px 6px;
        }
        .report-table thead tr.header-row-1 th[rowspan="2"] {
            border-bottom: 1px solid #94a3b8;
            cursor: pointer;
            user-select: none;
            box-shadow: inset 0 -1px 0 rgba(0,0,0,0.05);
        }
        .report-table thead tr.header-row-1 th[rowspan="2"]:hover { 
            background: linear-gradient(to bottom, #eff6ff 0%, #dbeafe 100%);
            color: #1e40af;
        }
        .report-table thead tr.header-row-2 th {
            padding: 4px 4px 4px 4px;
            font-size: 9.5px;
            position: sticky;
            top: 50px;
            background: linear-gradient(to bottom, #f1f5f9 0%, #e2e8f0 100%);
            z-index: 10;
            font-weight: 450;
            color: #475569;
            text-align: center;
            border-bottom: 1px solid #94a3b8;
            border-right: 1px solid #e2e8f0;
            white-space: nowrap;
            text-transform: uppercase;
            cursor: pointer;
            user-select: none;
            letter-spacing: 0.3px;
            transition: all 0.2s ease;
        }
        .report-table thead tr.header-row-2 th:hover { 
            background: linear-gradient(to bottom, #dbeafe 0%, #bfdbfe 100%);
            color: #1e40af;
        }
        .report-table th.sortable::after {
            content: '';
            opacity: 0;
            font-size: 10px;
            margin-left: 3px;
        }
        .report-table th.sorted-asc::after { 
            content: ' ↑'; 
            opacity: 1; 
            color: #1e40af;
            font-weight: 700;
        }
        .report-table th.sorted-desc::after { 
            content: ' ↓'; 
            opacity: 1; 
            color: #1e40af;
            font-weight: 700;
        }
        .report-table th.number-col { text-align: right; }
        
        .filter-icon {
            display: inline-block;
            margin-left: 3px;
            font-size: 10px;
            opacity: 0.5;
            cursor: pointer;
            transition: opacity 0.2s ease;
        }
        .filter-icon:hover { opacity: 1; }
        .filter-icon.active { 
            opacity: 1;
    	    color: #ffffff;
            background: #dc2626;
	    font-weight: 700;
        }
        
        .filter-popup-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: transparent;
            display: none;
            z-index: 10001;
        }
        .filter-popup-overlay.active { display: block; }
        
        .filter-popup {
            position: absolute;
            background: white;
            border-radius: 6px;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.15);
            border: 1px solid #d1d5db;
            max-height: 280px;
            overflow: hidden;
            display: flex;
            flex-direction: column;
        }
        
        .filter-popup-header {
            padding: 6px 8px;
            border-bottom: 1px solid #e5e7eb;
            display: flex;
            justify-content: space-between;
            align-items: center;
            background: #f8fafc;
        }
        
        .filter-popup-title {
            font-size: 11px;
            font-weight: 600;
            color: #1f2937;
        }
        
        .filter-popup-close {
            background: none;
            border: none;
            font-size: 14px;
            color: #6b7280;
            cursor: pointer;
            padding: 0;
            height: 16px;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 3px;
            aspect-ratio: 1;
        }
        .filter-popup-close:hover {
            background: #e5e7eb;
            color: #1f2937;
        }
        
        .filter-popup-body {
            padding: 8px;
            overflow-y: auto;
        }
        
        .filter-type-selector {
            margin-bottom: 6px;
        }
        
        .filter-type-selector label {
            display: block;
            font-size: 11px;
            font-weight: 600;
            color: #374151;
            margin-bottom: 2px;
        }
        
        .filter-type-selector select {
            width: 100%;
            padding: 4px 6px;
            font-size: 11px;
        }
        
        .filter-inputs {
            display: flex;
            flex-direction: column;
            gap: 6px;
        }
        
        .filter-input-group label {
            display: block;
            font-size: 11px;
            font-weight: 500;
            color: #374151;
            margin-bottom: 2px;
        }
        
        .filter-input-group input {
            width: 100%;
            padding: 4px 6px;
            font-size: 11px;
        }
        
        .filter-popup-footer {
            padding: 6px 8px;
            border-top: 1px solid #e5e7eb;
            display: flex;
            gap: 4px;
            justify-content: flex-end;
            background: #f8fafc;
        }
        
        .filter-popup-footer button {
            padding: 4px 8px;
            font-size: 11px;
        }
        
        .report-table tbody tr {
            transition: all 0.15s ease;
            border-bottom: 1px solid #f3f4f6;
        }
        .report-table tbody tr:hover { 
            background: #f0f4f8;
            box-shadow: 0 1px 2px rgba(0,0,0,0.04);
        }
        .report-table tbody tr:nth-child(even) { background: #f9fafb; }
        .report-table tbody tr:nth-child(even):hover { background: #f0f4f8; }
        .report-table td {
            padding: 10px 6px;
            border-bottom: 1px solid #f3f4f6;
            border-right: 1px solid #f0f0f0;
            color: #1f2937;
            white-space: nowrap;
            font-size: 12px;
            font-variant-numeric: tabular-nums;
            font-weight: 400;
            overflow: hidden;
            text-overflow: ellipsis;
            vertical-align: middle;
            box-sizing: border-box;
        }
        .report-table td:nth-child(1) { text-align: center; color: #4b5563; font-weight: 400; font-size: 11.5px; }
        .report-table td:nth-child(2) { font-weight: 400; color: #1f2937; font-size: 11.5px; }
        .report-table td:nth-child(3) { font-weight: 400; color: #1f2937; font-size: 11.5px; }
        .report-table td:nth-child(4) { font-size: 11.5px; }
        .report-table td:nth-child(5) { font-weight: 400; color: #1f2937; font-size: 11.5px; }
        .report-table td:nth-child(6) { font-size: 11.5px; }
        .report-table td:nth-child(7), .report-table td:nth-child(8) { font-size: 11.5px; }
        .report-table td:nth-child(9) { 
        }
        .report-table td:nth-child(11) { 
            border-right: 1px solid #e5e7eb;
        }
        .report-table thead tr.totals-row th:nth-child(11) { 
            border-right: 1px solid #e5e7eb;
        }
        .report-table thead tr.header-row-1 th:nth-child(11) { 
            border-right: 1px solid #e5e7eb;
        }
        .report-table td.number-col {
            text-align: right;
            font-variant-numeric: tabular-nums;
            font-weight: 400;
        }
        .report-table td.positive { color: #15803d; font-weight: 450; }
        .report-table td.negative { color: #b96060; font-weight: 450; }
        .buy-sell-column { display: none; }
        .buy-sell-column.visible { display: table-cell; }
        
        .time-column { display: none; }
        .time-column.visible { display: table-cell; }
        .report-table td.time-column, .report-table th.time-column { color: #475569; font-weight: 400; }
        .lot-column { display: none; }
        .lot-column.visible { display: table-cell; }
        
        .report-table td.price-column, .report-table th.price-column { color: #475569; font-weight: 400; }
        
        /* Single strategy view */
        .table-wrapper.single-strategy .report-table thead tr.header-row-1 th {
        }
        .table-wrapper.single-strategy .report-table thead tr.header-row-2 th {
        }
        .table-wrapper.single-strategy .report-table th.number-col {
        }
        .table-wrapper.single-strategy .report-table td.number-col {
        }
        .table-wrapper.single-strategy .report-table td:nth-child(1) {
        }
        .table-wrapper.single-strategy .report-table td:nth-child(2) {
        }
        .table-wrapper.single-strategy .report-table td:nth-child(3) {
        }
        .table-wrapper.single-strategy .report-table td:nth-child(4) {
        }
        .table-wrapper.single-strategy .report-table td:nth-child(5) {
        }
        .table-wrapper.single-strategy .report-table td:nth-child(6) {
        }
        .table-wrapper.single-strategy .report-table td:nth-child(7),
        .table-wrapper.single-strategy .report-table td:nth-child(8) {
        }
        .table-wrapper.single-strategy .report-table td:nth-child(9) {
        }
        .table-wrapper.single-strategy .report-table td {
        }
        
        .no-data { 
            text-align: center; 
            color: #9ca3af; 
            padding: 60px 40px; 
            font-size: 12px;
            font-variant-numeric: tabular-nums;
            font-weight: 400;
            background: #f8fafc;
        }
        
        .pagination {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 14px 20px;
            background: #f8fafc;
            border-top: 1px solid #e5e7eb;
            width: 100%;
            min-width: fit-content;
            box-sizing: border-box;
        }
        .pagination-info { font-size: 12px; color: #6b7280; font-weight: 400; }
        .pagination-controls { display: flex; gap: 8px; }
        .pagination-btn {
            padding: 5px 10px;
            border: 1px solid #d1d5db;
            border-radius: 6px;
            background: white;
            color: #374151;
            font-size: 10.5px;
            font-weight: 450;
            cursor: pointer;
            transition: all 0.15s ease;
        }
        .pagination-btn:hover:not(:disabled) { 
            background: #f9fafb;
            border-color: #9ca3af;
        }
        .pagination-btn:disabled { opacity: 0.4; cursor: not-allowed; }
        .pagination-btn.active { 
            background: #1e40af;
            color: white;
            border-color: #1e40af;
        }
        
        @media (max-width: 768px) {
            .main-content { padding: 12px; }
            .controls-section { flex-direction: column; align-items: stretch; }
            .control-group { flex-direction: column; align-items: stretch; }
            select, input, button { width: 100%; }
            .filter-popup { 
                width: calc(100vw - 20px);
                max-width: 180px;
                left: 10px !important;
            }
        }
        .custom-date-range {
            display: flex;
            gap: 4px;
            align-items: center;
            padding: 4px 8px;
            background: transparent;
            border-radius: 6px;
        }
        .custom-date-range label {
            font-size: 10px;
            font-weight: 600;
            color: #64748b;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }
        .custom-date-range input[type="date"] {
            padding: 5px 4px;
            font-size: 10px;
            border: 1px solid #e5e7eb;
            border-radius: 4px;
            font-family: inherit;
            color: #475569;
            cursor: pointer;
            background: transparent;
        }
        .date-nav-arrows {
            display: flex;
            flex-direction: column;
            gap: 1px;
            margin-left: 2px;
        }
        .date-nav-arrows button {
            padding: 0;
            width: 16px;
            height: 11px;
            font-size: 8px;
            line-height: 1;
            border: 1px solid #e5e7eb;
            background: transparent;
            color: #64748b;
            border-radius: 2px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.15s ease;
        }
        .date-nav-arrows button:hover {
            background: transparent;
            color: #475569;
            border-color: #cbd5e1;
        }
        .date-range-buttons {
            display: flex;
            gap: 4px;
        }
        .date-range-buttons .btn {
            padding: 5px 8px;
            font-size: 10px;
            font-weight: 600;
            color: #64748b;
            background: transparent;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.2s ease;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }
        .date-range-buttons .btn:hover {
            background: #e2e8f0;
            color: #475569;
        }
        .date-range-buttons .btn.active {
            background: white;
            color: #3b82f6;
            border: 1px solid #e5e7eb;
        }
    </style>
</head>
<body>
    <div class="main-content">
        <div class="loading-overlay" id="loadingOverlay">
            <div class="loading-content">
                <div class="loading-spinner"></div>
                <div class="loading-text" id="loadingText">Processing data...</div>
                <div class="loading-subtext" id="loadingSubtext">Please wait</div>
            </div>
        </div>

        <div class="filter-popup-overlay" id="filterPopupOverlay">
            <div class="filter-popup">
                <div class="filter-popup-header">
                    <div class="filter-popup-title" id="filterPopupTitle">Filter Column</div>
                    <button class="filter-popup-close" onclick="closeFilterPopup()">×</button>
                </div>
                <div class="filter-popup-body">
                    <div class="filter-type-selector">
                        <label>Type:</label>

                        <select id="filterType" onchange="updateFilterInputs()">
                            <option value="contains">Contains</option>
                            <option value="equals">Equals</option>
                            <option value="notEquals">Not Equal</option>
                            <option value="greaterThan">Greater Than</option>
                            <option value="lessThan">Less Than</option>
                            <option value="between">Between</option>
                            <option value="isBlank">Is Blank</option>
                            <option value="isNotBlank">Is Not Blank</option>
                        </select>

                    </div>
                    <div class="filter-inputs" id="filterInputs">
                        <div class="filter-input-group">
                            <label id="filterLabel1">Value:</label>
                            <input type="text" id="filterValue1" placeholder="Value">
                        </div>
                        <div class="filter-input-group" id="filterValue2Group" style="display: none;">
                            <label>To:</label>
                            <input type="text" id="filterValue2" placeholder="Value">
                        </div>
                    </div>
                </div>
                <div class="filter-popup-footer">
                    <button onclick="clearColumnFilter()">Clear</button>
                    <button class="primary" onclick="applyColumnFilter()">Apply</button>
                </div>
            </div>
        </div>

        <div class="page-header" style="display: flex; justify-content: space-between; align-items: flex-start; margin-bottom: 16px;">
            <div>
                <h1 class="page-title">Detailed Trade Report</h1>
                <p class="page-subtitle">Complete transaction history with broker-wise data</p>
            </div>
            <!-- Date Range Controls aligned to right -->
            <div style="display: flex; gap: 3px; align-items: center; padding: 5px 6px; background: #f1f5f9; border-radius: 8px; white-space: nowrap;">
                <div class="custom-date-range" style="padding: 0px 2px;">
                    <label style="font-size: 10px;">FROM:</label>
                    <input type="date" id="fromDateInput" style="width: 95px; padding: 5px 4px; font-size: 10px;">
                    <div class="date-nav-arrows">
                        <button onclick="navigateFromDate('prev')" title="Previous month start">▲</button>
                        <button onclick="navigateFromDate('next')" title="Next month start">▼</button>
                    </div>
                </div>
                <div class="custom-date-range" style="padding: 0px 2px;">
                    <label style="font-size: 10px;">TO:</label>
                    <input type="date" id="toDateInput" style="width: 95px; padding: 5px 4px; font-size: 10px;">
                    <div class="date-nav-arrows">
                        <button onclick="navigateToDate('prev')" title="Previous month end">▲</button>
                        <button onclick="navigateToDate('next')" title="Next month end">▼</button>
                    </div>
                </div>
                <div class="date-range-buttons" style="gap: 2px;">
                    <button class="btn" onclick="setReportDateRange('3M')" style="padding: 5px 8px; font-size: 10px;">LAST 3M</button>
                    <button class="btn" onclick="setReportDateRange('YTD')" style="padding: 5px 8px; font-size: 10px;">YTD</button>
                    <button class="btn" onclick="setReportDateRange('ALL')" style="padding: 5px 8px; font-size: 10px;">ALL TIME</button>
                </div>
            </div>
        </div>

        <div class="controls-section">
            <div class="strategy-filter-container">
                <button class="strategy-filter-button" id="dateFilterBtn">
                    <span>Date Filter</span>
                    <span class="filter-badge" id="dateFilterBadge" style="display: none;">0</span>
                    <span>▼</span>
                </button>
                <div class="strategy-filter-dropdown" id="dateFilterDropdown" style="min-width: 240px;">
                    <div class="strategy-filter-header">
                        <span class="strategy-filter-title">Select Dates</span>
                        <div class="strategy-filter-actions">
                            <span class="filter-action-btn" id="selectAllDatesBtn">All</span>
                            <span class="filter-action-btn" id="deselectAllDatesBtn">Clear</span>
                        </div>
                    </div>
                    <div style="padding: 8px 14px; border-bottom: 1px solid #e2e8f0; display: grid; grid-template-columns: repeat(2, 1fr); gap: 6px;">
                        <button class="quick-date-btn" id="todayBtn">Today</button>
                        <button class="quick-date-btn" id="yesterdayBtn">Yesterday</button>
                        <button class="quick-date-btn" id="thisWeekBtn">This Week</button>
                        <button class="quick-date-btn" id="lastWeekBtn">Last Week</button>
                        <button class="quick-date-btn" id="thisMonthBtn">This Month</button>
                        <button class="quick-date-btn" id="lastMonthBtn">Last Month</button>
                    </div>
                    <div class="strategy-filter-list" id="dateFilterList"></div>
                </div>
            </div>
            <div class="strategy-filter-container">
                <button class="strategy-filter-button" id="strategyNumberBtn">
                    <span id="strategyNumberText">All Strategies</span>
                    <span>▼</span>
                </button>
                <div class="strategy-filter-dropdown" id="strategyNumberDropdown">
                    <div class="strategy-filter-header">
                        <span class="strategy-filter-title">Switch Strategy</span>
                    </div>
                    <div class="strategy-filter-list" id="strategyNumberList"></div>
                </div>
            </div>
            <div class="strategy-filter-container">
                <button class="strategy-filter-button" id="strategyFilterBtn">
                    <span>Hide Strategies</span>
                    <span class="filter-badge" id="strategyFilterBadge" style="display: none;">0</span>
                    <span>▼</span>
                </button>
                <div class="strategy-filter-dropdown" id="strategyFilterDropdown">
                    <div class="strategy-filter-header">
                        <span class="strategy-filter-title">Select Stg</span>
                        <div class="strategy-filter-actions">
                            <span class="filter-action-btn" id="selectAllStrategiesBtn">All</span>
                            <span class="filter-action-btn" id="deselectAllStrategiesBtn">Clear</span>
                        </div>
                    </div>
                    <div class="strategy-filter-list" id="strategyFilterList"></div>
                </div>
            </div>
            <div class="strategy-filter-container">
                <button class="strategy-filter-button" id="brokerStrategyFilterBtn">
                    <span>Hide Broker Columns</span>
                    <span class="filter-badge" id="brokerFilterBadge" style="display: none;">0</span>
                    <span>▼</span>
                </button>
                <div class="strategy-filter-dropdown" id="brokerStrategyFilterDropdown">
                    <div class="strategy-filter-header">
                        <span class="strategy-filter-title">Hide Columns</span>
                        <div class="strategy-filter-actions">
                            <span class="filter-action-btn" id="selectAllBrokerStrategiesBtn">All</span>
                            <span class="filter-action-btn" id="deselectAllBrokerStrategiesBtn">Clear</span>
                        </div>
                    </div>
                    <div class="strategy-filter-list" id="brokerStrategyFilterList"></div>
                    <div class="filter-info-note">
                        ℹ️ Only hides columns, not rows
                    </div>
                </div>
            </div>
            <div class="control-group" id="brokerButtonsContainer">
                <!-- Broker buttons will be dynamically generated here -->
            </div>
            <button id="toggleBuySellBtn" onclick="toggleBuySellColumns()">
                <span id="buySellBtnText">Show Buy/Sell/Qty</span>
            </button>
            <button id="toggleTimeBtn" onclick="toggleTimeColumns()">
                <span id="timeBtnText">Show Time</span>
            </button>
            <button id="toggleLotBtn" onclick="toggleLotColumns()">
                <span id="lotBtnText">Show Lot</span>
            </button>
            <div class="control-group">
                <label class="control-label">Symbol:</label>
                <input type="text" id="symbolFilter" placeholder="Filter...">
            </div>
            <div class="control-group">
                <label class="control-label">Rows:</label>
                <select id="rowsPerPage">
                    <option value="10">10</option>
                    <option value="15" selected>15</option>
                    <option value="50">50</option>
                    <option value="100">100</option>
                    <option value="all">All</option>
                </select>
            </div>
            <button class="primary" id="applyFiltersBtn">Apply</button>
            <button id="resetFiltersBtn">Reset</button>
            <button id="exportCSVBtn">Export CSV</button>
        </div>

        <div class="table-container">
            <div class="table-wrapper">
                <table class="report-table" id="reportTable">
                    <thead id="tableHeaders">
                        <tr>
                            <th rowspan="2" class="sortable" data-column="sno">S.No</th>
                            <th rowspan="2" class="sortable" data-column="date">Date</th>
                            <th rowspan="2" class="sortable" data-column="strategy">STG</th>
                            <th rowspan="2" class="sortable" data-column="trade">Trade</th>
                            <th rowspan="2" class="sortable" data-column="symbol">Symbol</th>
                            <th rowspan="2" class="sortable number-col" data-column="qty">Qty</th>
                            <th rowspan="2" class="sortable number-col" data-column="entry">Entry</th>
                            <th rowspan="2" class="sortable number-col" data-column="exit">Exit</th>
                            <th rowspan="2" class="sortable number-col" data-column="profit">Profit</th>
                        </tr>
                        <tr class="header-row-2"></tr>
                    </thead>
                    <tbody id="tableBody">
                        <tr>
                            <td colspan="100" class="no-data">No data available</td>
                        </tr>
                    </tbody>
                </table>
                <div class="pagination" id="pagination" style="display: none;">
                    <div class="pagination-info" id="paginationInfo">Showing 0 of 0</div>
                    <div class="pagination-controls" id="paginationControls"></div>
                </div>
            </div>
        </div>
    </div>

    <script>
        let allTrades = [];
        let originalAllTrades = []; // Store original unfiltered data
        let filteredTrades = [];
        let currentPage = 1;
        let sortColumn = null;
        let sortDirection = 'asc';
        let brokerStrategies = [];
        let uniqueBrokers = []; // List of unique broker codes (ACA, CEA, ZEA, etc.)
        let strategies = [];
        let hiddenBrokerStrategies = new Set();
        let manualHiddenBrokerStrategies = new Set(); // Tracks manual hides from "Hide Broker Columns"
        let hiddenStrategies = new Set();
        let dateStructure = {};
        let hiddenDates = new Set();
        let collapsedMonths = new Set();
        let showBuySellColumns = false;
        let originalBuySellState = false; // Tracks original Buy/Sell/Qty state before strategy selection
        let showTimeColumns = false; // Time columns hidden by default
        let originalTimeState = false; // Tracks original Time state before strategy selection
        let showLotColumns = false; // Lot columns hidden by default
        let originalLotState = false; // Tracks original Lot state before strategy selection
        let columnFilters = {};
        let currentFilterColumn = null;
        let selectedStrategyNumber = null; // null means "All Strategies"
        let selectedBrokerFilter = null; // null means "All Broker", or broker code like "ACA"
        let savedAllStrategiesState = null; // Save broker filter state when "All Strategies" is active
        let dropdownCloseTimeout = null; // Timeout for delayed dropdown closing

        // Initialize with one sample strategy
        function initializeSampleStrategy() {
            brokerStrategies = ['STRATEGY1', 'STRATEGY2', 'STRATEGY3', 'STRATEGY4'];
            strategies = ['Strategy Name'];
            
            // No trade data - headers will show with 0 values
            allTrades = [];
            filteredTrades = [];
            
            // Build date structure (empty)
            dateStructure = {};
            
            // Update filter lists
            updateBrokerStrategyFilterList();
            updateStrategyFilterList();
            updateStrategyNumberList();
            updateDateFilterList();
        }

        const elements = {
            loadingOverlay: document.getElementById('loadingOverlay'),
            loadingText: document.getElementById('loadingText'),
            loadingSubtext: document.getElementById('loadingSubtext'),
            dateFilterBtn: document.getElementById('dateFilterBtn'),
            dateFilterDropdown: document.getElementById('dateFilterDropdown'),
            dateFilterList: document.getElementById('dateFilterList'),
            dateFilterBadge: document.getElementById('dateFilterBadge'),
            selectAllDatesBtn: document.getElementById('selectAllDatesBtn'),
            deselectAllDatesBtn: document.getElementById('deselectAllDatesBtn'),
            strategyFilterBtn: document.getElementById('strategyFilterBtn'),
            strategyFilterDropdown: document.getElementById('strategyFilterDropdown'),
            strategyFilterList: document.getElementById('strategyFilterList'),
            strategyFilterBadge: document.getElementById('strategyFilterBadge'),
            selectAllStrategiesBtn: document.getElementById('selectAllStrategiesBtn'),
            deselectAllStrategiesBtn: document.getElementById('deselectAllStrategiesBtn'),
            brokerStrategyFilterBtn: document.getElementById('brokerStrategyFilterBtn'),
            brokerStrategyFilterDropdown: document.getElementById('brokerStrategyFilterDropdown'),
            brokerStrategyFilterList: document.getElementById('brokerStrategyFilterList'),
            brokerFilterBadge: document.getElementById('brokerFilterBadge'),
            selectAllBrokerStrategiesBtn: document.getElementById('selectAllBrokerStrategiesBtn'),
            deselectAllBrokerStrategiesBtn: document.getElementById('deselectAllBrokerStrategiesBtn'),
            strategyNumberBtn: document.getElementById('strategyNumberBtn'),
            strategyNumberDropdown: document.getElementById('strategyNumberDropdown'),
            strategyNumberList: document.getElementById('strategyNumberList'),
            strategyNumberText: document.getElementById('strategyNumberText'),
            symbolFilter: document.getElementById('symbolFilter'),
            rowsPerPage: document.getElementById('rowsPerPage'),
            applyFiltersBtn: document.getElementById('applyFiltersBtn'),
            resetFiltersBtn: document.getElementById('resetFiltersBtn'),
            exportCSVBtn: document.getElementById('exportCSVBtn'),
            tableHeaders: document.getElementById('tableHeaders'),
            tableBody: document.getElementById('tableBody'),
            pagination: document.getElementById('pagination'),
            paginationInfo: document.getElementById('paginationInfo'),
            paginationControls: document.getElementById('paginationControls'),
            filterPopupOverlay: document.getElementById('filterPopupOverlay'),
            filterPopupTitle: document.getElementById('filterPopupTitle'),
            filterType: document.getElementById('filterType'),
            filterValue1: document.getElementById('filterValue1'),
            filterValue2: document.getElementById('filterValue2'),
            filterValue2Group: document.getElementById('filterValue2Group')
        };

        function openFilterPopup(column, stratName = null, field = null, iconElement = null) {
            currentFilterColumn = { column, stratName, field };
            
            let columnName;
            if (column) {
                columnName = column === 'sno' ? 'No' : 
                            column === 'strategy' ? 'Strat' :
                            column === 'symbol' ? 'Sym' :
                            column.toUpperCase();
            } else if (stratName && field) {
                const shortStrat = stratName.replace(/^B\d+PRO/, 'P');
                columnName = `${shortStrat} ${field.toUpperCase()}`;
            }
            
            elements.filterPopupTitle.textContent = columnName;
            
            const filterKey = getFilterKey(column, stratName, field);
            const existingFilter = columnFilters[filterKey];
            
            if (existingFilter) {
                elements.filterType.value = existingFilter.type;
                elements.filterValue1.value = existingFilter.value1 || '';
                elements.filterValue2.value = existingFilter.value2 || '';
            } else {
                elements.filterType.value = 'contains';
                elements.filterValue1.value = '';
                elements.filterValue2.value = '';
            }
            
            updateFilterInputs();
            elements.filterPopupOverlay.classList.add('active');
            
            // Position the popup near the clicked icon
            if (iconElement) {
                const rect = iconElement.getBoundingClientRect();
                const popup = document.querySelector('.filter-popup');
                
                // Calculate position
                let left = rect.left;
                let top = rect.bottom + 5;
                
                // Adjust if popup would go off-screen
                const popupWidth = 180;
                const popupHeight = 220;
                
                if (left + popupWidth > window.innerWidth) {
                    left = window.innerWidth - popupWidth - 10;
                }
                
                if (top + popupHeight > window.innerHeight) {
                    top = rect.top - popupHeight - 5;
                }
                
                popup.style.left = `${left}px`;
                popup.style.top = `${top}px`;
            }
            
            // Add Enter key listener
            const handleEnter = (e) => {
                if (e.key === 'Enter') {
                    applyColumnFilter();
                }
            };
            
            elements.filterValue1.removeEventListener('keypress', handleEnter);
            elements.filterValue2.removeEventListener('keypress', handleEnter);
            elements.filterValue1.addEventListener('keypress', handleEnter);
            elements.filterValue2.addEventListener('keypress', handleEnter);
            
            // Focus on first input
            setTimeout(() => elements.filterValue1.focus(), 100);
        }

        function closeFilterPopup() {
            elements.filterPopupOverlay.classList.remove('active');
            currentFilterColumn = null;
        }

        function updateFilterInputs() {
            const filterType = elements.filterType.value;
            const isBetween = filterType === 'between';
            const isBlankFilter = filterType === 'isBlank' || filterType === 'isNotBlank';
            
            elements.filterValue2Group.style.display = isBetween ? 'block' : 'none';
            
            // Hide both input groups for blank filters
            if (isBlankFilter) {
                document.querySelector('.filter-input-group').style.display = 'none';
                elements.filterValue2Group.style.display = 'none';
            } else {
                document.querySelector('.filter-input-group').style.display = 'block';
            }
            
            const labels = {
                contains: 'Value:',
                equals: 'Value:',
                notEquals: 'Value:',
                greaterThan: 'Greater:',
                lessThan: 'Less:',
                greaterOrEqual: 'Min:',
                lessOrEqual: 'Max:',
                between: 'From:',
                isBlank: '',
                isNotBlank: ''
            };
            
            document.getElementById('filterLabel1').textContent = labels[filterType] || 'Value:';
        }
                           
        function getFilterKey(column, stratName, field) {
            if (column) {
                return column;
            } else if (stratName && field) {
                return `${stratName}_${field}`;
            }
            return null;
        }

        function applyColumnFilter() {
            if (!currentFilterColumn) return;
            
            const { column, stratName, field } = currentFilterColumn;
            const filterKey = getFilterKey(column, stratName, field);
            
            const filterType = elements.filterType.value;
            const value1 = elements.filterValue1.value.trim();
            const value2 = elements.filterValue2.value.trim();
            
            // Allow blank filters without requiring input values
            if (filterType === 'isBlank' || filterType === 'isNotBlank') {
                columnFilters[filterKey] = {
                    type: filterType,
                    value1: '',
                    value2: ''
                };
                closeFilterPopup();
                applyFilters();
                return;
            }
            
            if (!value1 && filterType !== 'between') {
                closeFilterPopup();
                return;
            }
            
            if (filterType === 'between' && (!value1 || !value2)) {
                alert('Please enter both values for Between filter');
                return;
            }
            
            columnFilters[filterKey] = {
                type: filterType,
                value1: value1,
                value2: value2
            };
            
            closeFilterPopup();
            applyFilters();
        }

        function clearColumnFilter() {
            if (!currentFilterColumn) return;
            
            const { column, stratName, field } = currentFilterColumn;
            const filterKey = getFilterKey(column, stratName, field);
            
            delete columnFilters[filterKey];
            
            closeFilterPopup();
            applyFilters();
        }

        function testFilter(value, filter) {
            // Handle blank filters
            if (filter.type === 'isBlank') {
                return value === undefined || value === null || value === '' || value === 0;
            }
            
            if (filter.type === 'isNotBlank') {
                return value !== undefined && value !== null && value !== '' && value !== 0;
            }
            
            if (value === undefined || value === null) return false;
            
            const strValue = String(value).toLowerCase();
            const numValue = parseFloat(value);
            const isNumeric = !isNaN(numValue);
            
            const filterValue1 = filter.value1.toLowerCase();
            const filterNum1 = parseFloat(filter.value1);
            const filterNum2 = parseFloat(filter.value2);
            
            switch (filter.type) {
                case 'contains':
                    return strValue.includes(filterValue1);
                    
                case 'equals':
                    if (isNumeric && !isNaN(filterNum1)) {
                        return numValue === filterNum1;
                    }
                    return strValue === filterValue1;
                    
                case 'notEquals':
                    if (isNumeric && !isNaN(filterNum1)) {
                        return numValue !== filterNum1;
                    }
                    return strValue !== filterValue1;
                    
                case 'greaterThan':
                    if (isNumeric && !isNaN(filterNum1)) {
                        return numValue > filterNum1;
                    }
                    return false;
                    
                case 'lessThan':
                    if (isNumeric && !isNaN(filterNum1)) {
                        return numValue < filterNum1;
                    }
                    return false;
                    
                case 'greaterOrEqual':
                    if (isNumeric && !isNaN(filterNum1)) {
                        return numValue >= filterNum1;
                    }
                    return false;
                    
                case 'lessOrEqual':
                    if (isNumeric && !isNaN(filterNum1)) {
                        return numValue <= filterNum1;
                    }
                    return false;
                    
                case 'between':
                    if (isNumeric && !isNaN(filterNum1) && !isNaN(filterNum2)) {
                        return numValue >= filterNum1 && numValue <= filterNum2;
                    }
                    return false;
                    
                default:
                    return true;
            }
        }

        function loadSavedFilters() {
            try {
                const savedStrategyFilters = localStorage.getItem('reportStrategyFilters');
                if (savedStrategyFilters) {
                    hiddenStrategies = new Set(JSON.parse(savedStrategyFilters));
                }
                
                const savedBrokerFilters = localStorage.getItem('reportBrokerStrategyFilters');
                if (savedBrokerFilters) {
                    hiddenBrokerStrategies = new Set(JSON.parse(savedBrokerFilters));
                    // Initialize manual filters with the same saved data
                    manualHiddenBrokerStrategies = new Set(JSON.parse(savedBrokerFilters));
                }
                
                const savedDateFilters = localStorage.getItem('reportDateFilters');
                if (savedDateFilters) {
                    hiddenDates = new Set(JSON.parse(savedDateFilters));
                }
                
                const savedCollapsedMonths = localStorage.getItem('reportCollapsedMonths');
                if (savedCollapsedMonths) {
                    collapsedMonths = new Set(JSON.parse(savedCollapsedMonths));
                }
                
                const savedRowsPerPage = localStorage.getItem('reportRowsPerPage');
                if (savedRowsPerPage) {
                    elements.rowsPerPage.value = savedRowsPerPage;
                }
                
                // Load saved "All Strategies" state
                const savedAllStrategiesStateJSON = localStorage.getItem('reportAllStrategiesState');
                if (savedAllStrategiesStateJSON) {
                    const state = JSON.parse(savedAllStrategiesStateJSON);
                    savedAllStrategiesState = {
                        selectedBrokerFilter: state.selectedBrokerFilter,
                        hiddenBrokerStrategies: new Set(state.hiddenBrokerStrategies || []),
                        manualHiddenBrokerStrategies: new Set(state.manualHiddenBrokerStrategies || [])
                    };
                    // Apply the saved state immediately since we start on "All Strategies"
                    if (state.selectedBrokerFilter !== undefined) {
                        selectedBrokerFilter = state.selectedBrokerFilter;
                    }
                    if (state.hiddenBrokerStrategies) {
                        hiddenBrokerStrategies = new Set(state.hiddenBrokerStrategies);
                    }
                    if (state.manualHiddenBrokerStrategies) {
                        manualHiddenBrokerStrategies = new Set(state.manualHiddenBrokerStrategies);
                    }
                }
            } catch (e) {
                hiddenStrategies = new Set();
                hiddenBrokerStrategies = new Set();
                manualHiddenBrokerStrategies = new Set();
                hiddenDates = new Set();
                collapsedMonths = new Set();
            }
        }

        function saveStrategyFilters() {
            try {
                localStorage.setItem('reportStrategyFilters', JSON.stringify(Array.from(hiddenStrategies)));
            } catch (e) {}
        }

        function saveBrokerFilters() {
            try {
                // Only save manual filters, not auto-filtered ones from strategy selection
                localStorage.setItem('reportBrokerStrategyFilters', JSON.stringify(Array.from(manualHiddenBrokerStrategies)));
            } catch (e) {}
        }

        function saveDateFilters() {
            try {
                localStorage.setItem('reportDateFilters', JSON.stringify(Array.from(hiddenDates)));
                localStorage.setItem('reportCollapsedMonths', JSON.stringify(Array.from(collapsedMonths)));
            } catch (e) {}
        }

        function saveRowsPerPage() {
            try {
                localStorage.setItem('reportRowsPerPage', elements.rowsPerPage.value);
            } catch (e) {}
        }

        function cleanupSavedFilters() {
            if (hiddenStrategies.size > 0 && strategies.length > 0) {
                const validHiddenStrategies = new Set();
                hiddenStrategies.forEach(strategy => {
                    if (strategies.includes(strategy)) {
                        validHiddenStrategies.add(strategy);
                    }
                });
                if (validHiddenStrategies.size !== hiddenStrategies.size) {
                    hiddenStrategies = validHiddenStrategies;
                    saveStrategyFilters();
                }
            }
            
            if (hiddenBrokerStrategies.size > 0 && brokerStrategies.length > 0) {
                const validHiddenBrokerStrategies = new Set();
                hiddenBrokerStrategies.forEach(strategy => {
                    if (brokerStrategies.includes(strategy)) {
                        validHiddenBrokerStrategies.add(strategy);
                    }
                });
                if (validHiddenBrokerStrategies.size !== hiddenBrokerStrategies.size) {
                    hiddenBrokerStrategies = validHiddenBrokerStrategies;
                    saveBrokerFilters();
                }
            }
            
            if (hiddenDates.size > 0 && Object.keys(dateStructure).length > 0) {
                const allValidDates = Object.values(dateStructure).flat();
                const validHiddenDates = new Set();
                hiddenDates.forEach(date => {
                    if (allValidDates.includes(date)) {
                        validHiddenDates.add(date);
                    }
                });
                if (validHiddenDates.size !== hiddenDates.size) {
                    hiddenDates = validHiddenDates;
                    saveDateFilters();
                }
            }
        }

        function initEventListeners() {
            loadSavedFilters();
            
            elements.dateFilterBtn.addEventListener('click', (e) => {
                e.stopPropagation();
                closeOtherDropdowns('date');
                elements.dateFilterDropdown.classList.toggle('active');
            });
            
            elements.strategyFilterBtn.addEventListener('click', (e) => {
                e.stopPropagation();
                closeOtherDropdowns('strategy');
                elements.strategyFilterDropdown.classList.toggle('active');
            });
            
            elements.brokerStrategyFilterBtn.addEventListener('click', (e) => {
                e.stopPropagation();
                closeOtherDropdowns('broker');
                elements.brokerStrategyFilterDropdown.classList.toggle('active');
            });
            
            elements.strategyNumberBtn.addEventListener('click', (e) => {
                e.stopPropagation();
                closeOtherDropdowns('strategyNumber');
                elements.strategyNumberDropdown.classList.toggle('active');
            });
            
            elements.selectAllDatesBtn.addEventListener('click', selectAllDates);
            elements.deselectAllDatesBtn.addEventListener('click', deselectAllDates);
            
            document.getElementById('todayBtn').addEventListener('click', filterToday);
            document.getElementById('yesterdayBtn').addEventListener('click', filterYesterday);
            document.getElementById('thisWeekBtn').addEventListener('click', filterThisWeek);
            document.getElementById('lastWeekBtn').addEventListener('click', filterLastWeek);
            document.getElementById('thisMonthBtn').addEventListener('click', filterThisMonth);
            document.getElementById('lastMonthBtn').addEventListener('click', filterLastMonth);
            
            elements.selectAllStrategiesBtn.addEventListener('click', selectAllStrategies);
            elements.deselectAllStrategiesBtn.addEventListener('click', deselectAllStrategies);
            elements.selectAllBrokerStrategiesBtn.addEventListener('click', selectAllBrokerStrategies);
            elements.deselectAllBrokerStrategiesBtn.addEventListener('click', deselectAllBrokerStrategies);
            
            elements.applyFiltersBtn.addEventListener('click', applyFilters);
            elements.resetFiltersBtn.addEventListener('click', resetFilters);
            elements.exportCSVBtn.addEventListener('click', exportToCSV);
            
            elements.symbolFilter.addEventListener('input', debounce(applyFilters, 300));
            
            elements.rowsPerPage.addEventListener('change', () => {
                saveRowsPerPage();
                currentPage = 1;
                renderTable();
            });
            
            elements.dateFilterDropdown.addEventListener('click', (e) => e.stopPropagation());
            elements.strategyFilterDropdown.addEventListener('click', (e) => e.stopPropagation());
            elements.brokerStrategyFilterDropdown.addEventListener('click', (e) => e.stopPropagation());
            elements.strategyNumberDropdown.addEventListener('click', (e) => e.stopPropagation());
            
            elements.filterPopupOverlay.addEventListener('click', (e) => {
                if (e.target === elements.filterPopupOverlay) {
                    closeFilterPopup();
                }
            });
            
            document.addEventListener('click', (e) => {
                if (!e.target.closest('.strategy-filter-container')) {
                    closeAllDropdowns();
                }
            });
            
            // Add mouseleave event to all filter containers for delayed closing
            document.querySelectorAll('.strategy-filter-container').forEach(container => {
                container.addEventListener('mouseleave', () => {
                    // Clear any existing timeout
                    if (dropdownCloseTimeout) {
                        clearTimeout(dropdownCloseTimeout);
                    }
                    // Set a new timeout to close dropdowns after 500ms
                    dropdownCloseTimeout = setTimeout(() => {
                        closeAllDropdowns();
                    }, 500);
                });
                
                container.addEventListener('mouseenter', () => {
                    // If cursor is back inside container, cancel the close timeout
                    if (dropdownCloseTimeout) {
                        clearTimeout(dropdownCloseTimeout);
                        dropdownCloseTimeout = null;
                    }
                });
            });
            
            elements.tableHeaders.addEventListener('click', async (e) => {
                if (e.target.closest('.filter-icon')) {
                    e.stopPropagation();
                    const icon = e.target.closest('.filter-icon');
                    const column = icon.dataset.filterColumn;
                    const stratName = icon.dataset.filterStrat;
                    const field = icon.dataset.filterField;
                    openFilterPopup(column, stratName, field, icon);
                    return;
                }
                
                const th = e.target.closest('th.sortable');
                if (th && th.dataset.column) {
                    await sortTable(th.dataset.column, th);
                } else if (th && th.dataset.stratname && th.dataset.field) {
                    await sortTableByStrategy(th.dataset.stratname, th.dataset.field, th);
                }
            });
            
            // Initialize sample strategy and data
            initializeSampleStrategy();
            
            // Initialize table headers with sample data
            buildTableHeaders('all');
            renderTable();
        }

        function closeOtherDropdowns(keepOpen) {
            if (keepOpen !== 'date') elements.dateFilterDropdown.classList.remove('active');
            if (keepOpen !== 'strategy') elements.strategyFilterDropdown.classList.remove('active');
            if (keepOpen !== 'broker') elements.brokerStrategyFilterDropdown.classList.remove('active');
            if (keepOpen !== 'strategyNumber') elements.strategyNumberDropdown.classList.remove('active');
        }

        function closeAllDropdowns() {
            elements.dateFilterDropdown.classList.remove('active');
            elements.strategyFilterDropdown.classList.remove('active');
            elements.brokerStrategyFilterDropdown.classList.remove('active');
            elements.strategyNumberDropdown.classList.remove('active');
        }

        function showLoading(text = 'Processing...', subtext = 'Please wait') {
            elements.loadingText.textContent = text;
            elements.loadingSubtext.textContent = subtext;
            elements.loadingOverlay.classList.add('active');
        }

        function hideLoading() {
            elements.loadingOverlay.classList.remove('active');
        }

        function debounce(func, wait) {
            let timeout;
            return function executedFunction(...args) {
                const later = () => {
                    clearTimeout(timeout);
                    func(...args);
                };
                clearTimeout(timeout);
                timeout = setTimeout(later, wait);
            };
        }

        function convertDateToShortFormat(dateStr) {
            if (!dateStr) return '';
            const parts = dateStr.split('/');
            if (parts.length !== 3) return dateStr;
            const year = parts[2];
            if (year.length === 4) {
                return `${parts[0]}/${parts[1]}/${year.slice(-2)}`;
            }
            return dateStr;
        }

        function parseDateString(dateStr) {
            const parts = dateStr.split('/');
            if (parts.length !== 3) return null;
            let year = parseInt(parts[2]);
            if (year < 100) {
                year += 2000;
            }
            return new Date(year, parseInt(parts[1]) - 1, parseInt(parts[0]));
        }

        function formatDateString(date) {
            const day = String(date.getDate()).padStart(2, '0');
            const month = String(date.getMonth() + 1).padStart(2, '0');
            const year = String(date.getFullYear()).slice(-2);
            return `${day}/${month}/${year}`;
        }

        function getDateRange(type) {
            const today = new Date();
            today.setHours(0, 0, 0, 0);
            
            let startDate, endDate;
            
            switch(type) {
                case 'today':
                    startDate = new Date(today);
                    endDate = new Date(today);
                    break;
                    
                case 'yesterday':
                    startDate = new Date(today);
                    startDate.setDate(startDate.getDate() - 1);
                    endDate = new Date(startDate);
                    break;
                    
                case 'thisWeek':
                    const dayOfWeek = today.getDay();
                    startDate = new Date(today);
                    startDate.setDate(startDate.getDate() - dayOfWeek);
                    endDate = new Date(today);
                    break;
                    
                case 'lastWeek':
                    const lastWeekEnd = new Date(today);
                    lastWeekEnd.setDate(lastWeekEnd.getDate() - today.getDay() - 1);
                    const lastWeekStart = new Date(lastWeekEnd);
                    lastWeekStart.setDate(lastWeekStart.getDate() - 6);
                    startDate = lastWeekStart;
                    endDate = lastWeekEnd;
                    break;
                    
                case 'thisMonth':
                    startDate = new Date(today.getFullYear(), today.getMonth(), 1);
                    endDate = new Date(today);
                    break;
                    
                case 'lastMonth':
                    startDate = new Date(today.getFullYear(), today.getMonth() - 1, 1);
                    endDate = new Date(today.getFullYear(), today.getMonth(), 0);
                    break;
            }
            
            return { startDate, endDate };
        }

        function filterDatesByRange(type) {
            const { startDate, endDate } = getDateRange(type);
            const allDatesInData = Object.values(dateStructure).flat();
            
            hiddenDates.clear();
            allDatesInData.forEach(dateStr => {
                const tradeDate = parseDateString(dateStr);
                if (tradeDate) {
                    if (tradeDate < startDate || tradeDate > endDate) {
                        hiddenDates.add(dateStr);
                    }
                }
            });
            
            saveDateFilters();
            updateDateFilterList();
            applyFilters();
        }

        function filterToday() { filterDatesByRange('today'); }
        function filterYesterday() { filterDatesByRange('yesterday'); }
        function filterThisWeek() { filterDatesByRange('thisWeek'); }
        function filterLastWeek() { filterDatesByRange('lastWeek'); }
        function filterThisMonth() { filterDatesByRange('thisMonth'); }
        function filterLastMonth() { filterDatesByRange('lastMonth'); }

        function buildDateStructure() {
            dateStructure = {};
            const monthNames = ['January', 'February', 'March', 'April', 'May', 'June', 
                               'July', 'August', 'September', 'October', 'November', 'December'];
            
            allTrades.forEach(trade => {
                if (!trade.date) return;
                const parts = trade.date.split('/');
                if (parts.length !== 3) return;
                const monthIndex = parseInt(parts[1]) - 1;
                const year = parts[2];
                const monthName = monthNames[monthIndex];
                const monthYear = `${monthName}-${year}`; // e.g., "January-25"
                if (!dateStructure[monthYear]) dateStructure[monthYear] = [];
                if (!dateStructure[monthYear].includes(trade.date)) {
                    dateStructure[monthYear].push(trade.date);
                }
            });
            
            Object.keys(dateStructure).forEach(monthYear => {
                dateStructure[monthYear].sort((a, b) => {
                    const dayA = parseInt(a.split('/')[0]);
                    const dayB = parseInt(b.split('/')[0]);
                    return dayA - dayB;
                });
                if (!collapsedMonths.has(monthYear)) {
                    collapsedMonths.add(monthYear);
                }
            });
        }

        function updateDateFilterList() {
            if (Object.keys(dateStructure).length === 0) {
                elements.dateFilterList.innerHTML = '<div style="padding: 14px; text-align: center; color: #9ca3af; font-size: 12px;">No dates</div>';
                updateDateFilterBadge();
                return;
            }
            
            const monthOrder = ['January', 'February', 'March', 'April', 'May', 'June', 
                               'July', 'August', 'September', 'October', 'November', 'December'];
            
            // Group month-years by year
            const yearGroups = {};
            Object.keys(dateStructure).forEach(monthYear => {
                const [monthName, year] = monthYear.split('-');
                const fullYear = year.length === 2 ? (parseInt(year) > 50 ? `19${year}` : `20${year}`) : year;
                if (!yearGroups[fullYear]) yearGroups[fullYear] = [];
                yearGroups[fullYear].push(monthYear);
            });
            
            // Sort years descending, months within year ascending
            const sortedYears = Object.keys(yearGroups).sort((a, b) => b.localeCompare(a));
            const sortedMonthYears = [];
            sortedYears.forEach(year => {
                yearGroups[year].sort((a, b) => {
                    const monthA = a.split('-')[0];
                    const monthB = b.split('-')[0];
                    return monthOrder.indexOf(monthA) - monthOrder.indexOf(monthB);
                });
                sortedMonthYears.push(...yearGroups[year]);
            });
            
            elements.dateFilterList.innerHTML = '';
            
            // Render with year headers
            sortedYears.forEach(year => {
                // Add year header
                const yearHeader = document.createElement('div');
                yearHeader.className = 'year-header';
                yearHeader.style.cssText = 'padding: 8px 14px; font-weight: 600; font-size: 11px; color: #1f2937; background: #f3f4f6; border-bottom: 1px solid #d1d5db; display: flex; align-items: center; gap: 8px; cursor: pointer;';
                
                const yearCheckbox = document.createElement('input');
                yearCheckbox.type = 'checkbox';
                yearCheckbox.className = 'strategy-filter-checkbox year-checkbox';
                yearCheckbox.id = `year_${year}`;
                yearCheckbox.style.cssText = 'width: 14px; height: 14px; cursor: pointer;';
                
                // Check if all months in year are selected
                const allYearMonthsSelected = yearGroups[year].every(monthYear => {
                    const dates = dateStructure[monthYear];
                    return dates.every(d => !hiddenDates.has(d));
                });
                yearCheckbox.checked = allYearMonthsSelected;
                
                yearCheckbox.onclick = (e) => {
                    e.stopPropagation();
                    const isChecked = e.target.checked;
                    yearGroups[year].forEach(monthYear => {
                        const dates = dateStructure[monthYear];
                        dates.forEach(date => {
                            if (isChecked) {
                                hiddenDates.delete(date);
                            } else {
                                hiddenDates.add(date);
                            }
                        });
                    });
                    saveDateFilters();
                    updateDateFilterList();
                    filterAndDisplayData();
                };
                
                const yearLabel = document.createElement('label');
                yearLabel.style.cssText = 'cursor: pointer; user-select: none; flex: 1;';
                yearLabel.textContent = year;
                yearLabel.onclick = () => yearCheckbox.click();
                
                yearHeader.appendChild(yearCheckbox);
                yearHeader.appendChild(yearLabel);
                elements.dateFilterList.appendChild(yearHeader);
                
                // Add months for this year
                yearGroups[year].forEach((monthYear) => {
                const dates = dateStructure[monthYear];
                const allDatesHidden = dates.every(d => hiddenDates.has(d));
                const someDatesHidden = dates.some(d => hiddenDates.has(d)) && !allDatesHidden;
                const isExpanded = !collapsedMonths.has(monthYear);
                
                const monthItem = document.createElement('div');
                monthItem.className = 'strategy-filter-item date-month-item';
                monthItem.style.paddingLeft = '28px'; // Indent months under year
                monthItem.onclick = () => toggleMonth(monthYear);
                
                const expandIcon = document.createElement('span');
                expandIcon.className = 'expand-icon' + (isExpanded ? ' expanded' : '');
                expandIcon.textContent = '▶';
                expandIcon.onclick = (e) => {
                    e.stopPropagation();
                    toggleMonth(monthYear);
                };
                
                const checkbox = document.createElement('input');
                checkbox.type = 'checkbox';
                checkbox.className = 'strategy-filter-checkbox';
                checkbox.id = `month_${monthYear}`;
                checkbox.checked = !allDatesHidden;
                if (someDatesHidden) checkbox.style.opacity = '0.5';
                checkbox.onclick = (e) => {
                    e.stopPropagation();
                    toggleMonthDatesRow(monthYear);
                };
                
                const label = document.createElement('label');
                label.className = 'strategy-filter-label';
                label.textContent = monthYear.split('-')[0]; // Show only month name
                
                monthItem.appendChild(expandIcon);
                monthItem.appendChild(checkbox);
                monthItem.appendChild(label);
                elements.dateFilterList.appendChild(monthItem);
                
                const childrenDiv = document.createElement('div');
                childrenDiv.className = 'month-children' + (isExpanded ? ' expanded' : '');
                
                dates.forEach((date) => {
                    const dateItem = document.createElement('div');
                    dateItem.className = 'strategy-filter-item date-day-item';
                    dateItem.onclick = () => {
                        const checkbox = document.getElementById(`date_${date.replace(/\//g, '_')}`);
                        if (checkbox) {
                            checkbox.checked = !checkbox.checked;
                            toggleDateRow(date);
                        }
                    };
                    
                    const dateCheckbox = document.createElement('input');
                    dateCheckbox.type = 'checkbox';
                    dateCheckbox.className = 'strategy-filter-checkbox';
                    dateCheckbox.id = `date_${date.replace(/\//g, '_')}`;
                    dateCheckbox.checked = !hiddenDates.has(date);
                    dateCheckbox.onclick = (e) => {
                        e.stopPropagation();
                        toggleDateRow(date);
                    };
                    
                    const dateLabel = document.createElement('label');
                    dateLabel.className = 'strategy-filter-label';
                    dateLabel.textContent = date;
                    
                    dateItem.appendChild(dateCheckbox);
                    dateItem.appendChild(dateLabel);
                    childrenDiv.appendChild(dateItem);
                });
                
                elements.dateFilterList.appendChild(childrenDiv);
            });
            });
            
            updateDateFilterBadge();
        }

        function toggleMonth(month) {
            if (collapsedMonths.has(month)) {
                collapsedMonths.delete(month);
            } else {
                collapsedMonths.add(month);
            }
            saveDateFilters();
            updateDateFilterList();
        }

        function toggleMonthDatesRow(month) {
            const checkbox = document.getElementById(`month_${month}`);
            if (!checkbox) return;
            
            // Don't manually toggle - browser already did it when checkbox was clicked
            // checkbox.checked = !checkbox.checked;
            
            const dates = dateStructure[month];
            if (!dates) return;
            
            if (checkbox.checked) {
                dates.forEach(d => hiddenDates.delete(d));
            } else {
                dates.forEach(d => hiddenDates.add(d));
            }
            
            saveDateFilters();
            updateDateFilterList();
            applyFilters();
        }

        function toggleDateRow(date) {
            const checkbox = document.getElementById(`date_${date.replace(/\//g, '_')}`);
            if (!checkbox) return;
            
            // Don't manually toggle - browser already did it when checkbox was clicked
            // checkbox.checked = !checkbox.checked;
            
            if (checkbox.checked) {
                hiddenDates.delete(date);
            } else {
                hiddenDates.add(date);
            }
            
            saveDateFilters();
            updateDateFilterList();
            applyFilters();
        }

        function selectAllDates() {
            hiddenDates.clear();
            collapsedMonths.clear();
            Object.keys(dateStructure).forEach(month => collapsedMonths.add(month));
            saveDateFilters();
            updateDateFilterList();
            applyFilters();
        }

        function deselectAllDates() {
            Object.values(dateStructure).forEach(dates => {
                dates.forEach(d => hiddenDates.add(d));
            });
            collapsedMonths.clear();
            Object.keys(dateStructure).forEach(month => collapsedMonths.add(month));
            saveDateFilters();
            updateDateFilterList();
            applyFilters();
        }

        function updateDateFilterBadge() {
            const totalDates = Object.values(dateStructure).flat().length;
            const hiddenCount = hiddenDates.size;
            
            if (hiddenCount > 0 && totalDates > 0) {
                elements.dateFilterBadge.textContent = hiddenCount;
                elements.dateFilterBadge.style.display = 'inline-block';
            } else {
                elements.dateFilterBadge.style.display = 'none';
            }
        }

        function updateStrategyFilterList() {
            if (!strategies.length) {
                elements.strategyFilterList.innerHTML = '<div style="padding: 14px; text-align: center; color: #9ca3af; font-size: 12px;">No strategies</div>';
                updateStrategyFilterBadge();
                return;
            }
            
            elements.strategyFilterList.innerHTML = '';
            
            strategies.forEach((strategy) => {
                const item = document.createElement('div');
                item.className = 'strategy-filter-item';
                item.onclick = () => {
                    const checkbox = document.getElementById(`strat_${strategy}`);
                    if (checkbox) {
                        checkbox.checked = !checkbox.checked;
                        toggleStrategyRow(strategy);
                    }
                };
                
                const checkbox = document.createElement('input');
                checkbox.type = 'checkbox';
                checkbox.className = 'strategy-filter-checkbox';
                checkbox.id = `strat_${strategy}`;
                checkbox.checked = !hiddenStrategies.has(strategy);
                checkbox.onclick = (e) => {
                    e.stopPropagation();
                    toggleStrategyRow(strategy);
                };
                
                const label = document.createElement('label');
                label.className = 'strategy-filter-label';
                label.textContent = strategy;
                
                item.appendChild(checkbox);
                item.appendChild(label);
                elements.strategyFilterList.appendChild(item);
            });
            
            updateStrategyFilterBadge();
        }

        function toggleStrategyRow(strategy) {
            const checkbox = document.getElementById(`strat_${strategy}`);
            if (!checkbox) return;
            
            // Don't manually toggle - browser already did it when checkbox was clicked
            // checkbox.checked = !checkbox.checked;
            
            if (checkbox.checked) {
                hiddenStrategies.delete(strategy);
            } else {
                hiddenStrategies.add(strategy);
            }
            
            saveStrategyFilters();
            updateStrategyFilterBadge();
            updateStrategyNumberList();
            setTimeout(() => applyFilters(), 10);
        }

        function selectAllStrategies() {
            hiddenStrategies.clear();
            saveStrategyFilters();
            updateStrategyFilterList();
            updateStrategyNumberList();
            setTimeout(() => applyFilters(), 10);
        }

        function deselectAllStrategies() {
            strategies.forEach(s => hiddenStrategies.add(s));
            saveStrategyFilters();
            updateStrategyFilterList();
            updateStrategyNumberList();
            setTimeout(() => applyFilters(), 10);
        }

        function updateStrategyFilterBadge() {
            const hiddenCount = hiddenStrategies.size;
            if (hiddenCount > 0 && strategies.length > 0) {
                elements.strategyFilterBadge.textContent = hiddenCount;
                elements.strategyFilterBadge.style.display = 'inline-block';
            } else {
                elements.strategyFilterBadge.style.display = 'none';
            }
        }

        function updateStrategyNumberList() {
            // Filter out hidden strategies
            const visibleStrategies = strategies.filter(s => !hiddenStrategies.has(s));
            
            if (!visibleStrategies.length) {
                elements.strategyNumberList.innerHTML = '<div style="padding: 14px; text-align: center; color: #9ca3af; font-size: 12px;">No visible strategies</div>';
                // Reset to "All Strategies" if current selection is hidden
                if (selectedStrategyNumber !== null) {
                    selectedStrategyNumber = null;
                    elements.strategyNumberText.textContent = 'All Strategies';
                }
                return;
            }
            
            // Reset to "All Strategies" if currently selected strategy is hidden
            if (selectedStrategyNumber !== null && hiddenStrategies.has(selectedStrategyNumber)) {
                selectedStrategyNumber = null;
                elements.strategyNumberText.textContent = 'All Strategies';
            }
            
            elements.strategyNumberList.innerHTML = '';
            
            // Add "All Strategies" option
            const allItem = document.createElement('div');
            allItem.className = 'strategy-filter-item';
            allItem.onclick = () => selectStrategyNumber(null);
            
            const allLabel = document.createElement('label');
            allLabel.className = 'strategy-filter-label';
            allLabel.textContent = 'All Strategies';
            allLabel.style.fontWeight = selectedStrategyNumber === null ? '600' : '400';
            allLabel.style.color = selectedStrategyNumber === null ? '#1e40af' : '#475569';
            
            allItem.appendChild(allLabel);
            elements.strategyNumberList.appendChild(allItem);
            
            // Add only visible (non-hidden) strategies
            visibleStrategies.forEach((strategy) => {
                const item = document.createElement('div');
                item.className = 'strategy-filter-item';
                item.onclick = () => selectStrategyNumber(strategy);
                
                const label = document.createElement('label');
                label.className = 'strategy-filter-label';
                label.textContent = strategy;
                label.style.fontWeight = selectedStrategyNumber === strategy ? '600' : '400';
                label.style.color = selectedStrategyNumber === strategy ? '#1e40af' : '#475569';
                
                item.appendChild(label);
                elements.strategyNumberList.appendChild(item);
            });
        }

        function selectStrategyNumber(strategy) {
            // If currently on "All Strategies" and switching to a specific strategy,
            // save the current broker filter state
            if (selectedStrategyNumber === null && strategy !== null) {
                savedAllStrategiesState = {
                    selectedBrokerFilter: selectedBrokerFilter,
                    hiddenBrokerStrategies: new Set(hiddenBrokerStrategies),
                    manualHiddenBrokerStrategies: new Set(manualHiddenBrokerStrategies)
                };
                // Save to localStorage
                try {
                    localStorage.setItem('reportAllStrategiesState', JSON.stringify({
                        selectedBrokerFilter: selectedBrokerFilter,
                        hiddenBrokerStrategies: Array.from(hiddenBrokerStrategies),
                        manualHiddenBrokerStrategies: Array.from(manualHiddenBrokerStrategies)
                    }));
                } catch (e) {}
            }
            
            // When switching to a specific strategy (not "All Strategies")
            if (strategy !== null) {
                // Reset to "All Broker" for the specific strategy
                selectedBrokerFilter = null;
                hiddenBrokerStrategies.clear();
                // Also clear manual hidden to ensure all brokers show for the selected strategy
                // (unless it's the first time selecting a strategy from "All Strategies")
                if (selectedStrategyNumber !== null) {
                    manualHiddenBrokerStrategies.clear();
                }
            }
            
            // Save original Buy/Sell state when first selecting a specific strategy
            if (selectedStrategyNumber === null && strategy !== null) {
                originalBuySellState = showBuySellColumns;
                originalTimeState = showTimeColumns;
                originalLotState = showLotColumns;
            }
            
            selectedStrategyNumber = strategy;
            
            if (strategy === null) {
                elements.strategyNumberText.textContent = 'All Strategies';
                
                // Restore saved "All Strategies" state
                if (savedAllStrategiesState) {
                    selectedBrokerFilter = savedAllStrategiesState.selectedBrokerFilter;
                    hiddenBrokerStrategies = new Set(savedAllStrategiesState.hiddenBrokerStrategies);
                    manualHiddenBrokerStrategies = new Set(savedAllStrategiesState.manualHiddenBrokerStrategies);
                } else {
                    // No saved state, just restore manual hidden ones
                    hiddenBrokerStrategies.clear();
                    manualHiddenBrokerStrategies.forEach(s => hiddenBrokerStrategies.add(s));
                }
                
                // Restore original Buy/Sell/Qty state
                showBuySellColumns = originalBuySellState;
                document.getElementById('buySellBtnText').textContent = showBuySellColumns ? 'Hide Buy/Sell/Qty' : 'Show Buy/Sell/Qty';
                
                // Restore original Time state
                showTimeColumns = originalTimeState;
                document.getElementById('timeBtnText').textContent = showTimeColumns ? 'Hide Time' : 'Show Time';
                
                // Restore original Lot state
                showLotColumns = originalLotState;
                document.getElementById('lotBtnText').textContent = showLotColumns ? 'Hide Lot' : 'Show Lot';
            } else {
                elements.strategyNumberText.textContent = strategy;
                // Show selected strategy from all brokers, but respect manual hide selections
                const strategyPattern = strategy.replace(/\s+/g, ''); // Remove spaces for matching (e.g., "PRO 4" -> "PRO4")
                // (hiddenBrokerStrategies already cleared at start)
                
                brokerStrategies.forEach(brokerStrat => {
                    const brokerStratClean = brokerStrat.replace(/\s+/g, '').replace(/_/g, '');
                    
                    // Extract the PRO number from both strings for exact matching
                    // Match patterns like "PRO4", "PRO 4", "4PRO", etc.
                    const strategyProMatch = strategyPattern.match(/PRO(\d+)/i);
                    const brokerProMatch = brokerStratClean.match(/PRO(\d+)/i);
                    
                    let matches = false;
                    if (strategyProMatch && brokerProMatch) {
                        // Both have PRO numbers - they must match exactly
                        matches = strategyProMatch[1] === brokerProMatch[1];
                    } else {
                        // Fallback to contains check for non-PRO patterns
                        matches = brokerStratClean.includes(strategyPattern);
                    }
                    
                    // Hide if: manually hidden by user OR doesn't match the selected strategy
                    if (manualHiddenBrokerStrategies.has(brokerStrat) || !matches) {
                        hiddenBrokerStrategies.add(brokerStrat);
                    }
                });
                
                // Temporarily enable Buy/Sell/Qty columns for specific strategy
                showBuySellColumns = true;
                document.getElementById('buySellBtnText').textContent = 'Hide Buy/Sell/Qty';
                
                // Temporarily enable Time columns for specific strategy
                showTimeColumns = true;
                document.getElementById('timeBtnText').textContent = 'Hide Time';
                
                // Temporarily enable Lot columns for specific strategy
                showLotColumns = true;
                document.getElementById('lotBtnText').textContent = 'Hide Lot';
            }
            
            saveBrokerFilters();
            updateBrokerStrategyFilterList();
            updateStrategyNumberList();
            closeAllDropdowns();
            setTimeout(() => applyFilters(), 10);
        }

        function updateBrokerStrategyFilterList() {
            if (!brokerStrategies.length) {
                elements.brokerStrategyFilterList.innerHTML = '<div style="padding: 14px; text-align: center; color: #9ca3af; font-size: 12px;">No broker strategies</div>';
                updateBrokerFilterBadge();
                return;
            }
            
            elements.brokerStrategyFilterList.innerHTML = '';
            
            // Filter broker strategies based on selected strategy
            let displayStrategies = brokerStrategies;
            if (selectedStrategyNumber !== null) {
                const strategyPattern = selectedStrategyNumber.replace(/\s+/g, '');
                displayStrategies = brokerStrategies.filter(brokerStrat => {
                    const brokerStratClean = brokerStrat.replace(/\s+/g, '').replace(/_/g, '');
                    
                    const strategyProMatch = strategyPattern.match(/PRO(\d+)/i);
                    const brokerProMatch = brokerStratClean.match(/PRO(\d+)/i);
                    
                    if (strategyProMatch && brokerProMatch) {
                        return strategyProMatch[1] === brokerProMatch[1];
                    } else {
                        return brokerStratClean.includes(strategyPattern);
                    }
                });
            }
            
            displayStrategies.forEach((strategy) => {
                const item = document.createElement('div');
                item.className = 'strategy-filter-item';
                item.onclick = () => {
                    const checkbox = document.getElementById(`broker_${strategy}`);
                    if (checkbox) {
                        checkbox.checked = !checkbox.checked;
                        toggleBrokerStrategyRow(strategy);
                    }
                };
                
                const checkbox = document.createElement('input');
                checkbox.type = 'checkbox';
                checkbox.className = 'strategy-filter-checkbox';
                checkbox.id = `broker_${strategy}`;
                checkbox.checked = !hiddenBrokerStrategies.has(strategy);
                checkbox.onclick = (e) => {
                    e.stopPropagation();
                    toggleBrokerStrategyRow(strategy);
                };
                
                const label = document.createElement('label');
                label.className = 'strategy-filter-label';
                label.textContent = formatStrategyName(strategy);
                
                item.appendChild(checkbox);
                item.appendChild(label);
                elements.brokerStrategyFilterList.appendChild(item);
            });
            
            updateBrokerFilterBadge();
        }

        function toggleBrokerStrategyRow(strategy) {
            const checkbox = document.getElementById(`broker_${strategy}`);
            if (!checkbox) return;
            
            // Don't manually toggle - browser already did it when checkbox was clicked
            // checkbox.checked = !checkbox.checked;
            
            if (checkbox.checked) {
                hiddenBrokerStrategies.delete(strategy);
                manualHiddenBrokerStrategies.delete(strategy); // Remove from manual hide
            } else {
                hiddenBrokerStrategies.add(strategy);
                manualHiddenBrokerStrategies.add(strategy); // Add to manual hide
            }
            
            saveBrokerFilters();
            updateBrokerFilterBadge();
            setTimeout(() => applyFilters(), 10);
        }

        function selectAllBrokerStrategies() {
            hiddenBrokerStrategies.clear();
            manualHiddenBrokerStrategies.clear(); // Clear manual filters too
            saveBrokerFilters();
            updateBrokerStrategyFilterList();
            setTimeout(() => applyFilters(), 10);
        }

        function deselectAllBrokerStrategies() {
            brokerStrategies.forEach(s => {
                hiddenBrokerStrategies.add(s);
                manualHiddenBrokerStrategies.add(s); // Track as manual hide
            });
            saveBrokerFilters();
            updateBrokerStrategyFilterList();
            setTimeout(() => applyFilters(), 10);
        }

        function createDynamicBrokerButtons() {
            const container = document.getElementById('brokerButtonsContainer');
            if (!container) return;
            
            // Clear existing buttons
            container.innerHTML = '';
            
            // Create "All" button
            const allBtn = document.createElement('button');
            allBtn.className = 'quick-date-btn';
            allBtn.textContent = 'All Broker';
            allBtn.onclick = showAllBrokers;
            container.appendChild(allBtn);
            
            // Create dynamic broker buttons (ACA, CEA, ZEA, etc.)
            uniqueBrokers.forEach(broker => {
                const btn = document.createElement('button');
                btn.className = 'quick-date-btn';
                btn.textContent = broker;
                btn.onclick = () => showSpecificBroker(broker);
                container.appendChild(btn);
            });
        }

        function showSpecificBroker(brokerPrefix, skipSave = false) {
            // Set broker selection
            selectedBrokerFilter = brokerPrefix;
            
            // Show only specified broker columns (temporarily)
            hiddenBrokerStrategies.clear();
            
            brokerStrategies.forEach(brokerStrat => {
                let shouldHide = false;
                
                // First, hide if not the specified broker
                if (!brokerStrat.startsWith(brokerPrefix)) {
                    shouldHide = true;
                }
                
                // If a specific strategy is selected, also apply that filter
                if (!shouldHide && selectedStrategyNumber !== null) {
                    const strategyPattern = selectedStrategyNumber.replace(/\s+/g, '');
                    const brokerStratClean = brokerStrat.replace(/\s+/g, '').replace(/_/g, '');
                    
                    // Extract PRO numbers for exact matching
                    const strategyProMatch = strategyPattern.match(/PRO(\d+)/i);
                    const brokerProMatch = brokerStratClean.match(/PRO(\d+)/i);
                    
                    let matches = false;
                    if (strategyProMatch && brokerProMatch) {
                        matches = strategyProMatch[1] === brokerProMatch[1];
                    } else {
                        matches = brokerStratClean.includes(strategyPattern);
                    }
                    
                    if (!matches) {
                        shouldHide = true;
                    }
                }
                
                if (shouldHide) {
                    hiddenBrokerStrategies.add(brokerStrat);
                    // Mark as manual hide to prevent auto-hide from overriding
                    manualHiddenBrokerStrategies.add(brokerStrat);
                } else {
                    // Mark visible ones as manual show to prevent auto-hide
                    manualHiddenBrokerStrategies.delete(brokerStrat);
                }
            });
            
            // Don't save - this is a temporary view
            updateBrokerStrategyFilterList();
            setTimeout(() => applyFilters(), 10);
        }

        function showAllBrokers(skipSave = false) {
            // Set broker selection
            selectedBrokerFilter = null; // null means "All Broker"
            
            // Show all broker columns (temporarily, without clearing saved manual filters)
            hiddenBrokerStrategies.clear();
            manualHiddenBrokerStrategies.clear(); // Clear manual overrides so auto-hide can work
            
            // If a specific strategy is selected, apply that filter first
            if (selectedStrategyNumber !== null) {
                const strategyPattern = selectedStrategyNumber.replace(/\s+/g, '');
                
                brokerStrategies.forEach(brokerStrat => {
                    const brokerStratClean = brokerStrat.replace(/\s+/g, '').replace(/_/g, '');
                    
                    // Extract PRO numbers for exact matching
                    const strategyProMatch = strategyPattern.match(/PRO(\d+)/i);
                    const brokerProMatch = brokerStratClean.match(/PRO(\d+)/i);
                    
                    let matches = false;
                    if (strategyProMatch && brokerProMatch) {
                        matches = strategyProMatch[1] === brokerProMatch[1];
                    } else {
                        matches = brokerStratClean.includes(strategyPattern);
                    }
                    
                    if (!matches) {
                        hiddenBrokerStrategies.add(brokerStrat);
                        manualHiddenBrokerStrategies.add(brokerStrat);
                    }
                });
            }
            
            // Don't save - this is a temporary view
            updateBrokerStrategyFilterList();
            setTimeout(() => applyFilters(), 10);
        }

        function updateBrokerFilterBadge() {
            const hiddenCount = hiddenBrokerStrategies.size;
            if (hiddenCount > 0 && brokerStrategies.length > 0) {
                elements.brokerFilterBadge.textContent = hiddenCount;
                elements.brokerFilterBadge.style.display = 'inline-block';
            } else {
                elements.brokerFilterBadge.style.display = 'none';
            }
        }

        function formatStrategyName(strategyName) {
            if (!strategyName) return strategyName;
            // First remove underscores
            let formatted = strategyName.replace(/_/g, ' ');
            // Extract broker code and add space before PRO (e.g., "ACAPRO 4" -> "ACA PRO 4")
            const match = formatted.match(/^(.+?)PRO\s*(\d+)$/);
            if (match) {
                return `${match[1]} PRO ${match[2]}`;
            }
            // Fallback for other formats
            return formatted.replace(/(\d)(PRO)/g, '$1 $2');
        }

        function extractBrokerStrategies() {
            const strategiesSet = new Set();
            const mainStrategiesSet = new Set();
            const brokersSet = new Set();
            
            allTrades.forEach(trade => {
                if (trade.strategy) mainStrategiesSet.add(trade.strategy);
                if (trade.strategyDetails) {
                    Object.keys(trade.strategyDetails).forEach(stratName => {
                        if (!stratName.startsWith('A.PRO')) {
                            strategiesSet.add(stratName);
                            // Extract broker code dynamically (e.g., ACAPRO 1 -> ACA, CEAPRO 2 -> CEA)
                            const cleanName = stratName.replace(/\s+/g, '');
                            const brokerMatch = cleanName.match(/^(.+?)PRO/);
                            if (brokerMatch) {
                                brokersSet.add(brokerMatch[1]);
                            }
                        }
                    });
                }
            });
            
            brokerStrategies = Array.from(strategiesSet).sort((a, b) => {
                // Extract broker code and PRO number for sorting
                const cleanA = a.replace(/\s+/g, '');
                const cleanB = b.replace(/\s+/g, '');
                const aBrokerMatch = cleanA.match(/^(.+?)PRO/);
                const bBrokerMatch = cleanB.match(/^(.+?)PRO/);
                const aBroker = aBrokerMatch ? aBrokerMatch[1] : '';
                const bBroker = bBrokerMatch ? bBrokerMatch[1] : '';
                const aPro = a.match(/PRO\s*(\d+)/i)?.[1] || '0';
                const bPro = b.match(/PRO\s*(\d+)/i)?.[1] || '0';
                if (aBroker !== bBroker) return aBroker.localeCompare(bBroker);
                return parseInt(aPro) - parseInt(bPro);
            });
            
            // Extract and sort unique brokers
            uniqueBrokers = Array.from(brokersSet).sort();
            
            strategies = Array.from(mainStrategiesSet).sort();
            
            // Auto-hide strategies with no values
            autoHideEmptyStrategies();
            
            updateBrokerStrategyFilterList();
            updateStrategyFilterList();
            updateStrategyNumberList();
            createDynamicBrokerButtons(); // Create dynamic broker buttons
            
            // Default to "All Broker" (no saved selection)
            selectedBrokerFilter = null;
            
            buildTableHeaders('all');
        }

        // Function to automatically hide strategies with no values
        function autoHideEmptyStrategies(tradesToCheck = null) {
            // Use provided trades or default to allTrades
            const trades = tradesToCheck !== null ? tradesToCheck : allTrades;
            
            const strategyTotals = {};
            
            // Initialize totals for all broker strategies
            brokerStrategies.forEach(strategy => {
                strategyTotals[strategy] = {
                    pnl: 0,
                    dpnl: 0,
                    dbuy: 0,
                    dsell: 0,
                    hasAnyValue: false
                };
            });
            
            // Calculate totals for each strategy across trades
            trades.forEach(trade => {
                if (trade.strategyDetails) {
                    Object.entries(trade.strategyDetails).forEach(([stratName, details]) => {
                        if (strategyTotals[stratName]) {
                            // Check PNL
                            const pnl = details.pnl || 0;
                            strategyTotals[stratName].pnl += Math.abs(pnl);
                            if (pnl !== 0) strategyTotals[stratName].hasAnyValue = true;
                            
                            // Check DPNL
                            const dpnl = details.dpnl || 0;
                            strategyTotals[stratName].dpnl += Math.abs(dpnl);
                            if (dpnl !== 0) strategyTotals[stratName].hasAnyValue = true;
                            
                            // Check DBUY
                            const dbuy = details.dbuy || 0;
                            strategyTotals[stratName].dbuy += Math.abs(dbuy);
                            if (dbuy !== 0) strategyTotals[stratName].hasAnyValue = true;
                            
                            // Check DSELL
                            const dsell = details.dsell || 0;
                            strategyTotals[stratName].dsell += Math.abs(dsell);
                            if (dsell !== 0) strategyTotals[stratName].hasAnyValue = true;
                        }
                    });
                }
            });
            
            // Auto-hide strategies with no values
            // Only auto-hide if not manually hidden by user
            brokerStrategies.forEach(strategy => {
                const totals = strategyTotals[strategy];
                // Hide if no values at all (and it's not a manual hide)
                if (!totals.hasAnyValue && !manualHiddenBrokerStrategies.has(strategy)) {
                    hiddenBrokerStrategies.add(strategy);
                } else if (totals.hasAnyValue && !manualHiddenBrokerStrategies.has(strategy)) {
                    // Show if it has any value (and it's not manually hidden)
                    hiddenBrokerStrategies.delete(strategy);
                }
            });
        }

        async function applyFilters() {
            const symbolFilter = elements.symbolFilter.value.toUpperCase().trim();
            let tempTrades = [...allTrades];
            
            if (hiddenDates.size > 0) {
                tempTrades = tempTrades.filter(trade => !hiddenDates.has(trade.date));
            }
            
            const visibleStrategies = strategies.filter(s => !hiddenStrategies.has(s));
            if (strategies.length && visibleStrategies.length < strategies.length) {
                tempTrades = tempTrades.filter(trade => visibleStrategies.includes(trade.strategy));
            }
            
            // Apply strategy number filter
            if (selectedStrategyNumber !== null) {
                tempTrades = tempTrades.filter(trade => trade.strategy === selectedStrategyNumber);
            }
            
            if (symbolFilter) {
                tempTrades = tempTrades.filter(trade => trade.symbol?.toUpperCase().includes(symbolFilter));
            }
            
            // Apply column filters
            Object.keys(columnFilters).forEach(filterKey => {
                const filter = columnFilters[filterKey];
                
                tempTrades = tempTrades.filter(trade => {
                    let value;
                    
                    if (filterKey.includes('_')) {
                        const [stratName, field] = filterKey.split('_');
                        value = trade.strategyDetails?.[stratName]?.[field];
                    } else {
                        value = trade[filterKey];
                    }
                    
                    return testFilter(value, filter);
                });
            });
            
            // Auto-hide strategies with no values based on filtered data
            autoHideEmptyStrategies(tempTrades);
            
            const visibleBrokerStrategies = brokerStrategies.filter(s => !hiddenBrokerStrategies.has(s));
            
            filteredTrades = tempTrades;
            
            const showAll = !brokerStrategies.length || visibleBrokerStrategies.length === brokerStrategies.length;
            buildTableHeaders(showAll ? 'all' : visibleBrokerStrategies);
            currentPage = 1;
            renderTable();
        }

        async function resetFilters() {
            elements.symbolFilter.value = '';
            elements.rowsPerPage.value = '15';
            hiddenStrategies.clear();
            hiddenBrokerStrategies.clear();
            manualHiddenBrokerStrategies.clear(); // Clear manual broker filters
            hiddenDates.clear();
            collapsedMonths.clear();
            Object.keys(dateStructure).forEach(month => collapsedMonths.add(month));
            columnFilters = {};
            currentPage = 1;
            selectedStrategyNumber = null;
            elements.strategyNumberText.textContent = 'All Strategies';
            
            try {
                localStorage.removeItem('reportStrategyFilters');
                localStorage.removeItem('reportBrokerStrategyFilters');
                localStorage.removeItem('reportDateFilters');
                localStorage.removeItem('reportCollapsedMonths');
                localStorage.removeItem('reportRowsPerPage');
                localStorage.removeItem('reportAllStrategiesState');
            } catch (e) {}
            
            // Reset broker selection to default (All Broker)
            selectedBrokerFilter = null;
            savedAllStrategiesState = null;
            
            // Save the cleared date filters immediately
            saveDateFilters();
            saveStrategyFilters();
            saveBrokerFilters();
            
            // Auto-hide empty strategies after reset
            autoHideEmptyStrategies();
            
            updateStrategyFilterList();
            updateBrokerStrategyFilterList();
            updateStrategyNumberList();
            updateDateFilterList();
            sortColumn = null;
            sortDirection = 'asc';
            document.querySelectorAll('.report-table th').forEach(th => {
                th.classList.remove('sorted-asc', 'sorted-desc');
            });
            buildTableHeaders('all');
            await applyFilters();
        }

        function buildTableHeaders(filterBrokerStrategy = 'all') {
            let displayStrategies;
            if (filterBrokerStrategy === 'all') {
                displayStrategies = brokerStrategies;
            } else if (Array.isArray(filterBrokerStrategy)) {
                displayStrategies = filterBrokerStrategy;
            } else {
                displayStrategies = [filterBrokerStrategy];
            }
            
            const colors = ['#fef5f5', '#fefaf5', '#fefef5', '#f5fef8', '#f5f8fe', '#f8f5fe'];
            const colsPerStrategy = (showLotColumns ? 2 : 0) + 4 + (showTimeColumns ? 2 : 0) + (showBuySellColumns ? 3 : 0);
            
            const totals = { profit: 0 };
            const brokerTotals = {};
            displayStrategies.forEach(stratName => {
                brokerTotals[stratName] = { pnl: 0, dpnl: 0, dbuy: 0, dsell: 0, lot_pnl: 0 };
            });
            
            filteredTrades.forEach(trade => {
                totals.profit += trade.profit || 0;
                displayStrategies.forEach(stratName => {
                    const details = trade.strategyDetails?.[stratName] || {};
                    const pnl = details.pnl || 0;
                    const lot_size = details.lot;
                    const lot_pnl = (lot_size && lot_size !== 0) ? (pnl / lot_size) : 0;
                    brokerTotals[stratName].pnl += pnl;
                    brokerTotals[stratName].dpnl += details.dpnl || 0;
                    brokerTotals[stratName].dbuy += details.dbuy || 0;
                    brokerTotals[stratName].dsell += details.dsell || 0;
                    brokerTotals[stratName].lot_pnl += lot_pnl;
                });
            });
            
            let totalsRow = `<tr class="totals-row">
                <th colspan="5" style="text-align: left; font-weight: 600; border-right: none;">FILTERED TOTALS</th>
                <th class="number-col time-column${showTimeColumns ? ' visible' : ''}" style="border-right: none;"></th>
                <th class="number-col time-column${showTimeColumns ? ' visible' : ''}" style="border-right: none;"></th>
                <th class="number-col" style="border-right: none;"></th>
                <th class="number-col" style="border-right: none;"></th>
                <th class="number-col" style="border-right: none;"></th>
                <th class="number-col ${totals.profit >= 0 ? 'positive' : 'negative'}">₹${totals.profit.toLocaleString('en-IN', {maximumFractionDigits: 0})}</th>`;
            
            displayStrategies.forEach((stratName, index) => {
                const bt = brokerTotals[stratName];
                const firstColStyle = index === 0 ? `style="border-left: 1px solid #e5e7eb;"` : `style=""`;
                const groupStyle = `style=""`;
                const lastColStyle = `style="border-right: 1px solid #d1d5db;"`;
                
                totalsRow += `<th class="number-col ${bt.lot_pnl >= 0 ? 'positive' : 'negative'} lot-column${showLotColumns ? ' visible' : ''}" ${firstColStyle}>${bt.lot_pnl !== 0 ? bt.lot_pnl.toLocaleString('en-IN', {maximumFractionDigits: 0}) : ''}</th>`;
                totalsRow += `<th class="number-col ${bt.pnl >= 0 ? 'positive' : 'negative'}" ${groupStyle}>${bt.pnl.toLocaleString('en-IN', {maximumFractionDigits: 0})}</th>`;
                totalsRow += `<th class="number-col ${bt.dpnl >= 0 ? 'positive' : 'negative'}" ${groupStyle}>${bt.dpnl.toLocaleString('en-IN', {maximumFractionDigits: 0})}</th>`;
                totalsRow += `<th class="number-col ${bt.dbuy >= 0 ? 'positive' : 'negative'}" ${groupStyle}>${bt.dbuy.toLocaleString('en-IN', {maximumFractionDigits: 0})}</th>`;
                totalsRow += `<th class="number-col ${bt.dsell >= 0 ? 'positive' : 'negative'}" ${groupStyle}>${bt.dsell.toLocaleString('en-IN', {maximumFractionDigits: 0})}</th>`;
                totalsRow += `<th class="number-col time-column${showTimeColumns ? ' visible' : ''}" ${groupStyle}></th>`;
                totalsRow += `<th class="number-col time-column${showTimeColumns ? ' visible' : ''}" ${groupStyle}></th>`;
                totalsRow += `<th class="number-col buy-sell-column${showBuySellColumns ? ' visible' : ''}" ${groupStyle}></th>`;
                totalsRow += `<th class="number-col lot-column${showLotColumns ? ' visible' : ''}" ${groupStyle}></th>`;
                totalsRow += `<th class="number-col buy-sell-column${showBuySellColumns ? ' visible' : ''}" ${groupStyle}></th>`;
                totalsRow += `<th class="number-col buy-sell-column${showBuySellColumns ? ' visible' : ''}" ${lastColStyle}></th>`;
            });
            totalsRow += '</tr>';
            
            const mainColumns = ['sno', 'date', 'strategy', 'trade', 'symbol', 'a_entime', 'a_extime', 'qty', 'entry', 'exit', 'profit'];
            const columnLabels = { sno: 'S.No', date: 'Date', strategy: 'STG', trade: 'Trade', symbol: 'Symbol', a_entime: 'ENTIME', a_extime: 'EXTIME', qty: 'Qty', entry: 'Entry', exit: 'Exit', profit: 'Profit' };
            
            let headerRow1 = '<tr class="header-row-1">';
            mainColumns.forEach(col => {
                const hasFilter = columnFilters[col];
                const filterIcon = hasFilter ? ' active' : '';
                const isNumber = ['qty', 'entry', 'exit', 'profit'].includes(col);
                const isTime = ['a_entime', 'a_extime'].includes(col);
                const isPrice = ['qty', 'entry', 'exit'].includes(col);
                const timeClass = isTime ? ` time-column${showTimeColumns ? ' visible' : ''}` : '';
                const priceClass = isPrice ? ' price-column' : '';
                headerRow1 += `<th rowspan="2" class="sortable${isNumber ? ' number-col' : ''}${timeClass}${priceClass}" data-column="${col}">
                    ${columnLabels[col]}
                    <span class="filter-icon${filterIcon}" data-filter-column="${col}">🔽</span>
                </th>`;
            });
            
            displayStrategies.forEach((stratName, index) => {
                const displayName = formatStrategyName(stratName);
                const bgColor = colors[index % colors.length];
                const borderStyle = 'border-right: 1px solid #d1d5db; border-left: ' + (index === 0 ? '1px solid #e5e7eb;' : '0;');
                headerRow1 += `<th colspan="${colsPerStrategy}" class="number-col" style="background: linear-gradient(to bottom, ${bgColor} 0%, ${adjustColor(bgColor, -3)} 100%); ${borderStyle}">${displayName}</th>`;
            });
            headerRow1 += '</tr>';
            
            let headerRow2 = '<tr class="header-row-2">';
            displayStrategies.forEach((stratName, index) => {
                const bgColor = colors[index % colors.length];
                const baseBg = `background: linear-gradient(to bottom, ${adjustColor(bgColor, -3)} 0%, ${adjustColor(bgColor, -6)} 100%);`;
                const firstColBorder = index === 0 ? 'border-left: 1px solid #e5e7eb;' : '';
                const lastColBorder = 'border-right: 1px solid #d1d5db;';
                
                const fields = ['lot_pnl', 'pnl', 'dpnl', 'dbuy', 'dsell', 'entime', 'extime', 'qty', 'lot_size', 'enprc', 'exprc'];
                const fieldLabels = { lot_pnl: 'LOT PNL', pnl: 'PNL', dpnl: 'DPNL', dbuy: 'DBUY', dsell: 'DSELL', entime: 'ENTIME', extime: 'EXTIME', qty: 'QTY', lot_size: 'LOT SIZE', enprc: 'ENPRC', exprc: 'EXPRC' };
                
                fields.forEach((field, fIdx) => {
                    const filterKey = `${stratName}_${field}`;
                    const hasFilter = columnFilters[filterKey];
                    const filterIcon = hasFilter ? ' active' : '';
                    const isBuySell = ['qty', 'enprc', 'exprc'].includes(field);
                    const isTime = ['entime', 'extime'].includes(field);
                    const isLot = ['lot_size', 'lot_pnl'].includes(field);
                    const isPrice = ['qty', 'enprc', 'exprc'].includes(field);
                    const border = fIdx === 0 ? firstColBorder : (fIdx === fields.length - 1 ? lastColBorder : '');
                    const buySellClass = isBuySell ? ` buy-sell-column${showBuySellColumns ? ' visible' : ''}` : '';
                    const timeClass = isTime ? ` time-column${showTimeColumns ? ' visible' : ''}` : '';
                    const lotClass = isLot ? ` lot-column${showLotColumns ? ' visible' : ''}` : '';
                    const priceClass = isPrice ? ' price-column' : '';
                    
                    headerRow2 += `<th class="number-col sortable${buySellClass}${timeClass}${lotClass}${priceClass}" data-stratname="${stratName}" data-field="${field}" style="${baseBg} ${border}">
                        ${fieldLabels[field]}
                        <span class="filter-icon${filterIcon}" data-filter-strat="${stratName}" data-filter-field="${field}">🔽</span>
                    </th>`;
                });
            });
            headerRow2 += '</tr>';
            
            elements.tableHeaders.innerHTML = totalsRow + headerRow1 + headerRow2;
        }

        function adjustColor(color, percent) {
            const num = parseInt(color.replace('#', ''), 16);
            const amt = Math.round(2.55 * percent);
            const R = (num >> 16) + amt;
            const G = (num >> 8 & 0x00FF) + amt;
            const B = (num & 0x0000FF) + amt;
            return '#' + (0x1000000 + (R < 255 ? R < 1 ? 0 : R : 255) * 0x10000 +
                (G < 255 ? G < 1 ? 0 : G : 255) * 0x100 +
                (B < 255 ? B < 1 ? 0 : B : 255))
                .toString(16).slice(1);
        }

        function createTableRow(trade, displayStrategies) {
            const profit = trade.profit || 0;
            const profitClass = profit > 0 ? 'positive' : profit < 0 ? 'negative' : '';
            const colors = ['#fef5f5', '#fefaf5', '#fefef5', '#f5fef8', '#f5f8fe', '#f8f5fe'];
            
            let row = `<tr>
                <td>${trade.sno || ''}</td>
                <td>${convertDateToShortFormat(trade.date)}</td>
                <td>${trade.strategy || ''}</td>
                <td>${(trade.trade || '').toUpperCase()}</td>
                <td>${trade.symbol || ''}</td>
		<td class="number-col time-column${showTimeColumns ? ' visible' : ''}">${trade.a_entime || ''}</td>
		<td class="number-col time-column${showTimeColumns ? ' visible' : ''}">${trade.a_extime || ''}</td>
                <td class="number-col price-column">${trade.qty || ''}</td>
                <td class="number-col price-column">${trade.entry ? trade.entry.toFixed(2) : ''}</td>
                <td class="number-col price-column">${trade.exit ? trade.exit.toFixed(2) : ''}</td>
                <td class="number-col ${profitClass}">${profit !== 0 ? `₹${profit.toLocaleString('en-IN', {maximumFractionDigits: 0})}` : ''}</td>`;
            
            displayStrategies.forEach((stratName, index) => {
                const details = trade.strategyDetails?.[stratName] || {};
                const pnl = details.pnl || 0;
                const dpnl = details.dpnl || 0;
                const buy = details.buy || 0;
                const sell = details.sell || 0;
                const dbuy = details.dbuy || 0;
                const dsell = details.dsell || 0;
                const entime = details.entime || '';
                const extime = details.extime || '';
                const qty = details.qty || 0;
                const lot_size = details.lot !== undefined && details.lot !== null ? details.lot : '';
                const lot_pnl = (lot_size && lot_size !== 0) ? (pnl / lot_size) : 0;
                
                // Calculate ENPRC and EXPRC based on trade type
                let enprc = 0;
                let exprc = 0;
                if (trade.trade) {
                    const tradeType = trade.trade.toString().toUpperCase();
                    if (tradeType === 'SHORT') {
                        // Short trade: ENPRC = sell, EXPRC = buy
                        enprc = sell;
                        exprc = buy;
                    } else if (tradeType === 'LONG') {
                        // Long trade: ENPRC = buy, EXPRC = sell
                        enprc = buy;
                        exprc = sell;
                    }
                }
                
                const bgColor = colors[index % colors.length];
                const pnlClass = pnl > 0 ? 'positive' : pnl < 0 ? 'negative' : '';
                const dpnlClass = dpnl > 0 ? 'positive' : dpnl < 0 ? 'negative' : '';
                const dbuyClass = dbuy > 0 ? 'positive' : dbuy < 0 ? 'negative' : '';
                const dsellClass = dsell > 0 ? 'positive' : dsell < 0 ? 'negative' : '';
                const lot_pnlClass = lot_pnl > 0 ? 'positive' : lot_pnl < 0 ? 'negative' : '';
                const firstColBorder = index === 0 ? 'border-left: 1px solid #e5e7eb;' : '';
                const groupBorder = `style="background-color: ${bgColor}; ${firstColBorder}"`;
                const groupBorderNoFirst = `style="background-color: ${bgColor};"`;
                const lastColBorder = 'style="background-color: ' + bgColor + '; border-right: 1px solid #d1d5db;"';
                
                row += `<td class="number-col ${lot_pnlClass} lot-column${showLotColumns ? ' visible' : ''}" ${groupBorder}>${lot_pnl !== 0 ? lot_pnl.toLocaleString('en-IN', {maximumFractionDigits: 0}) : ''}</td>`;
                row += `<td class="number-col ${pnlClass}" ${groupBorderNoFirst}>${pnl !== 0 ? pnl.toLocaleString('en-IN', {maximumFractionDigits: 0}) : ''}</td>`;
                row += `<td class="number-col ${dpnlClass}" ${groupBorderNoFirst}>${dpnl !== 0 ? dpnl.toLocaleString('en-IN', {maximumFractionDigits: 0}) : ''}</td>`;
                row += `<td class="number-col ${dbuyClass}" ${groupBorderNoFirst}>${dbuy !== 0 ? dbuy.toLocaleString('en-IN', {maximumFractionDigits: 0}) : ''}</td>`;
                row += `<td class="number-col ${dsellClass}" ${groupBorderNoFirst}>${dsell !== 0 ? dsell.toLocaleString('en-IN', {maximumFractionDigits: 0}) : ''}</td>`;
                row += `<td class="number-col time-column${showTimeColumns ? ' visible' : ''}" ${groupBorderNoFirst}>${entime}</td>`;
                row += `<td class="number-col time-column${showTimeColumns ? ' visible' : ''}" ${groupBorderNoFirst}>${extime}</td>`;
                row += `<td class="number-col price-column buy-sell-column${showBuySellColumns ? ' visible' : ''}" ${groupBorderNoFirst}>${qty !== 0 ? qty : ''}</td>`;
                row += `<td class="number-col price-column lot-column${showLotColumns ? ' visible' : ''}" ${groupBorderNoFirst}>${lot_size && lot_size !== 0 ? parseFloat(lot_size).toFixed(1) : ''}</td>`;
                row += `<td class="number-col price-column buy-sell-column${showBuySellColumns ? ' visible' : ''}" ${groupBorderNoFirst}>${enprc !== 0 ? enprc.toFixed(2) : ''}</td>`;
                row += `<td class="number-col price-column buy-sell-column${showBuySellColumns ? ' visible' : ''}" ${lastColBorder}>${exprc !== 0 ? exprc.toFixed(2) : ''}</td>`;
            });
            
            return row + '</tr>';
        }

        function renderTable() {
            const visibleBrokerStrategies = brokerStrategies.filter(s => !hiddenBrokerStrategies.has(s));
            const displayStrategies = visibleBrokerStrategies.length === brokerStrategies.length ? 
                brokerStrategies : visibleBrokerStrategies;
            
            // Toggle single-strategy class for expanded column widths
            const tableWrapper = document.querySelector('.table-wrapper');
            if (visibleBrokerStrategies.length <= 3) {
                tableWrapper.classList.add('single-strategy');
            } else {
                tableWrapper.classList.remove('single-strategy');
            }
            
            // Adjust table width based on visible columns
            adjustTableWidth(displayStrategies.length);
            
            const rowsPerPage = elements.rowsPerPage.value === 'all' ? 
                filteredTrades.length : parseInt(elements.rowsPerPage.value);
            const totalPages = Math.ceil(filteredTrades.length / rowsPerPage);
            
            if (currentPage > totalPages && totalPages > 0) currentPage = totalPages;
            if (currentPage < 1) currentPage = 1;
            
            const startIndex = (currentPage - 1) * rowsPerPage;
            const endIndex = Math.min(startIndex + rowsPerPage, filteredTrades.length);
            const pageData = filteredTrades.slice(startIndex, endIndex);

            const colsPerStrategy = (showLotColumns ? 2 : 0) + 4 + (showTimeColumns ? 2 : 0) + (showBuySellColumns ? 3 : 0);
            const totalCols = 9 + (showTimeColumns ? 2 : 0) + (displayStrategies.length * colsPerStrategy);

            if (filteredTrades.length === 0) {
                elements.tableBody.innerHTML = `<tr><td colspan="${totalCols}" class="no-data">No trades found</td></tr>`;
                elements.pagination.style.display = 'none';
                return;
            }

            const rowsHTML = pageData.map(trade => createTableRow(trade, displayStrategies)).join('');
            elements.tableBody.innerHTML = rowsHTML;

            if (elements.rowsPerPage.value !== 'all') {
                elements.pagination.style.display = 'flex';
                elements.paginationInfo.textContent = `Showing ${startIndex + 1}-${endIndex} of ${filteredTrades.length.toLocaleString()}`;
                renderPagination(totalPages);
            } else {
                elements.pagination.style.display = 'none';
            }
        }

        function adjustTableWidth(visibleStrategyCount) {
            const tableWrapper = document.querySelector('.table-wrapper');
            
            if (!tableWrapper) return;
            
            // Calculate approximate columns
            // Base columns: 9 (S.No, Date, Strategy, Trade, Symbol, Qty, Entry, Exit, Profit)
            // Additional time columns: 2 if enabled
            // Per strategy: 4 base (PNL, DPNL, DBUY, DSELL) + optional (2 time + 2 lot + 3 buy/sell/qty/enprc/exprc)
            const baseColumns = 9 + (showTimeColumns ? 2 : 0);
            const colsPerStrategy = 4 + (showTimeColumns ? 2 : 0) + (showLotColumns ? 2 : 0) + (showBuySellColumns ? 3 : 0);
            const totalColumns = baseColumns + (visibleStrategyCount * colsPerStrategy);
        }

        function renderPagination(totalPages) {
            const maxButtons = 7;
            let startPage = Math.max(1, currentPage - Math.floor(maxButtons / 2));
            let endPage = Math.min(totalPages, startPage + maxButtons - 1);
            
            if (endPage - startPage < maxButtons - 1) {
                startPage = Math.max(1, endPage - maxButtons + 1);
            }

            let html = `<button class="pagination-btn" ${currentPage === 1 ? 'disabled' : ''} onclick="changePage(${currentPage - 1})">Prev</button>`;
            
            if (startPage > 1) {
                html += `<button class="pagination-btn" onclick="changePage(1)">1</button>`;
                if (startPage > 2) html += `<span style="padding: 0 5px; color: #9ca3af;">...</span>`;
            }

            for (let i = startPage; i <= endPage; i++) {
                html += `<button class="pagination-btn ${i === currentPage ? 'active' : ''}" onclick="changePage(${i})">${i}</button>`;
            }

            if (endPage < totalPages) {
                if (endPage < totalPages - 1) html += `<span style="padding: 0 5px; color: #9ca3af;">...</span>`;
                html += `<button class="pagination-btn" onclick="changePage(${totalPages})">${totalPages}</button>`;
            }

            html += `<button class="pagination-btn" ${currentPage === totalPages ? 'disabled' : ''} onclick="changePage(${currentPage + 1})">Next</button>`;
            
            elements.paginationControls.innerHTML = html;
        }

        function changePage(page) {
            const rowsPerPage = elements.rowsPerPage.value === 'all' ? filteredTrades.length : parseInt(elements.rowsPerPage.value);
            const totalPages = Math.ceil(filteredTrades.length / rowsPerPage);
            
            if (page < 1 || page > totalPages) return;
            
            currentPage = page;
            renderTable();
        }

        async function sortTable(column, th) {
            if (sortColumn === column) {
                sortDirection = sortDirection === 'asc' ? 'desc' : 'asc';
            } else {
                sortColumn = column;
                sortDirection = 'asc';
            }

            document.querySelectorAll('.report-table th').forEach(t => {
                t.classList.remove('sorted-asc', 'sorted-desc');
            });

            th.classList.add(sortDirection === 'asc' ? 'sorted-asc' : 'sorted-desc');

            filteredTrades.sort((a, b) => {
                let valA = a[column];
                let valB = b[column];

                if (typeof valA === 'string') valA = valA.toLowerCase();
                if (typeof valB === 'string') valB = valB.toLowerCase();

                if (valA < valB) return sortDirection === 'asc' ? -1 : 1;
                if (valA > valB) return sortDirection === 'asc' ? 1 : -1;
                return 0;
            });

            renderTable();
        }

        async function sortTableByStrategy(stratName, field, th) {
            const columnKey = `${stratName}_${field}`;
            
            if (sortColumn === columnKey) {
                sortDirection = sortDirection === 'asc' ? 'desc' : 'asc';
            } else {
                sortColumn = columnKey;
                sortDirection = 'asc';
            }

            document.querySelectorAll('.report-table th').forEach(t => {
                t.classList.remove('sorted-asc', 'sorted-desc');
            });

            th.classList.add(sortDirection === 'asc' ? 'sorted-asc' : 'sorted-desc');

            filteredTrades.sort((a, b) => {
                let valA, valB;
                
                // Handle lot_pnl specially since it's calculated
                if (field === 'lot_pnl') {
                    const detailsA = a.strategyDetails?.[stratName] || {};
                    const detailsB = b.strategyDetails?.[stratName] || {};
                    const lotA = detailsA.lot || 0;
                    const lotB = detailsB.lot || 0;
                    const pnlA = detailsA.pnl || 0;
                    const pnlB = detailsB.pnl || 0;
                    valA = (lotA && lotA !== 0) ? (pnlA / lotA) : 0;
                    valB = (lotB && lotB !== 0) ? (pnlB / lotB) : 0;
                } else if (field === 'lot_size') {
                    // Handle lot_size which is stored as 'lot'
                    valA = a.strategyDetails?.[stratName]?.lot || 0;
                    valB = b.strategyDetails?.[stratName]?.lot || 0;
                } else {
                    valA = a.strategyDetails?.[stratName]?.[field] || 0;
                    valB = b.strategyDetails?.[stratName]?.[field] || 0;
                }

                if (valA < valB) return sortDirection === 'asc' ? -1 : 1;
                if (valA > valB) return sortDirection === 'asc' ? 1 : -1;
                return 0;
            });

            renderTable();
        }


        async function exportToCSV() {
            if (filteredTrades.length === 0) {
                alert('No data to export');
                return;
            }

            const visibleBrokerStrategies = brokerStrategies.filter(s => !hiddenBrokerStrategies.has(s));
            const displayStrategies = visibleBrokerStrategies.length === brokerStrategies.length ? 
                brokerStrategies : visibleBrokerStrategies;

            const headers = ['S.No', 'Date', 'STG', 'Trade', 'Symbol', 'EN TIME', 'EX TIME', 'Qty', 'Entry', 'Exit', 'Profit'];
            displayStrategies.forEach(stratName => {
                const displayName = formatStrategyName(stratName);
                headers.push(`${displayName} LOT PNL`);
                headers.push(`${displayName} PNL`, `${displayName} DPNL`);
                headers.push(`${displayName} DBUY`, `${displayName} DSELL`);
                headers.push(`${displayName} entime`, `${displayName} extime`);
                if (showBuySellColumns) {
                    headers.push(`${displayName} QTY`);
                }
                if (showLotColumns) {
                    headers.push(`${displayName} LOT SIZE`);
                }
                if (showBuySellColumns) {
                    headers.push(`${displayName} ENPRC`, `${displayName} EXPRC`);
                }
            });
            
            const rows = filteredTrades.map(trade => {
                const row = [
                    trade.sno || '', trade.date || '', trade.strategy || '', trade.trade || '',
                    trade.symbol || '', trade.a_entime || '', trade.a_extime || '', 
                    trade.qty || '', trade.entry?.toFixed(2) || '',
                    trade.exit?.toFixed(2) || '', trade.profit || ''
                ];
                
                displayStrategies.forEach(stratName => {
                    const details = trade.strategyDetails?.[stratName] || {};
                    const lot = details.lot || 0;
                    const lot_pnl = (lot && lot !== 0) ? ((details.pnl || 0) / lot) : 0;
                    
                    // Calculate ENPRC and EXPRC based on trade type
                    let enprc = 0;
                    let exprc = 0;
                    if (trade.trade) {
                        const tradeType = trade.trade.toString().toUpperCase();
                        if (tradeType === 'SHORT') {
                            enprc = details.sell || 0;
                            exprc = details.buy || 0;
                        } else if (tradeType === 'LONG') {
                            enprc = details.buy || 0;
                            exprc = details.sell || 0;
                        }
                    }
                    
                    row.push(lot_pnl !== 0 ? lot_pnl.toFixed(0) : '');
                    row.push(details.pnl || '', details.dpnl || '');
                    row.push(details.dbuy || '', details.dsell || '');
                    row.push(details.entime || '', details.extime || '');
                    if (showBuySellColumns) {
                        row.push(details.qty || '');
                    }
                    if (showLotColumns) {
                        row.push(lot !== 0 ? parseFloat(lot).toFixed(1) : '');
                    }
                    if (showBuySellColumns) {
                        row.push(enprc !== 0 ? enprc.toFixed(2) : '', exprc !== 0 ? exprc.toFixed(2) : '');
                    }
                });
                
                return row;
            });

            const csvContent = [headers, ...rows].map(row => row.map(cell => `"${cell}"`).join(',')).join('\n');
            const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
            const link = document.createElement('a');
            link.href = URL.createObjectURL(blob);
            link.download = `trade_report_${new Date().toISOString().split('T')[0]}.csv`;
            link.click();
        }

        function toggleBuySellColumns() {
            showBuySellColumns = !showBuySellColumns;
            
            // Update original state if we're on "All Strategies"
            if (selectedStrategyNumber === null) {
                originalBuySellState = showBuySellColumns;
            }
            
            document.getElementById('buySellBtnText').textContent = showBuySellColumns ? 'Hide Buy/Sell/Qty' : 'Show Buy/Sell/Qty';
            const visibleBrokerStrategies = brokerStrategies.filter(s => !hiddenBrokerStrategies.has(s));
            const showAll = !brokerStrategies.length || visibleBrokerStrategies.length === brokerStrategies.length;
            buildTableHeaders(showAll ? 'all' : visibleBrokerStrategies);
            renderTable();
        }

        function toggleTimeColumns() {
            showTimeColumns = !showTimeColumns;
            
            // Update original state if we're on "All Strategies"
            if (selectedStrategyNumber === null) {
                originalTimeState = showTimeColumns;
            }
            
            document.getElementById('timeBtnText').textContent = showTimeColumns ? 'Hide Time' : 'Show Time';
            const visibleBrokerStrategies = brokerStrategies.filter(s => !hiddenBrokerStrategies.has(s));
            const showAll = !brokerStrategies.length || visibleBrokerStrategies.length === brokerStrategies.length;
            buildTableHeaders(showAll ? 'all' : visibleBrokerStrategies);
            renderTable();
        }

        function toggleLotColumns() {
            showLotColumns = !showLotColumns;
            
            // Update original state if we're on "All Strategies"
            if (selectedStrategyNumber === null) {
                originalLotState = showLotColumns;
            }
            
            document.getElementById('lotBtnText').textContent = showLotColumns ? 'Hide Lot' : 'Show Lot';
            const visibleBrokerStrategies = brokerStrategies.filter(s => !hiddenBrokerStrategies.has(s));
            const showAll = !brokerStrategies.length || visibleBrokerStrategies.length === brokerStrategies.length;
            buildTableHeaders(showAll ? 'all' : visibleBrokerStrategies);
            renderTable();
        }

        window.addEventListener('DOMContentLoaded', initEventListeners);
        
        window.addEventListener('DOMContentLoaded', () => {
            // Initialize button text based on default state
            document.getElementById('timeBtnText').textContent = showTimeColumns ? 'Hide Time' : 'Show Time';
            document.getElementById('lotBtnText').textContent = showLotColumns ? 'Hide Lot' : 'Show Lot';
        });

        window.addEventListener('message', async (event) => {
            const { type, data } = event.data;
            if (type === 'TRADES_DATA') {
                showLoading('Loading data...', `Processing ${data?.length || 0} trades`);
                try {
                    await new Promise(resolve => setTimeout(resolve, 100));
                    originalAllTrades = data || [];
                    
                    // Reset to ALL TIME and update date inputs based on available data
                    resetToAllTimeWithDataRange();
                    
                    // Apply date filtering
                    applyReportDateFilter();
                    
                    extractBrokerStrategies();
                    buildDateStructure();
                    updateDateFilterList();
                    cleanupSavedFilters();
                    await applyFilters();
                } finally {
                    hideLoading();
                }
            }
        });
        
        // Reset date range to ALL TIME and set inputs based on available data
        function resetToAllTimeWithDataRange() {
            const fromDateInput = document.getElementById('fromDateInput');
            const toDateInput = document.getElementById('toDateInput');
            
            if (originalAllTrades && originalAllTrades.length > 0) {
                // Find min and max dates from the data
                let minDate = null;
                let maxDate = null;
                
                originalAllTrades.forEach(trade => {
                    const dateParts = trade.date.split('/');
                    if (dateParts.length === 3) {
                        // Handle 2-digit years
                        let year = parseInt(dateParts[2]);
                        if (year < 100) {
                            year += 2000;
                        }
                        
                        const tradeDate = new Date(
                            year, // year
                            parseInt(dateParts[1]) - 1, // month (0-indexed)
                            parseInt(dateParts[0]) // day
                        );
                        
                        if (!minDate || tradeDate < minDate) {
                            minDate = tradeDate;
                        }
                        if (!maxDate || tradeDate > maxDate) {
                            maxDate = tradeDate;
                        }
                    }
                });
                
                // Set FROM date to earliest date in data using string format (YYYY-MM-DD)
                if (fromDateInput && minDate) {
                    const year = minDate.getFullYear();
                    const month = String(minDate.getMonth() + 1).padStart(2, '0');
                    const day = String(minDate.getDate()).padStart(2, '0');
                    fromDateInput.value = `${year}-${month}-${day}`;
                    
                    // Set min/max attributes for validation
                    fromDateInput.min = `${year}-${month}-${day}`;
                    if (maxDate) {
                        const maxYear = maxDate.getFullYear();
                        const maxMonth = String(maxDate.getMonth() + 1).padStart(2, '0');
                        const maxDay = String(maxDate.getDate()).padStart(2, '0');
                        fromDateInput.max = `${maxYear}-${maxMonth}-${maxDay}`;
                    }
                }
                
                // Set TO date to latest date in data using string format (YYYY-MM-DD)
                if (toDateInput && maxDate) {
                    const year = maxDate.getFullYear();
                    const month = String(maxDate.getMonth() + 1).padStart(2, '0');
                    const day = String(maxDate.getDate()).padStart(2, '0');
                    toDateInput.value = `${year}-${month}-${day}`;
                    
                    // Set min/max attributes for validation
                    if (minDate) {
                        const minYear = minDate.getFullYear();
                        const minMonth = String(minDate.getMonth() + 1).padStart(2, '0');
                        const minDay = String(minDate.getDate()).padStart(2, '0');
                        toDateInput.min = `${minYear}-${minMonth}-${minDay}`;
                    }
                    toDateInput.max = `${year}-${month}-${day}`;
                }
            } else {
                // No data, set to today
                const today = new Date();
                if (fromDateInput) {
                    fromDateInput.value = '';
                }
                if (toDateInput) {
                    const year = today.getFullYear();
                    const month = String(today.getMonth() + 1).padStart(2, '0');
                    const day = String(today.getDate()).padStart(2, '0');
                    toDateInput.value = `${year}-${month}-${day}`;
                }
            }
            
            // Set ALL TIME button as active
            document.querySelectorAll('.date-range-buttons .btn').forEach(btn => {
                btn.classList.remove('active');
                if (btn.textContent.trim() === 'ALL TIME') {
                    btn.classList.add('active');
                }
            });
        }

        // Date filtering function for report
        function applyReportDateFilter() {
            const fromDateInput = document.getElementById('fromDateInput');
            const toDateInput = document.getElementById('toDateInput');
            
            let filteredData = originalAllTrades;
            
            // Parse dates if they exist
            const fromDate = fromDateInput?.value ? new Date(fromDateInput.value) : null;
            const toDate = toDateInput?.value ? new Date(toDateInput.value) : null;
            
            // Filter trades based on date range
            if (fromDate || toDate) {
                filteredData = originalAllTrades.filter(trade => {
                    // Parse trade date (format: DD/MM/YY or DD/MM/YYYY)
                    const dateParts = trade.date.split('/');
                    if (dateParts.length !== 3) return true; // Keep if can't parse
                    
                    // Handle 2-digit years
                    let year = parseInt(dateParts[2]);
                    if (year < 100) {
                        year += 2000;
                    }
                    
                    const tradeDate = new Date(
                        year, // year
                        parseInt(dateParts[1]) - 1, // month (0-indexed)
                        parseInt(dateParts[0]) // day
                    );
                    
                    // Set both dates to start of day for inclusive comparison
                    if (fromDate) {
                        const fromDateStart = new Date(fromDate);
                        fromDateStart.setHours(0, 0, 0, 0);
                        if (tradeDate < fromDateStart) return false;
                    }
                    
                    if (toDate) {
                        // Set toDate to end of day for inclusive comparison
                        const toDateEnd = new Date(toDate);
                        toDateEnd.setHours(23, 59, 59, 999);
                        if (tradeDate > toDateEnd) return false;
                    }
                    
                    return true;
                });
            }
            
            // Set filtered data as current allTrades
            allTrades = filteredData;
            filteredTrades = [...allTrades];
        }

        // Date range handling functions for report
        function setReportDateRange(range) {
            const today = new Date();
            const toDateInput = document.getElementById('toDateInput');
            const fromDateInput = document.getElementById('fromDateInput');
            
            // Set TO date to today using string format
            const todayYear = today.getFullYear();
            const todayMonth = String(today.getMonth() + 1).padStart(2, '0');
            const todayDay = String(today.getDate()).padStart(2, '0');
            toDateInput.value = `${todayYear}-${todayMonth}-${todayDay}`;
            
            if (range === '3M') {
                // Last 3 months
                const threeMonthsAgo = new Date(today);
                threeMonthsAgo.setMonth(today.getMonth() - 3);
                const year = threeMonthsAgo.getFullYear();
                const month = String(threeMonthsAgo.getMonth() + 1).padStart(2, '0');
                const day = String(threeMonthsAgo.getDate()).padStart(2, '0');
                fromDateInput.value = `${year}-${month}-${day}`;
            } else if (range === 'YTD') {
                // Year to date - January 1st of current year
                const year = today.getFullYear();
                fromDateInput.value = `${year}-01-01`;
            } else if (range === 'ALL') {
                // All time - reset to data range
                resetToAllTimeWithDataRange();
                reprocessReportData();
                return; // Exit early as resetToAllTimeWithDataRange handles button activation
            }
            
            // Update active button styling
            document.querySelectorAll('.date-range-buttons .btn').forEach(btn => {
                btn.classList.remove('active');
            });
            event.target.classList.add('active');
            
            // Reprocess data with new date filter
            reprocessReportData();
        }

        // Reprocess report data after date change
        async function reprocessReportData() {
            if (!originalAllTrades || originalAllTrades.length === 0) return;
            
            // Apply date filtering
            applyReportDateFilter();
            
            // Rebuild necessary structures for the filtered data
            extractBrokerStrategies();
            buildDateStructure();
            updateDateFilterList();
            cleanupSavedFilters();
            
            // Refresh table only
            await applyFilters();
        }

        // Initialize date inputs on load
        window.addEventListener('DOMContentLoaded', () => {
            const fromDateInput = document.getElementById('fromDateInput');
            const toDateInput = document.getElementById('toDateInput');
            
            // Initial setup using string format
            const today = new Date();
            const year = today.getFullYear();
            const month = String(today.getMonth() + 1).padStart(2, '0');
            const day = String(today.getDate()).padStart(2, '0');
            
            if (toDateInput) {
                toDateInput.value = `${year}-${month}-${day}`;
            }
            
            // Set default to ALL TIME (no FROM date)
            if (fromDateInput) {
                fromDateInput.value = '';
            }
            
            // Set ALL TIME button as active by default
            document.querySelectorAll('.date-range-buttons .btn').forEach((btn) => {
                if (btn.textContent.trim() === 'ALL TIME') {
                    btn.classList.add('active');
                }
            });
            
            // Add event listeners for manual date changes
            if (fromDateInput) {
                fromDateInput.addEventListener('change', () => {
                    // Remove active class from all buttons when manually changing dates
                    document.querySelectorAll('.date-range-buttons .btn').forEach(btn => {
                        btn.classList.remove('active');
                    });
                    // Reprocess data
                    reprocessReportData();
                });
                
                // Add keyboard navigation with swapped arrow behavior
                fromDateInput.addEventListener('keydown', (e) => {
                    if (e.key === 'ArrowUp') {
                        e.preventDefault();
                        fromDateInput.stepDown();
                        document.querySelectorAll('.date-range-buttons .btn').forEach(btn => btn.classList.remove('active'));
                        reprocessReportData();
                    } else if (e.key === 'ArrowDown') {
                        e.preventDefault();
                        fromDateInput.stepUp();
                        document.querySelectorAll('.date-range-buttons .btn').forEach(btn => btn.classList.remove('active'));
                        reprocessReportData();
                    }
                });
            }
            
            if (toDateInput) {
                toDateInput.addEventListener('change', () => {
                    // Remove active class from all buttons when manually changing dates
                    document.querySelectorAll('.date-range-buttons .btn').forEach(btn => {
                        btn.classList.remove('active');
                    });
                    // Reprocess data
                    reprocessReportData();
                });
                
                // Add keyboard navigation with swapped arrow behavior
                toDateInput.addEventListener('keydown', (e) => {
                    if (e.key === 'ArrowUp') {
                        e.preventDefault();
                        toDateInput.stepDown();
                        document.querySelectorAll('.date-range-buttons .btn').forEach(btn => btn.classList.remove('active'));
                        reprocessReportData();
                    } else if (e.key === 'ArrowDown') {
                        e.preventDefault();
                        toDateInput.stepUp();
                        document.querySelectorAll('.date-range-buttons .btn').forEach(btn => btn.classList.remove('active'));
                        reprocessReportData();
                    }
                });
            }
            
            // Auto-close calendar on click outside
            document.addEventListener('click', function(event) {
                const isFromDate = fromDateInput && fromDateInput.contains(event.target);
                const isToDate = toDateInput && toDateInput.contains(event.target);
                
                if (!isFromDate && !isToDate) {
                    if (fromDateInput && document.activeElement === fromDateInput) {
                        fromDateInput.blur();
                    }
                    if (toDateInput && document.activeElement === toDateInput) {
                        toDateInput.blur();
                    }
                }
            });
            
            // Auto-close calendar on Escape key
            document.addEventListener('keydown', function(event) {
                if (event.key === 'Escape') {
                    if (fromDateInput && document.activeElement === fromDateInput) {
                        fromDateInput.blur();
                    }
                    if (toDateInput && document.activeElement === toDateInput) {
                        toDateInput.blur();
                    }
                }
            });
        });
        
        // Navigation functions for arrow buttons
        function navigateFromDate(direction) {
            const fromDateInput = document.getElementById('fromDateInput');
            if (!fromDateInput) return;
            
            let currentDate;
            if (fromDateInput.value) {
                currentDate = new Date(fromDateInput.value + 'T00:00:00');
            } else {
                currentDate = new Date();
            }
            
            let targetDate;
            if (direction === 'prev') {
                // Previous month's first date
                targetDate = new Date(currentDate.getFullYear(), currentDate.getMonth() - 1, 1);
            } else {
                // Next month's first date
                targetDate = new Date(currentDate.getFullYear(), currentDate.getMonth() + 1, 1);
            }
            
            const year = targetDate.getFullYear();
            const month = String(targetDate.getMonth() + 1).padStart(2, '0');
            const day = '01';
            
            fromDateInput.value = `${year}-${month}-${day}`;
            document.querySelectorAll('.date-range-buttons .btn').forEach(btn => btn.classList.remove('active'));
            reprocessReportData();
        }
        
        function navigateToDate(direction) {
            const toDateInput = document.getElementById('toDateInput');
            if (!toDateInput) return;
            
            let currentDate;
            if (toDateInput.value) {
                currentDate = new Date(toDateInput.value + 'T00:00:00');
            } else {
                currentDate = new Date();
            }
            
            let targetDate;
            if (direction === 'prev') {
                // Previous month's last date
                targetDate = new Date(currentDate.getFullYear(), currentDate.getMonth(), 0);
            } else {
                // Next month's last date
                targetDate = new Date(currentDate.getFullYear(), currentDate.getMonth() + 2, 0);
            }
            
            const year = targetDate.getFullYear();
            const month = String(targetDate.getMonth() + 1).padStart(2, '0');
            const day = String(targetDate.getDate()).padStart(2, '0');
            
            toDateInput.value = `${year}-${month}-${day}`;
            document.querySelectorAll('.date-range-buttons .btn').forEach(btn => btn.classList.remove('active'));
            reprocessReportData();
        }
    </script>
</body>
</html>
